<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术美术学习记录</title>
  
  
  <link href="https://aspect-ux.github.io/atom.xml" rel="self"/>
  
  <link href="https://aspect-ux.github.io/"/>
  <updated>2023-07-13T04:33:24.453Z</updated>
  <id>https://aspect-ux.github.io/</id>
  
  <author>
    <name>Aspect</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Geometry(几何)</title>
    <link href="https://aspect-ux.github.io/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/"/>
    <id>https://aspect-ux.github.io/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/</id>
    <published>2023-07-13T01:35:24.619Z</published>
    <updated>2023-07-13T04:33:24.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduce-to-Geometry"><a href="#Introduce-to-Geometry" class="headerlink" title="Introduce to Geometry"></a>Introduce to Geometry</h1><h2 id="Examples-of-Geometry"><a href="#Examples-of-Geometry" class="headerlink" title="Examples of Geometry"></a>Examples of Geometry</h2><p>机械</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094334796.png" class title="image-20230713094334796"><p>水</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094400111.png" class title="image-20230713094400111"><p>毛发</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094451880.png" class title="image-20230713094451880"><h2 id="Representation-of-Geometry"><a href="#Representation-of-Geometry" class="headerlink" title="Representation of Geometry"></a>Representation of Geometry</h2><p><strong>Implicit(隐式表达)</strong></p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094634138.png" class title="image-20230713094634138"><p><strong>Explicit(显式表达)</strong></p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094802801.png" class title="image-20230713094802801"><p>直接通过uv映射方式定义</p><p>隐式不知道谁是函数的结果是哪个变量，显示知道</p><p><code>Geometry is hard!</code></p><p>隐式表达，一般看表达式，但是光看表达式并不直观。algebraic方式。</p><p>另一种方法是constructive solid geometry（csg,构造立体几何法)</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713095753987.png" class title="image-20230713095753987"><p>距离函数Distance Function</p><p>希望blend得到AB的中间状态</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713100223756.png" class title="image-20230713100223756"><p>如果是第一行的图，结果不能得到左黑右白的中间态</p><p>第二行使用SDF，通过blend，可以得到0的位置，颜色围绕0开始渐变。</p><p>插值得到的SDF再转回原图像</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/166.png" class>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduce-to-Geometry&quot;&gt;&lt;a href=&quot;#Introduce-to-Geometry&quot; class=&quot;headerlink&quot; title=&quot;Introduce to Geometry&quot;&gt;&lt;/a&gt;Introduce to Geometry&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Shading(着色)</title>
    <link href="https://aspect-ux.github.io/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/"/>
    <id>https://aspect-ux.github.io/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/</id>
    <published>2023-07-11T02:58:51.658Z</published>
    <updated>2023-07-13T01:35:13.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading(着色)"></a>Shading(着色)</h1><h2 id="Visibility-Occulusion-可见性-遮蔽"><a href="#Visibility-Occulusion-可见性-遮蔽" class="headerlink" title="Visibility/Occulusion(可见性/遮蔽)"></a>Visibility/Occulusion(可见性/遮蔽)</h2><p><strong>Painter’s Algorithm</strong> 从后往前画</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711122733524.png" class title="image-20230711122733524"><p>但是由于自遮挡的关系，有些无法具体描述远近的（如上图左右面的绘制），绘制顺序显得尤为重要。</p><p>左，下，右，上，这个顺序结果正确</p><p>但是右，上，左，下，由于左下两面的错误遮挡，导致结果错误。</p><p>假如一个模型是两个蛇状管道相互缠绕组合而成的，那渲染先后的问题就更加困难，正方体能够区分不同面无非是一个面遮挡另一个，后者不规则的分区有着非单一的复杂遮挡关系，如此看来这种算法局限性也很大</p><p><strong>结论：</strong> 一定程度上画家算法是有效的，但是sorting layer的问题是难以解决的。</p><p><strong>ZBuffer</strong> 深度缓存</p><p>为了解决画家算法的问题，引入深度缓存</p><p>简而言之，对每个像素的深度进行保存，保留最近的那个深度值</p><ul><li>framebuffer存颜色值</li><li>depth buffer(z-buffer)存深度值</li></ul><p>效果如下图，记z值为positive</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711125920188.png" class title="image-20230711125920188"><p>具体代码实现算法，记初始zbuffer的值都是无限大，每绘制一个图元都来一次二重循环遍历所有像素，不断装填覆盖更小的z</p><p>时间复杂度O(n),设三角形个数为n,三角形之间覆盖的个数为常数个。</p><p>zbuffer的算法显然是一个很好的解决方法。</p><p>【提高】</p><p>MSAA常用于反走样，一个像素中有多个采样点，然后根据采样点的分布率来评判该像素颜色深浅</p><p>如果绘制有重叠部分的两个三角形，对于抗锯齿的部分，如果只是对像素进行z-buffer，然后边缘锯齿用MSAA,</p><p>结果也还行。</p><p>想要更好的结果，我们也许可以对采样点进行zbuffer,毕竟像素是呆板的块状，如果能够进一步细化，或许分布率不会变，却也能让先后关系更精确，进而结果更精确。</p><h2 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination&amp;Shading"></a>Illumination&amp;Shading</h2><p><strong>BlinnPhong Model</strong></p><p>布林冯光照模型</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711133718085.png" class title="image-20230711133718085"><p>三个相加等于着色结果</p><p>着色是局部的</p><p><strong>着色不等于阴影（shading != shadow)</strong></p><p>n是法线向量，h是半程向量（入射光向量l与眼睛视线向量v的单位向量和）</p><p>以下为布林冯的高光</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711140322707.png" class title="image-20230711140322707"><p>最终结果</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711141207203.png" class title="image-20230711141207203"><p><strong>Shading Frequency</strong> 着色频率问题</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711142158445.png" class title="image-20230711142158445"><h2 id="Graphics-Pipeline-Real-time-rendering"><a href="#Graphics-Pipeline-Real-time-rendering" class="headerlink" title="Graphics Pipeline(Real-time rendering)"></a>Graphics Pipeline(Real-time rendering)</h2><p>图形渲染管线，实时渲染管线</p><p>Application 应用阶段，输入顶点数据</p><p>Geometry 几何阶段</p><p>Rasterization 光栅化阶段</p><ul><li><p>Shading 着色（shaded fragment)</p></li><li><p>framebuffer （严格来说属于光栅化）</p></li></ul><p>输出屏幕</p><p>除了常规的fragment shader,vertex shader</p><p>现在还有compute shader(通用)，geometry shader(几何shader)等可编程部分</p><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>每个三角形顶点都有一个uv坐标（0，1），可以反复平铺</p><h3 id="Barycentric-coordinates-重心坐标"><a href="#Barycentric-coordinates-重心坐标" class="headerlink" title="Barycentric coordinates(重心坐标)"></a>Barycentric coordinates(重心坐标)</h3><p>interporate across triangle在三角形内进行插值，希望三角形内部得到平滑过渡</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712105733661.png" class title="image-20230712105733661"><p>α，β，γ均大于等于0，重心在三角形内</p><p>A点在重心坐标系的重心坐标（α，β，γ）为（1，0，0），B为（0，1，0）</p><p>三角形的重心坐标计算公式就是相加除以3，重心坐标为（1/3，1/3，1/3）</p><p>三角形内任意一点的重心坐标计算结论如下</p><p><strong>结论</strong></p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712110740529.png" class title="image-20230712110740529"><p>【补充】</p><ul><li>α+β+γ = 1，是重心坐标的性质，同时是重心坐标在ABC平面上的要求</li><li>三维中的属性在三维中做插值，否则投影到屏幕再做可能会因为重心不一致而错误；</li></ul><h3 id="Texture-queries"><a href="#Texture-queries" class="headerlink" title="Texture queries"></a>Texture queries</h3><p>a pixel on a texture is a texel(纹素)</p><p>texture mapping简单应用：通过查uv来将纹理的值作为Diffuse Color</p><p>纹理太小，采样后会被拉大texture magnification</p><p>最后结果不精确，得到的会是明显的像素块的非连续结果</p><p><strong>解决方法：</strong>纹素，屏幕分辨率差别大，texture queries的时候，用屏幕像素坐标查询texture的uv,</p><p>使用双线性插值（Bilinear Interpolation) 来解决非连续的问题。</p><p>水平、竖直都进行下述插值操作，对texel的4个像素进行插值</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712134134465.png" class title="image-20230712134134465"><p>另有Bicubic的方法，取周围16个像素</p><p><strong>1. Point Sample problem</strong></p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712175243366.png" class title="image-20230712175243366"><p>采样纹理的时候为什么会出现这样的走样（artifact)？</p><p>当纹理特别大，哪怕一个纹素也包括了很多高频信息，人眼跟不上变化频率，于是产生了走样。</p><p>或者，texture queries 的时候，采样一个像素的时候只使用一个采样点，采样频率不够，导致最后结果表现不够精确连续。</p><p>增加采样点虽然理论可行，但是计算量太大。</p><p><strong>2. Range Query Problem</strong></p><p>范围查询不像点查询一样进行采样，而是直接查询一个范围的结果，这样就避免了上述的计算量。</p><p>范围查询根据功能可以分为平均，最大，最小….很多种不同类的方式。</p><p>引入<strong>Mipmap</strong>的概念，(fast,approximate,square)，分为多级，分辨率逐级减半，D = log(L)</p><p>使用mipmap比原来多用了1/3的空间存储</p><p>如何使用mipmap?</p><p>离人眼近的地方，使用低级别的，分辨率更高的，离人眼远的地方，对精度要求低，可以用分辨率更低的mipmap。</p><p>【注】实际操作中，由于mipmap本身是方块，查询方式离散，层与层之间还需再进行插值。本身xy两轴上分别做了插值让纹理适配原像素，然后又在层与层直接插值，称之为三线性插值（trilinear interpolation)</p><p><strong>3. mipmap limitation &amp; Anisotropic Filter</strong></p><p>mipmap远处会出现<strong>过度模糊</strong>的问题，</p><p>问题在哪？其实还是出在三线性插值上，之前提到mipmap的approximate的特性，本身插值方法就是人为近似的，而且又只能处理方形区域的查询。</p><p>引入效果更好的方法。</p><p>Anisotropic Filter各向异性过滤（ripmap)</p><p>游戏中2x指的是左上角两层的范围，存储量收敛到原来的3倍，游戏中一般都可以开到最高，对性能不会有任何影响。</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193451568.png" class title="image-20230712193451568"><p>这种方法由于x,y方向都有拉伸，查询不局限于方形，扩展到矩形</p><p><strong>但是</strong>如下图，screen上的一块像素表达的内容在texture上也许是斜着的，使用各向异性查询，就要求将整块斜块用矩形包围，最后结果overblur。irregular footprint（覆盖区） in texture的问题</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193630633.png" class title="image-20230712193630633"><p>竖着的长条可以解决，但是斜着的就不好解决。</p><p><strong>EWA filtering</strong></p><p>将查询范围用多个圆包围，多次查询</p><p>可以处理不规则图形，但是计算量很大</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712195236130.png" class title="image-20230712195236130"><h3 id="Application-of-textures"><a href="#Application-of-textures" class="headerlink" title="Application of textures"></a>Application of textures</h3><p>现代GPU中，texture = memory + range query(filtering)</p><ol><li><p>Environment Map 环境贴图，物体反射周围的光;描述不同方向的光照信息。</p><p>Shperical Map,发生扭曲；Cube Map</p></li><li><p>Bump/Normal Map</p><p>凹凸贴图如何绘制法线制造凹凸感？</p><ul><li>设原来法线为（0，0，1）</li><li>求偏导（derivatives),假设u,v变化单位1</li></ul><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230713090701583.png" class title="image-20230713090701583"><p>切线逆时针旋转90度得到法线</p><p>得到法线（-dp/du,-dp/dv,1)</p><p>这样，通过凹凸贴图的纹理映射，制造假的法线，实现结果的凹凸。</p></li><li><p>Displacement Map,位移贴图，真正的移动了原模型，不同于凹凸贴图。</p><p>要求三角形很细，三角形的频率要比纹理高；采样率高，模型足够细致</p><p>DX上有一个方法叫动态细分，即便是模型不是很精细，但是可以根据需要进行选择性移动</p></li></ol><p>其它</p><p><strong>Provide Precompute shading</strong></p><p><strong>3d textures and volume rendering</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shading-着色&quot;&gt;&lt;a href=&quot;#Shading-着色&quot; class=&quot;headerlink&quot; title=&quot;Shading(着色)&quot;&gt;&lt;/a&gt;Shading(着色)&lt;/h1&gt;&lt;h2 id=&quot;Visibility-Occulusion-可见性-遮蔽&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio下Cpp的配置</title>
    <link href="https://aspect-ux.github.io/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/"/>
    <id>https://aspect-ux.github.io/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/</id>
    <published>2023-05-24T06:18:26.100Z</published>
    <updated>2023-07-06T06:23:30.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VS-CPP-配置"><a href="#VS-CPP-配置" class="headerlink" title="VS CPP 配置"></a>VS CPP 配置</h1><p>在VS上编写cpp程序时，经常出现少了xx库或者xx undefined</p><p>分为静态和动态配置方法</p><ol><li><p>下载对应资源包</p></li><li><p>认识配置方法</p></li></ol><p>属性面板有三个选项，</p><img src="/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/1.png" class title="image-20230524142140450"><p><strong>动态载入：</strong> ①对于下载的include 在”C/C++”下配置；②lib在linker下配置，具体lib文件在linker-&gt;input下配置；③dll一般放在根目录（或者32dll放在sysWOW64,64dll放在system32下）</p><p><strong>静态载入：</strong> 前两步和之前一样，但是第三步变成在linker-&gt;proprocessor中加入对应宏</p><p>注意对应版本文件夹</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VS-CPP-配置&quot;&gt;&lt;a href=&quot;#VS-CPP-配置&quot; class=&quot;headerlink&quot; title=&quot;VS CPP 配置&quot;&gt;&lt;/a&gt;VS CPP 配置&lt;/h1&gt;&lt;p&gt;在VS上编写cpp程序时，经常出现少了xx库或者xx undefined&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="随记" scheme="https://aspect-ux.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Rasterization(光栅化)</title>
    <link href="https://aspect-ux.github.io/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/"/>
    <id>https://aspect-ux.github.io/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/</id>
    <published>2023-05-23T12:15:23.290Z</published>
    <updated>2023-07-06T13:07:50.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization(光栅化)"></a>Rasterization(光栅化)</h1><p>总览</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/1.png" class><h2 id="光栅化流程"><a href="#光栅化流程" class="headerlink" title="光栅化流程"></a>光栅化流程</h2><p>之前提到了MVP过程，在这之后,所有的物体都会停留在【-1，1】^3</p><p>立方体(Canonical Cube)空间中，然后要进行光栅化。</p><h3 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a>Viewport Transformation(视口变换)</h3><p>也就是将物体“画”到屏幕上，这里具体要做的是上图中的viewport mapping</p><p><strong>即将【-1，1】拉伸(重映射remapping)到【width,height】的屏幕上</strong></p><p>设置什么样的变换矩阵才能变换成功呢？</p><p>（其实在半兰伯特光照模型中就有这个思路，先乘以1/2，然后加上1/2，就转换到【0，1】区间了。）</p><p>根据这个思路得到转换矩阵</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230523205240615.png" class title="image-20230523205240615"><p>需要注意：这个变换与z值无关</p><h3 id="Rasterizing-triangles-into-pixels"><a href="#Rasterizing-triangles-into-pixels" class="headerlink" title="Rasterizing triangles into pixels"></a>Rasterizing triangles into pixels</h3><p>上面只是说了光栅化是画物体到屏幕，具体来说，物体是由一个又一个多边形构成，最基本的元素是三角形，我们要做的是让这个三角行用像素画出来(或填充)，进而在屏幕上显示。</p><p>具体实现算法就是通过遍历像素，判断像素中心是否在三角形内。</p><p><strong>如何判断是否在三角形内</strong></p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_2.png" class><p>假设从ABC逆时针方向来看，</p><p>我们发现一个规律，但凡P点在三角形内，一定满足</p><p>n1 = AB x AP</p><p>n2 = BC x BP</p><p>n3 = CA x CP</p><p>三个方向都是朝着纸面向上，也就是说z分量大于0(充要条件),否则，则不在三角形内。</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_3.png" class title="homework2_3"><p>这样就可以判断是否在三角形内</p><p><strong>另外遍历像素很麻烦，这里引入包围盒(Bounding Box)</strong></p><p> 引入axis-aligned bounding box(AABB)轴对齐包围盒</p><p>每一行都根据三角形边界用一个包围盒，这样就不会浪费，从而实现光栅化的加速。</p><p>但是并不简单。</p><p>在这里如果要单纯光栅化一个三角形，我们只知道三个顶点的坐标，这里可以粗略地将三角形用方形框住，只遍历方形中的像素。</p><h2 id="光栅化细节之反走样"><a href="#光栅化细节之反走样" class="headerlink" title="光栅化细节之反走样"></a>光栅化细节之反走样</h2><p>如果只是按照上述流程，结果其实并不理想。</p><p>最明显的就是，像素是方形，那么填充三角形会产生锯齿Jaggies</p><h3 id="Aliasing-走样"><a href="#Aliasing-走样" class="headerlink" title="Aliasing(走样)"></a>Aliasing(走样)</h3><p>sample artifacts,采样所造成的瑕疵</p><ul><li>Jaggies(锯齿)</li><li>Moire (摩尔纹)</li><li>Wagon Wheel Illusion(车轮效应) 时间上采样的问题</li></ul><p>信号变化太快，采样跟不上</p><h3 id="如何反走样？-Antialiasing-Ideas"><a href="#如何反走样？-Antialiasing-Ideas" class="headerlink" title="如何反走样？(Antialiasing Ideas)"></a>如何反走样？(Antialiasing Ideas)</h3><h4 id="卷积、时域、频域、空间域和滤波"><a href="#卷积、时域、频域、空间域和滤波" class="headerlink" title="卷积、时域、频域、空间域和滤波"></a>卷积、时域、频域、空间域和滤波</h4><ol><li>首先：这里用信号的方式表示反走样如下图，不同的函数，相同的采样点，采样结果却一样，导致不同信号无法区分，于是产生了走样</li></ol><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145800199.png" class title="image-20230706145800199"><ol start="2"><li><p><strong>反走样的方法是Blurring</strong>：采样前做滤波(pre-filtering)，什么是滤波？抹除特定的频率。</p><p>滤波 = 卷积 = 平均，顺序不能反，不然不过是将走样后的图像再模糊了一下，还是走样的。</p></li><li><p>什么是卷积、时域、频域？</p><p>下图说明了卷积的过程，特定的卷积核对信号本身进行加权操作</p></li></ol><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706152137019.png" class title="image-20230706152137019"><ul><li><p><strong>时域（time domain）</strong>自变量是时间,即横轴是时间,纵轴是信号的变化。其动态信号x（t）是描述信号在不同时刻取值的函数。</p></li><li><p><strong>频域（frequency domain）</strong>自变量是频率,即横轴是频率,纵轴是该频率信号的幅度,也就是通常说的频谱图。</p></li><li><p>**空间域(spatial domain) **     简称空域，又称图像空间(image space)，一般这个概念会出现在数字图像处理中，指由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。</p></li></ul><h4 id="Fourier-Transform-傅里叶变换"><a href="#Fourier-Transform-傅里叶变换" class="headerlink" title="Fourier Transform(傅里叶变换)"></a>Fourier Transform(傅里叶变换)</h4><p>傅里叶变换能做什么？将信号从时域转换到频域（对于一张图像，时域指不同空间的信号？；频域指的是信号随频率变化的函数）</p><p>傅里叶展开：任何周期函数都可以写成正弦余弦和的函数</p><p>傅里叶变换和逆傅里叶变换，将不同的函数之间相互转换</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145241029.png" class title="image-20230706145241029"><p>如以下例子</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150533898.png" class title="image-20230706150533898"><p>首先确定信号变换时一般都是默认为周期性函数，但是对于非周期性的图像，则会水平竖直平铺多张图像，</p><p>边界变化剧烈，于是有了两条白线。</p><p>任何信号在不同频率的样子叫做频谱。</p><p>下图为高通</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150930320.png" class title="image-20230706150930320"><p>下图为低通</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151033905.png" class title="image-20230706151033905"><p>下图为高低频都去掉的结果（中通滤波）</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151222306.png" class title="image-20230706151222306"><h4 id="Convolution-Theorem-卷积定理"><a href="#Convolution-Theorem-卷积定理" class="headerlink" title="Convolution Theorem(卷积定理)"></a>Convolution Theorem(卷积定理)</h4><p>spatial domain上的卷积（平均）模糊等价于</p><p>frequency domain上的乘积</p><p>时域的卷积等于频域的乘积（暂时不清楚spatial domain和time domain的区别）</p><p>尤其注意，卷积定理有两个，时域的乘积 也等于 频域的卷积，对偶性（详情查询）</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706153322488.png" class title="image-20230706153322488"><p>上图的卷积核，也叫做滤波器，由于上图将低频信息保存了下来，也叫做低通滤波器low box filter</p><p>越大的box结果越模糊。</p><p>走样现象的另一种解释</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706155140903.png" class title="image-20230706155140903"><p>像素很大，采样很稀疏，频谱密集</p><p>采样速度不够快，导致频谱混叠，信息损失，造成走样</p><h4 id="归纳反走样或减少走样方法"><a href="#归纳反走样或减少走样方法" class="headerlink" title="归纳反走样或减少走样方法"></a>归纳反走样或减少走样方法</h4><ol><li><p>Increase sample rate(reduce aliasing error)</p></li><li><p>先模糊后反走样，先低通，后采样，高频滤掉，就不会产生重叠；</p><p>关键点在于，频谱混叠导致结果失真，但是模糊只会丢掉高频细节。后者显然更好</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706160213696.png" class title="image-20230706160213696"></li></ol><h3 id="实际应用中的反走样"><a href="#实际应用中的反走样" class="headerlink" title="实际应用中的反走样"></a>实际应用中的反走样</h3><h4 id="MSAA-Multi-Sample-Anti-Aliasing"><a href="#MSAA-Multi-Sample-Anti-Aliasing" class="headerlink" title="MSAA(Multi Sample Anti-Aliasing)"></a>MSAA(Multi Sample Anti-Aliasing)</h4><p>将一个像素分成多个“小像素”</p><p>如4x4</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706161007121.png" class title="image-20230706161007121"><p>根据小像素覆盖率来进行模糊，这样能够更准确的确定模糊度，然后采样</p><p>注意：MSAA并不是通过提高分辨率真的增加”小像素“，只不过是在一个像素里采样若干个点</p><p>但是上述例子的代价是增加了4x4共16倍的采样量</p><p>另外还有FXAA（后处理，得到锯齿才处理）和TAA等方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rasterization-光栅化&quot;&gt;&lt;a href=&quot;#Rasterization-光栅化&quot; class=&quot;headerlink&quot; title=&quot;Rasterization(光栅化)&quot;&gt;&lt;/a&gt;Rasterization(光栅化)&lt;/h1&gt;&lt;p&gt;总览&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Transformation(变换)</title>
    <link href="https://aspect-ux.github.io/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/"/>
    <id>https://aspect-ux.github.io/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/</id>
    <published>2023-05-17T16:09:51.767Z</published>
    <updated>2023-07-06T06:18:12.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h1><h2 id="变换的理论及推导"><a href="#变换的理论及推导" class="headerlink" title="变换的理论及推导"></a>变换的理论及推导</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation"></a>Why Transformation</h3><p><strong>Q1： 为什么要学习变换呢？</strong></p><p>A1： 动画的实现，光栅化图像变换投射进“人眼”。由于计算机最终的变换服务于数学世界，于是同一用矩阵来表示变换，线性代数中学过对应知识。</p><p><strong>Q2: 举例有哪些变换？</strong></p><p>A2： Scale Matrix，缩放；Reflection Matrix,对称(镜像)；</p><p>Shear Matrix,切变(有称”错切“，”斜切“)；</p><p>Rotate Matrix…</p><p>旋转矩阵推导</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/推导旋转矩阵.jpg" alt="image-20230518004250114" style="zoom: 67%;"><p>到目前为止的变换，我们都可以对(x,y…)进行线性变换(Liner transformation)得到变换结果(x’,y’)</p><p><strong>但是平移变换不行？</strong></p><p>试想一下，如果对x平移一个单位，那么变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/平移变换.jpg" alt="image-20230518005707401" style="zoom:80%;"><p>无法用一个矩阵就解决变换，（上面的变换形式引出仿射变换(Affine Transformation)的概念），同时进行线性和平移变换</p><p>接下来</p><h3 id="Homogeneous-coordinates-齐次坐标"><a href="#Homogeneous-coordinates-齐次坐标" class="headerlink" title="Homogeneous coordinates(齐次坐标)"></a>Homogeneous coordinates(齐次坐标)</h3><p>要想用一个矩阵表示所有变换</p><p>这里引入了齐次坐标的概念，以二维举例，引入第三维度</p><p>设点的第三维度为1，向量为0.</p><ul><li>之所以向量为0，是因为向量具有方向不变性，假设进行平移变换，我们希望这个向量前后不变的；但是如果但三维度不是0，那么结果就有可能出现向量方向的变化。</li><li>之所以点为1，是因为这样就解决了<strong>平移问题</strong>，通过增加维度，使得一个矩阵同时表示平移和线性变换。</li></ul><p>另外</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/%E7%82%B9%E4%B8%8E%E5%90%91%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="image-20230518012256246"><p>在齐次坐标系下，不难推导出，点+点等于中点，只需同时除以w=2,使得w回归为1</p><p>最后放一张仿射变换的图片和常见变换公式的图片</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/affineTransformation.png" class title="image-20230518012637415"><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518013201379.png" class title="image-20230518013201379"><h3 id="Composing-Transform-变换组合"><a href="#Composing-Transform-变换组合" class="headerlink" title="Composing Transform(变换组合)"></a>Composing Transform(变换组合)</h3><ul><li><p>我们需要知道，复杂的一连串的变换是可以组合的，因为虽然变换越多，矩阵越多，但是由于都是乘法，根据矩阵结合律可以最终合成一个</p></li><li><p>平移和旋转具有严格先后顺序，毕竟先加后乘，与先乘后加结果不一样；具体来说是先乘后加，先变换后平移</p></li></ul><p><strong>Decomposing complex transform(解构复杂变换)</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518014414740.png" class title="image-20230518014414740"><p>由图知，直接从图一到图四其实并不方便。</p><p>我们先把物体的旋转中心移平移回原点，然后旋转，最后平移回去。（因为我们只能做原点为旋转中心的旋转，不然就无法用之前的固定结论）。</p><p><strong>如果不以原点为旋转中心，以某个轴为旋转中心轴</strong></p><p>绕z轴旋转(本来二维的扩展成三维后等价绕z轴旋转)</p><ul><li>绕哪个轴，哪个轴的坐标为位置不变</li></ul><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518205820940.png" class title="image-20230518205820940"><p><strong>拓展到3d transformation也是一样</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518210227508.png" class title="image-20230518210227508"><p><strong>ps:</strong> 按照直觉可能会觉得绕y轴的旋转矩阵有问题，其实是因为该图表示的是右手坐标系的变换；已知<code>x.crossproduct(z) = -z.crossproduct(x)</code>(右手法则)，这里XxZ = -Y,所以需要对α取反。</p><p><strong>Rodrigues’s Rotation Formula</strong></p><p>描述了绕任意轴旋转任意角度的变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518213219770.png" class title="image-20230518213219770"><p>下面来推导一下这个公式同时引入四元数的学习</p><p>参考：<a href="https://www.zhihu.com/tardis/zm/art/78987582?source_id=1005">四元数和旋转(Quaternion &amp; rotation) (zhihu.com)</a></p><p>前提：axis n是一个单位向量，并且n过原点(如果不过原点，参考前面的方法先平移回原点)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230520235749777.png" class title="image-20230520235749777"><p><strong>有关四元数</strong></p><p>定义：</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230521000033200.png" class title="image-20230521000033200"><h2 id="MVP-Transformation"><a href="#MVP-Transformation" class="headerlink" title="MVP Transformation"></a>MVP Transformation</h2><p>拍照过程</p><ol><li>摆放好待拍摄的物品，或者人物。（model transformation)</li><li>调整好拍摄(相机)角度。(view transformation)</li><li>调整焦距,拍摄。(projection transformation)</li></ol><p>也就是常说的MVP变换</p><p><strong>这里Viewing Transformation包括了View Transformation(视图变换)和Projection Transformation(投影变换)</strong></p><h3 id="View-Camera-Transformation-视图变换"><a href="#View-Camera-Transformation-视图变换" class="headerlink" title="View/Camera Transformation(视图变换)"></a>View/Camera Transformation(视图变换)</h3><p>视图变换就是把相机放好。把相机移回原点，相机的三个向量分别和世界坐标的三个轴对齐。先平移后旋转</p><ul><li>平移回原点</li><li>旋转对齐轴</li></ul><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523214954945.png" class title="image-20230523214954945"><p>平移矩阵很好得到</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215056433.png" class title="image-20230523215056433"><p>然后是旋转矩阵</p><p>但是要想将相机三向量t,g,x转换到世界坐标轴XYZ(单位向量)上，其实不好算，所以这里反过来算</p><p>所以首先明确目标矩阵(1 0 0 0；0 1 0 0； 0 0 1 0； 0 0 0 1)，由于反过来算，所以变成了起始矩阵</p><p><strong>细节:</strong> g to -Z,相机对准Z的负方向，t to Y, gxt to X，x由g、t叉乘得到</p><p>R(view)的逆矩阵很好得到，毕竟（0，0，1）旋转到一个位置很好做</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215450184.png" class title="image-20230523215450184"><p>至此实现了从世界坐标轴到相机坐标轴的旋转，只要额外再取个逆，就能得到R(view)</p><h3 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h3><h4 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h4><p>正交投影假设物体和相机无限远，这样物体通过视锥体投影到相机没有近大远小</p><p>以下这张图解释了这个过程(<strong>先平移后缩放</strong>)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523221856008.png" class title="image-20230523221856008"><p><strong>注意：这里是右手系，相机往-z方向看</strong>，OpenGL就是右手坐标系。</p><p>但是unity 和 dx都是左手坐标系</p><p>再这样的前提下|f|要比|n|要小</p><p>由此得到正交变换的变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523222223893.png" class title="image-20230523222223893"><p>如何理解r,l,b,n,f,t这些东西，可以理解成物体左右上下前后的“坐标”，</p><p>平移矩阵好理解，缩放矩阵本质上是用【2/左右距离】作为缩放倍数，最后结果为2，使得物体缩放到【-1，1】的cube中。</p><p>至此正交投影结束</p><h4 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h4><p>视锥体原平面投影到近平面就能产生透视效果</p><p><strong>这里做透视投影的过程是，先将视锥体squish(挤)成cuboid(长方体）再做正交投影</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224143182.png" class title="image-20230523224143182"><p>由远近平面的关系，我们可以根据相似三角形得到比例关系</p><p><code>y&#39; = (n/z)y</code></p><p>首先明确我们的目标是将(x,y,z)变换到(x’,y’,z’)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224929643.png" class title="image-20230523224929643"><p>进而在齐次坐标上是</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225031775.png" class title="image-20230523225031775"><p>从透视投影到正交投影的矩阵可以写成</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225322150.png" class title="image-20230523225322150"><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225545132.png" class title="image-20230523225545132"><p>这里我们要具体推导一下第三行的值</p><p>本质上就是用远近平面上的点带入，完成二元方程组，进而推导出第三行</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233910281.png" class title="image-20230523233910281"><p>最后合成透视矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233933492.png" class title="image-20230523233933492"><p>推导结束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Transformation-变换&quot;&gt;&lt;a href=&quot;#Transformation-变换&quot; class=&quot;headerlink&quot; title=&quot;Transformation(变换)&quot;&gt;&lt;/a&gt;Transformation(变换)&lt;/h1&gt;&lt;h2 id=&quot;变换的</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始的图形学 概述</title>
    <link href="https://aspect-ux.github.io/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%A6%82%E8%BF%B0/"/>
    <id>https://aspect-ux.github.io/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-17T15:21:24.887Z</published>
    <updated>2023-07-13T00:42:21.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于实在觉得有必要细致、全面、通透地学习一遍图形学相关基础理论知识，于是开了这个坑。</p><p>但是，就我个人而言，该系列不会局限单纯的理论。目前的想法是，除开基础理论推导</p><ul><li><p>会添加一些引擎中的原理和实现，games系列闫令其老师101，202的作业，以及流行图形API如OpenGL的理论实践。</p></li><li><p>同时PBR,RTR等图形学进阶书籍阅读笔记也可能会不定期更新。</p></li></ul><p>总的来说，理论性会更强，实验性的记录和学习也会占相当一部分，包罗图形学及其相关应用。个人的意义算是这个方向的<strong>笔记或“个人百科全书”</strong>。后续也会不断完善。</p><h2 id="Overview-of-Computer-Graphics"><a href="#Overview-of-Computer-Graphics" class="headerlink" title="Overview of Computer Graphics"></a>Overview of Computer Graphics</h2><p>这里借games101开个头</p><h3 id="Why-Study-CG"><a href="#Why-Study-CG" class="headerlink" title="Why Study CG"></a>Why Study CG</h3><ul><li><p>Fundamental Intellectual Challenges: </p><ul><li>Creates and interacts with realistic virtual world(与虚拟交互)</li><li>Require understanding of all aspects of physical world(了解物理世界)</li><li>New computing methods,displays,technologies(新技术，方法)</li></ul></li><li><p>Technical Challenges:</p><ul><li>Math of(perspective) projections,curves,surfaces(数学)</li><li>Physics of lighting and shading(物理)</li><li>Representing / operating shapes in 3D(图形/3d)</li><li>Animation / simulation(动画/模拟)</li><li>3D graphics software programming and hardware(3d编程/硬件)</li></ul></li><li><p>Forget about the previous reason: <strong>Graphics is awesome!</strong></p></li></ul><p><strong>总而言之，图形学真的很有趣！！！</strong></p><h3 id="What-will-be-in-the-corner"><a href="#What-will-be-in-the-corner" class="headerlink" title="What will be in the corner"></a>What will be in the corner</h3><ul><li><p>Mathematics theories</p></li><li><p>Rasterization</p></li><li><p>Curves and Meshes</p></li><li><p>Ray Tracing</p><p>and so on…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于实</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/"/>
    <id>https://aspect-ux.github.io/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/</id>
    <published>2022-12-01T15:42:33.960Z</published>
    <updated>2022-12-01T16:33:14.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Signal-Processing"><a href="#Signal-Processing" class="headerlink" title="Signal Processing"></a>Signal Processing</h1><p>在图形中，我们经常要处理具有连续变量的函数：一开始你只看到一张图像，但是随着你的探索，你将会看到更多。本质上，连续函数不能直接在电脑上表达，我们必须用优先的比特来表达他们。</p><p>最有用的方法之一是存储这个函数在不同点的值，然后在需要的时候进行重构。</p><p>你现在位置应该熟悉使用二维网格像素来表达图像，所以你已经见过一个采样的表现。</p><p>另一个关于sampled representation 的粒子是二维的数字化平板。</p><p>例如平板电脑，或者艺术家使用的数位屏。这种情况下，最原式的函数是数位笔的移动</p><p>（stylus数位笔触针手写笔)</p><p>…</p><h3 id="Digital-Audio-Sample-in-1d"><a href="#Digital-Audio-Sample-in-1d" class="headerlink" title="Digital Audio : Sample in 1d"></a>Digital Audio : Sample in 1d</h3><p>即使sampled representation 已经用于电子交流很久了，激光唱片（compact disc)在1982年的引入，紧随着音频数字记录器的使用增长，在过去的10年里，是第一个高度可视的消费者应用采样。</p><p>…</p><h3 id="Sampling-Artifacts-and-Aliasing"><a href="#Sampling-Artifacts-and-Aliasing" class="headerlink" title="Sampling Artifacts and Aliasing"></a>Sampling Artifacts and Aliasing</h3><p>数字音频记录可以为sampling 和reconstruction处理更加具体的模型。</p><p>Aliasing 展示了不管什么时候，采样重构失效导致人工结果是一个令人惊讶的频率</p><p>在音频中，走样以一种奇怪的声音和额外的声调–一个10Hz的bell ring,当采样到8Hz,就变成一个6Hzd的声调</p><p>在图像中，走样经常因为采样网格的interaction和图像中常规特点。以moire pattern的形式出现。</p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669910518267.png" class width="1669910518267"><h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><p>在我们讨论sampling和reconstruction算法之前，我们首先要检验它们基于的数学该奶奶</p><p>convolution卷积。</p><p>卷积是一个简单的数学概念，为算法作基础用来采样，过滤，重构。</p><p>同时它也是我们如何分析这些算法的基础。</p><p>卷积是一个function:它使用两个functions，然后将它们结合成一个新的function</p><p>这本书中，卷积运算符用一个*标记。f * g,f is convolved with g</p><p>卷积可以被用于连续方法或者离散的序列。</p><p>同时也可以被用于定义在1d,2d,3d或者更高维度.</p><p>为了定义方便，我们通常假设函数定义域区域无限。</p><p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/Website\Blog\source_posts\虎书\07\1669911797075.png" alt="1669911797075"></p><h3 id="Moving-Average"><a href="#Moving-Average" class="headerlink" title="Moving Average"></a>Moving Average</h3><p>为了得到一个基础的卷积图像。</p><p>思考：使用moving average来平滑一个函数。</p><p>为了在任意一个点得到平滑的值，我们需要计算函数超出范围拓展到每个方向，距离长度为r 的平均值。</p><p>距离r是平滑的radius，控制平滑度</p><p>我们用数学方法表示，如果平滑一个连续的函数g(x)，平均化（averaging)意味着在区间内对g进行求积分</p><p>（integrating)</p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669912247511.png" class width="1669912247511"><h3 id="Discrete-Convolution"><a href="#Discrete-Convolution" class="headerlink" title="Discrete Convolution"></a>Discrete Convolution</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Signal-Processing&quot;&gt;&lt;a href=&quot;#Signal-Processing&quot; class=&quot;headerlink&quot; title=&quot;Signal Processing&quot;&gt;&lt;/a&gt;Signal Processing&lt;/h1&gt;&lt;p&gt;在图形中，我们经常要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/12/01/naive/Games%E7%B3%BB%E5%88%97/101/Lecture03%20Transformation/"/>
    <id>https://aspect-ux.github.io/2022/12/01/naive/Games%E7%B3%BB%E5%88%97/101/Lecture03%20Transformation/</id>
    <published>2022-12-01T15:26:12.558Z</published>
    <updated>2022-12-01T15:42:22.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture03-Transformation"><a href="#Lecture03-Transformation" class="headerlink" title="Lecture03 Transformation"></a>Lecture03 Transformation</h1><h2 id="Last-Lecture"><a href="#Last-Lecture" class="headerlink" title="Last Lecture"></a>Last Lecture</h2><ul><li><p>Basic operations : addition, multiplication</p></li><li><p>Dot Product - Forward/backward  (dot product positive/negative)</p><p>如果点乘结果为正，则向前；否则向后</p></li><li><p>Cross Product - Left/right (cross product outward/inward)</p><p>如果叉乘结果指向外面，则为左；否则为右</p></li><li><p>Matrice</p></li></ul><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation?"></a>Why Transformation?</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture03-Transformation&quot;&gt;&lt;a href=&quot;#Lecture03-Transformation&quot; class=&quot;headerlink&quot; title=&quot;Lecture03 Transformation&quot;&gt;&lt;/a&gt;Lecture03 Tran</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Homework/homework1/"/>
    <id>https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Homework/homework1/</id>
    <published>2022-11-13T13:11:29.406Z</published>
    <updated>2022-11-13T13:11:29.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p>需要eigen和opencv</p><p>注意include( ),下载地址<a href="https://www.raoyunsoft.com/opencv/opencv-4.5.2/">Index of /opencv/opencv-4.5.2/ (raoyunsoft.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01&quot;&gt;&lt;a href=&quot;#01&quot; class=&quot;headerlink&quot; title=&quot;01&quot;&gt;&lt;/a&gt;01&lt;/h1&gt;&lt;p&gt;需要eigen和opencv&lt;/p&gt;
&lt;p&gt;注意include( ),下载地址&lt;a href=&quot;https://www.raoyunsoft</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Lecture01%20Overview%20of%20Computer%20Graphics/"/>
    <id>https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Lecture01%20Overview%20of%20Computer%20Graphics/</id>
    <published>2022-11-13T12:11:45.520Z</published>
    <updated>2022-11-13T12:12:40.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture01-Overview-of-Computer-Graphics"><a href="#Lecture01-Overview-of-Computer-Graphics" class="headerlink" title="Lecture01 Overview of Computer Graphics"></a>Lecture01 Overview of Computer Graphics</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture01-Overview-of-Computer-Graphics&quot;&gt;&lt;a href=&quot;#Lecture01-Overview-of-Computer-Graphics&quot; class=&quot;headerlink&quot; title=&quot;Lecture01 Over</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软链接c盘</title>
    <link href="https://aspect-ux.github.io/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/"/>
    <id>https://aspect-ux.github.io/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/</id>
    <published>2022-11-12T08:53:28.016Z</published>
    <updated>2022-11-15T13:05:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软链接c盘"><a href="#软链接c盘" class="headerlink" title="软链接c盘"></a>软链接c盘</h1><p>c盘文件链接到d盘，减小c盘占用<br>将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接<br>mklink /D “C:\Program Files\Adobe” “D:\MySoftware\Adobe”</p><h1 id="Unity-Cache"><a href="#Unity-Cache" class="headerlink" title="Unity Cache"></a>Unity Cache</h1><p>参考<a href="https://blog.csdn.net/baidu_39447417/article/details/117829765">(36条消息) 修改Unity的Cache缓存位置_GA博客的博客-CSDN博客_unity缓存</a></p><h1 id="SP字体太小"><a href="#SP字体太小" class="headerlink" title="SP字体太小"></a>SP字体太小</h1><p>QT_SCALE_FACTOR 1.3  用户变量</p><p>但是有副作用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软链接c盘&quot;&gt;&lt;a href=&quot;#软链接c盘&quot; class=&quot;headerlink&quot; title=&quot;软链接c盘&quot;&gt;&lt;/a&gt;软链接c盘&lt;/h1&gt;&lt;p&gt;c盘文件链接到d盘，减小c盘占用&lt;br&gt;将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接&lt;b</summary>
      
    
    
    
    <category term="随记" scheme="https://aspect-ux.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要12</title>
    <link href="https://aspect-ux.github.io/2022/11/10/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/"/>
    <id>https://aspect-ux.github.io/2022/11/10/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/</id>
    <published>2022-11-10T12:01:33.562Z</published>
    <updated>2022-11-10T12:02:24.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕后处理"><a href="#屏幕后处理" class="headerlink" title="屏幕后处理"></a>屏幕后处理</h1><p>顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。</p><p><code>onRenderImage</code>属于抓取屏幕的函数，应用在所有透明和不透明渲染完成后</p><h3 id="Unity中实现屏幕后处理"><a href="#Unity中实现屏幕后处理" class="headerlink" title="Unity中实现屏幕后处理"></a>Unity中实现屏幕后处理</h3><p><code>PostEffectsBase.cs </code>用于检验shader和material，并且通过脚本面板更改数据；如果不符合要求，则脚本失效.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先注意</span></span><br><span class="line"><span class="comment">//unity 有三种模式，player mode,edit mode(正常模式)，prefab mode(进入预制体更改)</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResource</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;This platform does not support image effects or render texture....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 如果shader，material同时有效；如果shader有效。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;shader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;material&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有shader就直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material) <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整屏幕亮度、饱和度、对比度"><a href="#调整屏幕亮度、饱和度、对比度" class="headerlink" title="调整屏幕亮度、饱和度、对比度"></a>调整屏幕亮度、饱和度、对比度</h4><p><em>代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                //Apply Brightness</span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                //Apply Saturation</span><br><span class="line">                fixed luminance= 0.2125 * renderTex.r + 0 . 7154 * renderTex . g + 0.0721 * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation); //饱和度是色彩的鲜艳程度或纯度</span><br><span class="line">                </span><br><span class="line">                //Apply Contrast</span><br><span class="line">                fixed3 avgColor = fixed3(0.5,0.5,0.5);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast);</span><br><span class="line">                </span><br><span class="line">                return fixed4(finalColor,renderTex.a);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>1.直接相乘得到亮度</p><p>2.计算亮度值luminance;</p><p>3.使用饱和度在上一步颜色和亮度值之间插值</p><p>4.对比度类似。</p><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>利用边缘检测算子对图像进行<strong>卷积</strong></p><p>如果我们想要对图像进行均值模糊，可以使用一个 3x3 的卷积核，核内每个元素的值均为 1/9。</p><p>见P249</p><p>在进行边缘检测时，我们需要对每个像素进行卷积计算，有两个方向的梯度。</p><p>整体梯度公式为<br>$$<br>G = sqrt(Gx^2 + Gy^2)<br>$$<br>出于性能考虑，一般也用绝对值取代开根号。</p><p><strong>使用Sobel算子实现描边</strong></p><p><strong>顶点着色器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.uv;</span><br><span class="line">                </span><br><span class="line">                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);</span><br><span class="line">o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);</span><br><span class="line">o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);</span><br><span class="line">o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);</span><br><span class="line">o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);</span><br><span class="line">o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);</span><br><span class="line">o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);</span><br><span class="line">o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);</span><br><span class="line">o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>使用Sobel算子采样，并且将采样代码转到顶点着色器，减少运算。并且由于顶点到片元的插值是线性的，所以并不会影响结果。</p><p><strong>edge计算</strong></p><p>计算9块像素的亮度，并且将水平和竖直方向的对应梯度和计算出来。最后1减去两者绝对值。</p><p><em>得到的edge越小，越有可能是边缘</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line">        const half Gx[9] = &#123;-1,  0,  1,</span><br><span class="line">        -2,  0,  2,</span><br><span class="line">        -1,  0,  1&#125;;</span><br><span class="line">        const half Gy[9] = &#123;-1, -2, -1,</span><br><span class="line">        0,  0,  0,</span><br><span class="line">        1,  2,  1&#125;;</span><br><span class="line">        half texColor;</span><br><span class="line">        half edgeX = 0;</span><br><span class="line">        half edgeY = 0;</span><br><span class="line">        for (int it = 0; it &lt; 9; it++) &#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"></span><br><span class="line">        return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>片元着色器</strong></p><p>利用Sobel得到梯度值edge后，分别计算贴图和纯色背景下的颜色值。</p><p>最后利用<code>_EdgeOnly</code>在两者之间取值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><p>卷积的另一个应用是高斯模糊</p><p>见P253</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line"><span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render the vertical pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render the horizontal pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graphics.Blit(buffer0, dest);</span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Graphics.Blit(src, dest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见P257</p><p>使用五个高斯核</p><p><strong>注：</strong>使用<code>CGINCLUDE</code>可以将顶点片元着色器包住，达到多个pass使用同一份着色器代码及其声明。</p><p>没看懂…….</p><h4 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a>Bloom效果</h4><p>根据某个阈值提取出画面中较亮的区域，然后通过高斯模糊，模拟光线扩散的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;屏幕后处理&quot;&gt;&lt;a href=&quot;#屏幕后处理&quot; class=&quot;headerlink&quot; title=&quot;屏幕后处理&quot;&gt;&lt;/a&gt;屏幕后处理&lt;/h1&gt;&lt;p&gt;顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onRenderIm</summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Games101 Material_01</title>
    <link href="https://aspect-ux.github.io/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/"/>
    <id>https://aspect-ux.github.io/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/</id>
    <published>2022-11-10T11:42:22.996Z</published>
    <updated>2022-11-10T12:05:07.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><h2 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse/Lambertian Material"></a>Diffuse/Lambertian Material</h2><p>对半球costheta积分结果是PI</p><p>关于这个证明</p><img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668081297856.png" class title="uTools_1668081297856"><p>半球上的立体角定义为覆盖半球表面区域的面积初一半径的平方</p><img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668080586079.png" class title="uTools_1668080586079">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Material&quot;&gt;&lt;a href=&quot;#Material&quot; class=&quot;headerlink&quot; title=&quot;Material&quot;&gt;&lt;/a&gt;Material&lt;/h1&gt;&lt;h2 id=&quot;Diffuse-Lambertian-Material&quot;&gt;&lt;a href=&quot;#Di</summary>
      
    
    
    
    <category term="Games101" scheme="https://aspect-ux.github.io/categories/Games101/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要11</title>
    <link href="https://aspect-ux.github.io/2022/11/09/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/"/>
    <id>https://aspect-ux.github.io/2022/11/09/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/</id>
    <published>2022-11-09T14:04:17.719Z</published>
    <updated>2023-05-16T14:24:26.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter11-让画面动起来"><a href="#Chapter11-让画面动起来" class="headerlink" title="Chapter11-让画面动起来"></a>Chapter11-让画面动起来</h2><h3 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h3><p>1.序列帧动画</p><p>….</p><p>2.滚动背景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//frac函数返回标量或每个矢量中各分量的小数部分。return v - floor(v);</span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex) + frac(float2(_ScrollX,0.0)*_Time.y);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord,_DetailTex) + frac(float2(_Scroll2X,0.0)*_Time.y);</span><br><span class="line">//可以发现当x乘上一个小于1的值时，系数越小，呈现的图像结果会越稀疏</span><br></pre></td></tr></table></figure><p>函数如下图</p><img src="/2022/11/09/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661861601610.png" class title="uTools_1661861601610"><p>frac(float)等价上图</p><p>frac(float2())则等价于以圆心为原点，以这个点为起点的线为半径，每过v的长度，为一个周期。最后构成多重圆环。而横坐标</p><p>的倍率则影响密度。倍率大于1，噪声越大，间隔小，密度大。</p><p><font color="red">如果渲染2d物体，可以将相机模式转换成正交模式</font></p><p>3.水波动画</p><p>由于本例中需要移动模型空间坐标，而批处理会使得相关模型合并，使得相关模型丢失原来模型空间；所以一般有顶点移动anime的shader要考虑关闭batch;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;</span><br><span class="line">    &quot;RenderType&quot;=&quot;Transparent&quot;,</span><br><span class="line">    &quot;IgnoreProjector&quot; = &quot;True&quot;,</span><br><span class="line">    &quot;RenderType&quot; = &quot;Transparent&quot;,</span><br><span class="line">    &quot;DisableBatching&quot; = &quot;True&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如何形成水波？顶点着色器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 offset;</span><br><span class="line">offset.yzw = float3(0.0,0.0,0.0);</span><br><span class="line">offset.x = sin(_Frequency * _Time.y +v.vertex.x * _InWaveLength + v.vertex.y *</span><br><span class="line">_InWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line">o.pos = mul(UNITY_MATRIX_MVP,v.vertex + offset);</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); //将纹理进行uv映射</span><br><span class="line">o.uv += float2(0.0,_Time.y * Speed);      //将uv的v根据时间变化进行增长</span><br></pre></td></tr></table></figure><p>等价于<br>$$<br>x = Magnitude * sin(_Frequency * t+w * vertex)<br>$$<br>由此使得水波水平变化。</p><p>同时还用了纹理动画，产生水平的纹理动画。</p><p>4.广告牌技术</p><p>效果：星星始终面朝摄像机，向上的位置并未改变，当y轴转动，也会跟着转动</p><p><em>代码</em></p><p>1.获取模型空间的中心和相机点</p><p>2.将法线设为从中心点指向相机的方向</p><p>3.将法线y方向乘以_VerticalBillboarding，并归一化</p><p>4.一般来说，法线并不等于up向量，up向量为（0，1，0）,但是随着视点的转变，法线也会变，如果法线等于up，</p><p>​    那么后续叉乘的结果会出错。此时up会变成向前的向量。</p><p>5.然后是right向量，由前两个向量叉乘得到，需要归一化，至此三个正基向量得到。</p><p>6.<code>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</code></p><p>​    最后实现顶点坐标在模型空间，三个分量不同程度的形变，</p><p>​    <strong>结果是：</strong><font color="red">错误</font>_VerticalBillboarding=1，星星就像是跟踪屏幕；</p><p>​    _VerticalBillboarding= 0星星固定，有透视效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//顶点动画都是在模型空间变换</span><br><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">//1.</span><br><span class="line">float3 center = float3(0, 0, 0);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">float3 normalDir = viewer - center;</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span><br><span class="line">// Which means the normal dir is fixed</span><br><span class="line">// Or if _VerticalBillboarding equals 0, the y of normal is 0</span><br><span class="line">// Which means the up dir is fixed</span><br><span class="line">normalDir.y =normalDir.y * _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line">//4.</span><br><span class="line">// Get the approximate up dir</span><br><span class="line">// If normal dir is already towards up, then the up dir is towards front</span><br><span class="line">float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">// Use the three vectors to rotate the quad</span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">             </span><br><span class="line">o.pos = UnityObjectToClipPos(float4(localPos, 1));</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/11/09/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661943292280.png" class title="uTools_1661943292280">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter11-让画面动起来&quot;&gt;&lt;a href=&quot;#Chapter11-让画面动起来&quot; class=&quot;headerlink&quot; title=&quot;Chapter11-让画面动起来&quot;&gt;&lt;/a&gt;Chapter11-让画面动起来&lt;/h2&gt;&lt;h3 id=&quot;纹理动画&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
    <category term="shader动画" scheme="https://aspect-ux.github.io/tags/shader%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Computer Graphics 06</title>
    <link href="https://aspect-ux.github.io/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/"/>
    <id>https://aspect-ux.github.io/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/</id>
    <published>2022-11-08T12:41:39.965Z</published>
    <updated>2022-11-10T11:34:55.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-Graphics-Pipeline"><a href="#The-Graphics-Pipeline" class="headerlink" title="The Graphics Pipeline"></a>The Graphics Pipeline</h1><p>前面几章已经建立了所需的数学基础(scaffolding)</p><p>现在主要讨论第二种主要的rendering 方式。</p><p>—在屏幕上一个接着一个绘制物体，也即<strong>object order rendering</strong></p><p>不同于ray tracing 的方式，通过像素找物体，现在会反过来通过物体找像素</p><p>**在一张被几何图元(geometric primitive)占满的图像上的所有像素的过程，称之为rasterization(光栅化)**，所以object order rendering也称之为光栅化渲染</p><p>而实现这一操作的操作序列，称之为图形渲染管线，<strong>graphics pipeline</strong></p><p>这种方法的成功，来源于它的效率。</p><p>对于大型场景，对数据存储模式的管理 是至关重要的操作。而且制作一个整个场景的通道来访问几何的每一个bit一次,比重复地搜索场景来检索所需的场景更加有有时。</p><p>object-order rendering不只有一种方法。</p><p>hardware 硬件pipeline使用OpenGL,Direct3D等API</p><p>software pipeline使用鱼电影制作，提供了像RenderMan这样地API</p><ul><li><p>硬件渲染管线需要运行地很快，使得足以支撑起实时游戏，可视化和用户交互</p></li><li><p>Production pipeline(生产管线)则追求高质量动画、视觉效果,但是这会花费很多时间。</p></li></ul><h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><h3 id="Line-Drawing"><a href="#Line-Drawing" class="headerlink" title="Line Drawing"></a>Line Drawing</h3><p><strong>使用隐式线条方程</strong></p><p>用隐式方程画线条最普遍的算法是<strong>midpoint algorithm</strong></p><p>这种算法能够画出和<strong>Bresenham algorithm</strong>一样的线条，但是稍微更加直接。</p><p>见P38</p><p>常见的斜截式(slope-intercept)    <code>y = mx + b</code></p><p>b称为y-intercept,</p><p>slope-intercept 有时有点尴尬(awkward)，因为它不能表示x = 0,不然m需要infinite</p><p>这时候使用隐式表达式(implicit equation)     <code>Ax + By + C = 0</code></p><p>还有两点式<code>(y0 - y1) x + (x1 - x0)y + C = 0</code></p><p>C的话代入任意一个点就可以得到</p><p><strong>最终</strong></p><p><code>(y0 - y1) x + (x1 - x0)y + x0 y1 - x1y0 = 0</code></p><p>我们假设x0&lt;=x1,如果不正确，就交换两个点，斜率</p><p>slope    <code>m  =(y1  - y 0)/(x1 - x0);</code></p><p><strong>以下假设m在（0，1）区间</strong></p><img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1667998615390.png" class title="uTools_1667998615390"><p>一个很有效的方法是，通过比较两个预选像素的中点和line，如果line在中点上面，就画（x+1,y+1)</p><p>不然就画（x+1,y)</p><p>那么如何比较（x+1,y+0.5）和线条呢</p><p><code>f(x + 1,y + 0.5) &lt; 0 then y = y + 1</code></p><p>详情见P182</p><h3 id="Triangle-Rasterization"><a href="#Triangle-Rasterization" class="headerlink" title="Triangle Rasterization"></a>Triangle Rasterization</h3><p>三角形内重心（barycentric coordinates)的颜色</p><p>是 <code>c = a * c0 + b * c1 + r * c2</code></p><p>另一个rasterizing triangle的细节（subtlety)是共享顶点和边。</p><p>这意味着相邻（adjacent)三角形之间没有间隙，我们可以用midpoint algorithm来画每个</p><p>三角形的边，然后填充内部像素</p><p>光栅化三角形，需要避免顺序问题，消除间隙，而方法则是，按照惯例（convention)，当且仅当像素的中心在三角形内，才进行光栅化。</p><p><strong>暴力算法（brute force algorithm)</strong></p><p>使用中心判断是否光栅化</p><img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668001076663.png" class title="uTools_1668001076663"><h3 id="Dealing-with-Pixels-on-Triangle-Edges"><a href="#Dealing-with-Pixels-on-Triangle-Edges" class="headerlink" title="Dealing with Pixels on Triangle Edges"></a>Dealing with Pixels on Triangle Edges</h3><p>我们还没有讨论如果像素中心在三角形的边缘该怎么办，</p><p>根据上面的思路，如果不光栅化，那么势必会小一圈，相邻三角形可能会有一个大的间隙；如果光栅化，相比较前者好一些，但仍有问题：<strong>如果三角形都是transparent的，这将会造成double-coloring</strong>,毕竟本意是半透明，但是却画了两次。</p><img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668001688563.png" class title="uTools_1668001688563"><p>所以我们真的确实需要裁定（award)具体哪一个像素，然后我们希望这个过程能够很简单。</p><p>其中一个方法是，标记任意视线之外的点确定为公共边的一侧，并且指定这个边是要绘制的。</p><h3 id="Perspective-Correct-Interpolation"><a href="#Perspective-Correct-Interpolation" class="headerlink" title="Perspective Correct Interpolation"></a>Perspective Correct Interpolation</h3><p>当interpolating quantities 插值大量的，例如纹理坐标或者3d坐标等需要在3d三角上线性改变</p><p>的数据时</p><p>在实现“纠正视觉透视”有一些subtleties(小方法，精妙的细节)</p><p>当透视校正很重要时我们会使用纹理坐标作为一种数量的指标（example)</p><p>3d空间线性值很重要是，上述考虑也适用于任何参数</p><p>事情不会那么简单的原因是，单纯的屏幕空间纹理坐标插值，会导致不正确的图像。如下图</p><img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668078483770.png" class title="uTools_1668078483770"><img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668079789675.png" class title="uTools_1668079789675">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-Graphics-Pipeline&quot;&gt;&lt;a href=&quot;#The-Graphics-Pipeline&quot; class=&quot;headerlink&quot; title=&quot;The Graphics Pipeline&quot;&gt;&lt;/a&gt;The Graphics Pipeline&lt;/</summary>
      
    
    
    
    <category term="Fundamental of Computer Graphics" scheme="https://aspect-ux.github.io/categories/Fundamental-of-Computer-Graphics/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要9</title>
    <link href="https://aspect-ux.github.io/2022/11/07/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/"/>
    <id>https://aspect-ux.github.io/2022/11/07/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/</id>
    <published>2022-11-07T12:47:02.955Z</published>
    <updated>2022-11-07T12:52:14.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h2><h3 id="立方体纹理（CubeMap"><a href="#立方体纹理（CubeMap" class="headerlink" title="立方体纹理（CubeMap)"></a>立方体纹理（CubeMap)</h3><p>立方体纹理映射技术是实现环境映射的一种方法，还应用于Skybox</p><p>1.新建skybox类型的材质，填充6张中级篇Chapter10，设置为Wrap Mode设置为Clamp使得衔接顺畅;</p><p>2.创建用于环境映射的<code>CubeMap</code></p><p>环境映射技术最常见的应用是<strong>反射</strong>和<strong>折射</strong></p><ul><li>反射</li></ul><p><code>lerp(y1,y2,weight) = y1 + (y2-y1)*weight;</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed3 reflection = texCUBE(_CubeMap,i.worldRefl).rgb * _Reflection.rgb;<span class="comment">//在立体纹理中采样</span></span><br><span class="line"></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line">float3 color = ambient + lerp(diffuse,reflection,_ReflectionAmount) *atten;<span class="comment">//有反射，无高光</span></span><br></pre></td></tr></table></figure><img src="/2022/11/07/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213048053.png" class title="uTools_1661213048053"><ul><li>折射(Refraction)</li></ul><p>​    计算折射</p><img src="/2022/11/07/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213306951.png" class title="uTools_1661213306951"><p>**斯涅尔定律(Snell’s law)**，m1 *sin(a) = m2 * sin(a2)，m1,m2 分别为折射率。真空折射率是1，玻璃的折射率是1.5</p><p>玻璃一般分为两次折射，但第二次折射较复杂，一般只模拟第一次折射。</p><img src="/2022/11/07/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661218211269.png" class title="uTools_1661218211269"><p><strong>菲涅耳反射</strong></p><p>（Fresnel Reflection)</p><p>比如看远处的水会反光，这就是菲涅耳反射；不仅透明物体，很多不透明物体或多或少都存在菲涅耳反射。</p><p>F(V ,D)=F0+(l-F0)(1-v·n)^5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed fresnel = _FresnelScale + (1-_FresnelScale) * pow(1-dot(worldViewDir,worldNormal),5);</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">return fixed4(color, 1.0);</span><br></pre></td></tr></table></figure><h3 id="渲染目标纹理"><a href="#渲染目标纹理" class="headerlink" title="渲染目标纹理"></a>渲染目标纹理</h3><p>现代GPU允许将三维场景渲染到中间缓冲，即渲染目标纹理（Render Target Texture)</p><p><strong>使用渲染纹理模拟镜子效果</strong></p><p>见P219</p><p><strong>玻璃效果</strong></p><p>to be studyed</p><h3 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h3><p>SetProperty，该插件用于在Unity面板上修改材质属性，并通过_UpdateMaterial()函数来使用新的属性生成程序<a href="https://so.csdn.net/so/search?q=%E7%BA%B9%E7%90%86&spm=1001.2101.3001.7020">纹理</a>。</p><p><em>示例</em> :<code>ProceduralTextureGeneration.cs</code></p><p>代码首先初始化 维纹理，并且提前计算了 些生成纹理时需要的变队。然后，使用了</p><p>个两层的嵌套循环遍历纹理中的每个像素，并在纹理七依次绘制 个圆形 。最后，调用</p><p>Texture2D.Apply 函数来强制把像素值写入纹理中，并返回该程序纹理。</p><p><strong>unity中有一种程序材质专门使用程序纹理。而程序纹理是通过算法实现的效果。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高级纹理&quot;&gt;&lt;a href=&quot;#高级纹理&quot; class=&quot;headerlink&quot; title=&quot;高级纹理&quot;&gt;&lt;/a&gt;高级纹理&lt;/h2&gt;&lt;h3 id=&quot;立方体纹理（CubeMap&quot;&gt;&lt;a href=&quot;#立方体纹理（CubeMap&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Computer Graphics 05</title>
    <link href="https://aspect-ux.github.io/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/"/>
    <id>https://aspect-ux.github.io/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/</id>
    <published>2022-11-07T11:33:18.103Z</published>
    <updated>2022-11-08T12:41:28.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Viewing"><a href="#Viewing" class="headerlink" title="Viewing"></a>Viewing</h1><h2 id="Viewing-Transformations"><a href="#Viewing-Transformations" class="headerlink" title="Viewing Transformations"></a>Viewing Transformations</h2><p>视角变换用于映射3d位置。</p><p>它是一头复杂的野兽，依赖于包括相机坐标、orientation(取向)，投影的类型，视角的区域，和图片的清晰度(resolution);</p><p>它是通过几个简单变换点乘获得</p><ul><li>相机变换(camera/eye  transformation)</li><li>投影变换(projection transformation)</li><li>视口(窗口)变换(viewport transformation)</li></ul><img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667821796670.png" class title="uTools_1667821796670"><p>模型空间-&gt;世界空间-&gt;相机空间-&gt;规范化视线空间-&gt;屏幕空间</p><h3 id="The-Viewport-Transformation"><a href="#The-Viewport-Transformation" class="headerlink" title="The Viewport Transformation"></a>The Viewport Transformation</h3><p>假设我们想要看到的几何体在规范的视图体积空间(canonical view volume)</p><p>然后我们想要在z轴方向用**正交(orthographic)**相机观察</p><p>canonical view volume(规范视图空间)是一个包含了所有3d坐标的正方体，这些坐标</p><p>在笛卡尔坐标系(cartesian coordinates)中处于（-1，1）之间</p><p>我们将x = -1投射到屏幕的左边，y = -1投射到屏幕的底部，像素坐标的定义是围绕着</p><p>以整数坐标为中心的方形。这样图像的边缘就有半个unit的overshoot</p><p>如果我们想要在图片上画nx * ny个像素,我们需要将square[-1.1]映射到[-0.5，nx - 0.5]</p><p>x [-0.5,ny - 0.5]</p><p><strong>这里是假设线段完全在规范视角空间里，后面会放下这个假设,讨论clipping(裁剪)</strong></p><img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667823244143.png" class title="uTools_1667823244143"><p><code>Xscreen = nx/2 * Xcanonical + (nx - 1) / 2</code></p><p>…</p><p>注意这个矩阵忽略了z分量，因为这不影响投影到图片，但是在正式称呼这个矩阵为视口矩阵</p><p>(transform to screen),我们需要增加一一行和一列来存储z分量，不改变z分量</p><img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667824528183.png" class title="uTools_1667824528183"><p>最终这个投影到屏幕</p><h3 id="The-Orthographic-Projection-Transformation"><a href="#The-Orthographic-Projection-Transformation" class="headerlink" title="The Orthographic Projection Transformation"></a>The Orthographic Projection Transformation</h3><p>当然，我们通常想要在除了canonical view volume空间的一些区域渲染几何体。我们的第一步是生成视图，这个视图保持view dir,orrientation不变，looking alone -z with +y up. </p><p>我们将在右边乘以另一个矩阵来增广这个矩阵。</p><img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667909557536.png" class title="uTools_1667909557536"><p>the six params are respectively left,right,bottom,top,near,far</p><p>正交视图空间是在-z轴上，所以f是更小的负数</p><p>在z轴上，这样近视图反而比远视图更大，这是非直觉性的(uninstuitive)</p><img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667910750246.png" class title="uTools_1667910750246"><p>omit …..</p><h3 id="相机变换"><a href="#相机变换" class="headerlink" title="相机变换"></a>相机变换</h3><h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Viewing&quot;&gt;&lt;a href=&quot;#Viewing&quot; class=&quot;headerlink&quot; title=&quot;Viewing&quot;&gt;&lt;/a&gt;Viewing&lt;/h1&gt;&lt;h2 id=&quot;Viewing-Transformations&quot;&gt;&lt;a href=&quot;#Viewing-Tr</summary>
      
    
    
    
    <category term="Fundamental of Computer Graphics" scheme="https://aspect-ux.github.io/categories/Fundamental-of-Computer-Graphics/"/>
    
    
  </entry>
  
  <entry>
    <title>Event System</title>
    <link href="https://aspect-ux.github.io/2022/11/06/naive/Unity/EventSystem/"/>
    <id>https://aspect-ux.github.io/2022/11/06/naive/Unity/EventSystem/</id>
    <published>2022-11-06T15:37:26.618Z</published>
    <updated>2022-11-06T15:59:29.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>两个文件</p><p><a href="EventSystem/01/EventManager.cs">EventManager</a></p><p><a href="EventSystem/01/IEventListener.cs">EventManager</a></p><p><strong>用法</strong></p><ul><li>使用<code>interface IEventListener</code>注册事件，卸载事件</li><li>注册具体方法使用<code>AddEventListener</code>,卸载使用<code>RemoveEventListener</code></li><li>如果需要传多个参数，需要适当更新文件具体代码</li></ul><p><strong>综述</strong></p><p>一件事情会有可能会有许多反馈，每当我们要检测一个事件，首先注册这个事件，不断+=添加方法（反馈）,这些都在start(awake)之类中进行，等到游戏结束再取消订阅。</p><ul><li>包含一个<code>static EventManager instance;</code>单一实例并用于外部访问成员数据和方法</li><li>包含一个<code>interface IEventInfo</code>用于外部多态地实现方法</li><li>包含一个字典<code>Dictionary&lt;string,IEventInfo&gt; actionDic</code> 用于存储事件，可以理解成”事件池”</li><li>包含类<code>EventInfo&lt;T&gt;</code>继承自上述接口，用于添加单参数方法</li><li>包含添加、移除、触发事件</li></ul><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>文件</p><p><a href="EventSystem/02/EventHandler.cs">EventHandler</a></p><p>原理与方法一是一样的，使用方法也大差不差。</p><p>方法一将事件加入字典，不用每次添加都往一个文件里跑，并且结构也清晰一些。</p><p>方法二代码量相对少？好像也没少…。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Event-System&quot;&gt;&lt;a href=&quot;#Event-System&quot; class=&quot;headerlink&quot; title=&quot;Event System&quot;&gt;&lt;/a&gt;Event System&lt;/h2&gt;&lt;h3 id=&quot;方法1：&quot;&gt;&lt;a href=&quot;#方法1：&quot; cla</summary>
      
    
    
    
    <category term="Game system with uniy" scheme="https://aspect-ux.github.io/categories/Game-system-with-uniy/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要9</title>
    <link href="https://aspect-ux.github.io/2022/11/03/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter9/"/>
    <id>https://aspect-ux.github.io/2022/11/03/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter9/</id>
    <published>2022-11-03T13:45:49.701Z</published>
    <updated>2022-11-03T13:46:32.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Complex-Light-Chapter9"><a href="#Complex-Light-Chapter9" class="headerlink" title="Complex Light - Chapter9"></a>Complex Light - Chapter9</h2><h3 id="渲染路径（Rendering-Path"><a href="#渲染路径（Rendering-Path" class="headerlink" title="渲染路径（Rendering Path)"></a>渲染路径（Rendering Path)</h3><p><strong>分为前向渲染路径，延迟渲染路径(更新），顶点渲染路径（弃用）</strong></p><p>1.前向渲染路径，如果深度测试不过关，该片元不可见，反之可见，就进行光照计算</p><p>2.如果物体受到多个光源照射，就要写多个Pass,然后在帧缓冲中将这些光照结果混合。</p><p>3.前向渲染中，光照类型（平行光parallel light或其他）+光照渲染模式（important)决定了处理光照（照亮物体）的方式。</p><p>而处理方式分为逐像素，逐顶点、sh计算。</p><p>参见P182</p><h3 id="Unity光源类型"><a href="#Unity光源类型" class="headerlink" title="Unity光源类型"></a>Unity光源类型</h3><p>1.平行光、点光源、<em>面光源</em>和<em>聚光灯</em>，面光源只在烘焙时才会产生作用</p><p>2.当RenderMode是Auto,Unity自动判断哪些光源逐像素，哪些顶点、sh计算。</p><p>3.最亮的平行光是按照逐像素计算，而Auto状态下最多除平行光源外4个逐像素计算，这些在addtional pass中计算</p><p><strong>最常用的光源属性有：位置、方向、颜色、强度、衰减</strong></p><ul><li>光照衰弱</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用纹理来计算衰弱值</span></span><br><span class="line"><span class="keyword">fixed</span> atten = tex2D(_ ghtTextureO, dot(lightCoord, lightCoord) .rr) .UNITY_ATTEN_CHANNEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数学公式进行线性衰弱值计算</span></span><br><span class="line"><span class="built_in">float</span> distance = length (_WorldSpaceLightPosO . xyz - i. worldPosi <span class="keyword">on</span>.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> <span class="comment">// distance; // linear attenuation</span></span><br></pre></td></tr></table></figure><h3 id="Unity阴影"><a href="#Unity阴影" class="headerlink" title="Unity阴影"></a>Unity阴影</h3><p>1.如果最重要的平行光开启了阴影，那么Unity会为这个光源生成<em>阴影纹理图</em>，一种由光源出发的深度图。</p><p>2.另取一个LightMode为ShadowCaster的Pass,Unity会将摄像头放到光源的地方</p><p>3.一个物体想要接收阴影，那么在shader中要对纹理采样；相同地，一个物体想要投射阴影，就要参与纹理计算</p><p>见P200</p><ul><li>如何让正方体接收阴影</li></ul><p>SHADOWCOORD,TRANSFER_SHADOW,SHADOW_ATTENUATION分别在v2f,vert,frag中调用</p><p>实现接收阴影</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHADOW_COORDS(2)</span><br><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure><p><strong>光照衰减和阴影的效果是一样的，于是就有了统一光照衰弱和阴影</strong></p><p>unity提供一个方法同时管理这两者</p><p><code>UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</code></p><ul><li><p>透明物体的阴影</p><p>在AlphaTest的基础上使用上述方法</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Complex-Light-Chapter9&quot;&gt;&lt;a href=&quot;#Complex-Light-Chapter9&quot; class=&quot;headerlink&quot; title=&quot;Complex Light - Chapter9&quot;&gt;&lt;/a&gt;Complex Light - Ch</summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要8</title>
    <link href="https://aspect-ux.github.io/2022/11/02/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/"/>
    <id>https://aspect-ux.github.io/2022/11/02/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/</id>
    <published>2022-11-02T13:00:26.665Z</published>
    <updated>2022-11-02T13:02:04.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter8-透明效果"><a href="#Chapter8-透明效果" class="headerlink" title="Chapter8 透明效果"></a>Chapter8 透明效果</h2><h3 id="实现透明的方法"><a href="#实现透明的方法" class="headerlink" title="实现透明的方法"></a>实现透明的方法</h3><p>unity中通常使用两种方式实现透明效果</p><p>1.透明度测试(alpha test),（无法实现真正的半透明）</p><p>2.透明度混合(alpha blending)</p><p><strong>使用深度测试，可以不考虑渲染顺序</strong>，但是使用透明度混合时，需要关闭*<code>ZWrite</code>*，关闭了深度写入</p><p>虽然<em>透明度测试</em>不需要关闭，但是它的机制是如果透明度不满足某个阈值（通常小于），直接舍弃该片元。</p><ul><li>为什么关闭<code>ZWrite</code>?</li></ul><p><em>由于深度测试丢弃远处被遮挡部分，但是透明物体的机制是”可以透过并看见远处的物体”。</em></p><p>关闭了ZWrite，渲染顺序则成了问题。</p><p><strong>流程</strong></p><p>1.渲染时，会进行深度测试，如果先渲染后面的不透明b，将b写入颜色缓冲和深度缓冲；然后渲染前面的透明a,a写入颜色缓冲，会发生透明混合，显示正确。</p><p>2.如果先渲染a,进行深度测试，写入颜色缓冲，但是关闭了ZWrite，无法写入深度值，然后渲染b，写入深度值，写入颜色缓冲，b的颜色<strong>覆盖</strong>a,只能看见b。</p><p>3.半透明物体之间亦然。</p><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>Unity Shader解决方案为SubShader 中的Tags</p><p>以下为透明度测试alpha test示例</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       Tags&#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;TransparentCutout&quot;</span>&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">//alpha test</span></span><br><span class="line">               clip(texColor.a - _Cutoff);</span><br><span class="line">               <span class="comment">// Equal to </span></span><br><span class="line">               <span class="comment">// if (( exColor - _Cutoff) &lt; 0 . 0) &#123; </span></span><br><span class="line">               <span class="comment">// discard; &#125;</span></span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">         &#125;  </span><br></pre></td></tr></table></figure><p>每块的透明度都不同，根据面板调整_Cutoff可以看出哪个更低，低的那个会直接被剔除</p><p>结果图</p><img src="/2022/11/02/naive/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/uTools_1660983793621.png" class title="uTools_1660983793621"><h3 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       //alpha blend</span><br><span class="line">       Tags&#123;&quot;Queue&quot;=/*&quot;AlphaTest&quot;*/&quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">           ZWrite Off</span><br><span class="line">           Blend SrcAlpha OneMinusSrcAlpha  //P170</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br><span class="line">           //去掉clip</span><br></pre></td></tr></table></figure><h3 id="解决排序问题"><a href="#解决排序问题" class="headerlink" title="解决排序问题"></a>解决排序问题</h3><p><strong>一般先开启深度测试、写入，先渲染不透明物体，然后关闭写入，对不透明物体排序，先渲染后面的物体</strong></p><ul><li><strong>但是仍然存在很大问题。</strong></li></ul><p>比如一个物体，各个部分互相遮挡，又或者多个物体，相互遮挡，而深度排序是像素级别的。</p><p><strong>问题在于</strong></p><p>现在开启ZWrite</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Pass&#123;</span><br><span class="line"> ZWrite On </span><br><span class="line"> ColorMask 0//ColorMask RGB 、 A 、 0 、其他任何rgba的组合</span><br><span class="line"> //0表示不写入任何颜色通道，即只写入深度缓存，不输出颜色</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新添加一个Pass通道。该Pass专门用来写入深度缓冲，并且先执行。</p><p>Pass通道中加上<code>//Cull Front/Back/Off 需要双面渲染时关闭剔除</code></p><p>注意如果关闭了深度写入，此时再双面渲染就会出现半透明错误渲染</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter8-透明效果&quot;&gt;&lt;a href=&quot;#Chapter8-透明效果&quot; class=&quot;headerlink&quot; title=&quot;Chapter8 透明效果&quot;&gt;&lt;/a&gt;Chapter8 透明效果&lt;/h2&gt;&lt;h3 id=&quot;实现透明的方法&quot;&gt;&lt;a href=&quot;#实现</summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
  </entry>
  
</feed>
