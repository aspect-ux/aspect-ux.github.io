<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术美术学习记录</title>
  
  
  <link href="https://aspect-ux.github.io/atom.xml" rel="self"/>
  
  <link href="https://aspect-ux.github.io/"/>
  <updated>2023-08-22T12:21:18.130Z</updated>
  <id>https://aspect-ux.github.io/</id>
  
  <author>
    <name>Aspect</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
    <id>https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</id>
    <published>2023-09-06T14:22:12.213Z</published>
    <updated>2023-08-22T12:21:18.130Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Re0:数据结构与算法之 树与二叉树</title>
    <link href="https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-09-06T14:22:12.211Z</published>
    <updated>2023-09-06T14:33:48.661Z</updated>
    
    <content type="html"><![CDATA[<p>TODO:2023/08/18 19:00: 1.递归非递归遍历 2.线索树<br>TODO:2023/08/21 20:00: 1.取消stl的使用 2.树，森林，二叉树 3. 哈夫曼编码 4. 并查集的应用</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用语言：c/c++</li><li>仅个人学习记录，如有细节错误望理解（欢迎指正）</li><li>完整可运行代码见文末</li><li>持续更新中</li></ul><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><ul><li><p>定义：n（n&gt;=0）个结点的有限集合。n = 0为空树。</p><p>什么是结点？可以理解成一个包含数据区域和若干个指向其他结点的指针的结构体。</p><p>对于非空树，有且仅有一个根结点，其他结点皆有前驱结点。</p></li><li><p>表示方法：</p><ul><li><p>倒置树结构（如下图)</p><img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230815222453369.png" class title="image-20230815222453369"></li><li><p>文氏图</p></li><li><p>广义表</p></li><li><p>凹入表示法</p></li></ul></li><li><p>基本术语</p><ul><li>度：分为结点的度和树的度两种。前者是该节点的子树数量，也即后驱结点个数；后者则是所有结点度的最大值。</li><li>叶结点：也称为终端结点</li><li>层级：从根结点往下，1-n</li><li>树的高度：最大层级数</li><li>结点的名称：子结点，根结点，父结点（双亲结点），兄弟结点，堂兄弟结点等等。</li><li>m（m&gt;=0）棵互不相交的树。</li></ul></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树中一个结点的后驱结点最大只能为2。</p><p>除了叶子结点外，如果所有结点都有2个后驱结点，就叫做<strong>满二叉树</strong>。<br>另外还有一种二叉树叫做完全二叉树，除了最后一层相较于满二叉树可能有缺失外，其他一致。满二叉树一定是完全二叉树。<br><strong>注意</strong>，完全二叉树按照从左到右，从上到下的顺序，在遍历完所有结点之前不会遇到空结点。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li><p><strong>性质1：第 i 层的最多有 $2^{i-1}$结点</strong><br>证明：由于下一层 = 上一层 * 2<br>第一层有1个结点，第二层2个，第三层4个…<br>所以第i层$2^{i - 1}$个</p></li><li><p><strong>性质2：深度为k的二叉树，最多有$2^{k}$ - 1个结点</strong><br>证明：利用上一个性质的结论，第i层最多有$2^{k - 1}$个结点<br>深度为k，那么结点数最多共计<br>S = $2^{0}$ + $2^{1}$ + $2^{2}$ + … + $2^{k - 1}$<br>2S = $2^{1}$ + $2^{2}$ + $2^{1}$ + … + $2^{k - 1}$<br>S = 2S - S = $2^{k}$ - $2^{0}$ = $2^{k}$ - 1</p></li><li><p><strong>性质3：对于任意二叉树T，叶子结点数为$n_0$,度数为2的结点数位$n_2$,那么$n_0$ = $n_2$ + 1。</strong>*<br>证明： 先来分析一下，二叉树只有度为0-叶子结点，度为1，2的其他结点。<br>设度为1的结点有$n_1$个，总结点数为n。<br>n = $n_0$ + $n_1$ + $n_2$ ①</p><p>然后，除了叶子，所有结点都有至少一个结点，我们可以根据子结点来计算n<br>n = $n_0$ * 0 + $n_1$ * 1 + $n_2$ * 2 + 1（不要忘记根结点）②<br>② - ① = $n_2$ + 1 - $n_0$ = 0<br>即证 $n_0$ = $n_2$ + 1，度为0的结点比度为2的结点多一个。</p></li><li><p><strong>性质4：具有n个结点的完全二叉树深度为$[log_2n ] (向下) + 1$</strong><br>性质1，2是根据深度推导结点个数，3是0度和2度结点数关系。<br>性质4则是根据结点数推导二叉树深度。<br>证明：首先，完全二叉树保证了除了最后一层，其他层都与满二叉树完全相同。总结点数小于等于满二叉树的结点数。<br>根据性质2深度为k的二叉树最多有$2^{k}$ - 1个结点<br>我们设深度为k，那么可以得到以下不等式<br>$$<br>2^{k - 1} - 1 &lt; n &lt;= 2^{k} - 1<br>$$<br>简化后<br>$$<br>2^{k - 1} &lt;= n &lt; 2^{k}<br>$$<br>即得$k&lt;=log_2n + 1$</p></li><li><p><strong>性质5：在完全二叉树中，按照从左到右，从上到下，从1开始对结点进行编号，有以下性质：</strong></p><ol><li>若i = 1,为根结点。i &gt; 1则双亲结点序号为i/2</li><li>i &gt; n/2(叶子),则没有左孩子结点；i &lt; = n/2,则左孩子结点序号为2 * i。<br>证明：深度为k的满二叉树，最后一层最大有$2^{k-1}$个结点。除去最后一层一共有$2^{k - 1} - 1$,前k-1层总数少于最后一层，也就是小于n/2个结点。<br> 另一个方面来说，i&lt;=n/2时，i层某个结点到它的左子结点，刚好经过了i个结点。</li><li>i * 2 + 1 &gt; n,则无右孩子；否则有孩子结点序号为2 * i + 1。</li></ol></li></ul><h3 id="二叉树的遍历-Traverse"><a href="#二叉树的遍历-Traverse" class="headerlink" title="二叉树的遍历(Traverse)"></a>二叉树的遍历(Traverse)</h3><p>二叉树的存储结构分为顺序和链式两种，顺序结构采用结构体数组将数据存储在连续存储单元。</p><p>以下采用链式结构。<br>二叉树数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> TreeNode *root;</span><br></pre></td></tr></table></figure><p><strong>以下使用递归遍历(非递归在后面)</strong></p><h4 id="前序-先序-遍历"><a href="#前序-先序-遍历" class="headerlink" title="前序(先序)遍历"></a>前序(先序)遍历</h4><p>先左子树后右子树，无限递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先左后根最后右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTravere</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">InOrderTravere</span>(root-&gt;left);</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">  <span class="built_in">InOrderTravere</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先左后右最后根</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;right);</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  qu.<span class="built_in">push</span>(root);</span><br><span class="line">  level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> n = qu.<span class="built_in">size</span>();</span><br><span class="line">    LevelArr.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      TreeNode *tmp = qu.<span class="built_in">front</span>();</span><br><span class="line">      qu.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>层序遍历操作</span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(tmp);</span><br><span class="line">      LevelArr[level].<span class="built_in">push_back</span>(tmp-&gt;val); <span class="comment">//二维数组记录 </span></span><br><span class="line">      <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">        qu.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">        qu.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    level ++; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="非递归算法实现遍历"><a href="#非递归算法实现遍历" class="headerlink" title="非递归算法实现遍历"></a>非递归算法实现遍历</h4><p>为什么使用非递归算法？、<br>递归需要系统提供隐式栈实现，效率低且无法适应无递归语言设施。</p><h5 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>()) <span class="comment">// node指向当前新指针，stack存储待开发的旧指针 </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 先序遍历：先输出当前结点(左),保证push进去的结点不为空</span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(node);</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      node = st.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 中序遍历输出 最左的非空结点(输出左结点)</span></span><br><span class="line">      node = st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 输出位置 </span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(node); </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 转移指针到右结点,因为右子树也需要递归判断 </span></span><br><span class="line">      node = node-&gt;right; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root,*recent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 后序遍历需要先输出右结点才能输出相对根结点</span></span><br><span class="line">      node = st.<span class="built_in">top</span>();</span><br><span class="line">      <span class="comment">// 直到右子结点是空结点才输出 </span></span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right &amp;&amp; node-&gt;right != recent)</span><br><span class="line">      &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        node = node-&gt;right-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 输出位置 </span></span><br><span class="line">        <span class="built_in">PrintTBTreeNode</span>(node);</span><br><span class="line">        recent = st.<span class="built_in">top</span>(); <span class="comment">// 记录最近一次访问</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        node = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>前言</strong>：我们在使用二叉树时，无法直接获得某个结点的前驱或后继的信息，只能从根结点开始遍历；另一方面，一个二叉树中，n个结点有2n个指针域，但是真正存储了信息的只有n-1个。</p><p>现在需要利用多余的指针域指向前驱和后继，这种指针称为线索。<br>而这种二叉结构又叫做线索链表。<br><strong>遍历并插入线索的操作叫做线索化</strong></p><p>数据结构如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索树结点 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> lTag;</span><br><span class="line">    <span class="type">int</span> rTag;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">lTag</span>(<span class="number">0</span>), <span class="built_in">rTag</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">lTag</span>(<span class="number">0</span>), <span class="built_in">rTag</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>(<span class="type">int</span> x,<span class="type">int</span> lTag,<span class="type">int</span> rTag, TreeNode *left, TreeNode *right)</span><br><span class="line">: <span class="built_in">val</span>(x),<span class="built_in">lTag</span>(lTag), <span class="built_in">rTag</span>(rTag), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，多了lTag,rTag两个int类型。规则如下</p><ol><li>lTag = 0,left指针域指向左孩子</li><li>lTag = 1,left指针域指向前驱</li><li>rTag = 0,right指针域指向右孩子</li><li>rTag = 1,right指针域指向后驱</li></ol><h4 id="线索化"><a href="#线索化" class="headerlink" title="线索化"></a>线索化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序线索化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThread</span><span class="params">(ThreadTreeNode* threadRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!threadRoot) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">InitThread</span>(threadRoot-&gt;left);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 左子树为空，那么存储前驱 </span></span><br><span class="line">  <span class="keyword">if</span> (!threadRoot-&gt;left)</span><br><span class="line">  &#123;</span><br><span class="line">    threadRoot-&gt;left = pre; </span><br><span class="line">    threadRoot-&gt;lTag = <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 右子树为空且前驱结点不为空，存储后驱 </span></span><br><span class="line">  <span class="keyword">if</span> (!threadRoot-&gt;right &amp;&amp; pre)</span><br><span class="line">  &#123;</span><br><span class="line">    pre-&gt;right = threadRoot;</span><br><span class="line">    pre-&gt;rTag = <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录前驱结点 </span></span><br><span class="line">  pre = threadRoot;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">InitThread</span>(threadRoot-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树（查找树）"><a href="#二叉搜索树（查找树）" class="headerlink" title="二叉搜索树（查找树）"></a>二叉搜索树（查找树）</h3><p>搜索树中，左子结点值小于父结点，右子结点大于父结点<br>中序遍历得到从小到大排序。</p><h3 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h3><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树又叫做最优二叉树</p><img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/uTools_1692620939563.png" class><ol><li>路径：根到叶子结点</li><li>路径长度：从根结点到叶子节点，每经过一个结点+1.（从一个结点到另一个结点经过的分支树）,设长度为l。</li><li>权：每个结点分配一个值，称为权,设为w。</li><li><strong>结点的带权路径长度：</strong> w * l</li><li><strong>树的带权路径长度：</strong> 结点带权路径长度之和 WPL = $w_1l_1$ + $w_2l_2$….</li></ol><h5 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h5><ol><li>n个权${w_1,w_2,…,w_n}$,分配到n个结点，可以看成n棵二叉树的森林F（权重不重复）</li><li>在森林F中选择权重最小的两棵树(二叉树),作为根结点的左右子树，根结点的权为两者之和。从F中删除已选中的树。</li><li>重复1，2操作。</li></ol><h5 id="哈夫曼树的特征"><a href="#哈夫曼树的特征" class="headerlink" title="哈夫曼树的特征"></a>哈夫曼树的特征</h5><p>根据上述的构造方法，不难发现</p><ul><li>有n个叶子结点，n - 1个非叶子结点。<h5 id="构造代码"><a href="#构造代码" class="headerlink" title="构造代码"></a>构造代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10 <span class="comment">//叶子结点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2*N - 1 <span class="comment">// 总结点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> w; <span class="comment">// 权重</span></span><br><span class="line">  <span class="type">int</span> p; <span class="comment">// 双亲的下标,为0时表示还没有父结点,可构造。 </span></span><br><span class="line">  <span class="type">int</span> left; <span class="comment">// 左孩的下标</span></span><br><span class="line">  <span class="type">int</span> right; <span class="comment">// 右孩的下标 </span></span><br><span class="line">&#125;HuffmanTree[M+<span class="number">1</span>]; </span><br><span class="line">HuffmanTree HT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree HT,<span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> s1_value,s2_value = s1_value = INT_MAX;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1_value &gt; HT[i].w &amp;&amp; HT[i].p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s1_value = HT[i].w;</span><br><span class="line">      s1 = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 查找第二小的权重 且 待构造 </span></span><br><span class="line">    <span class="keyword">if</span> (HT[i].w != s1_value &amp;&amp; HT[i].w &lt; s2_value &amp;&amp; HT[i].p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s2_value = HT[i].w;</span><br><span class="line">      s2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(<span class="type">int</span> w[],<span class="type">int</span> n,<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// HT[0]不使用 </span></span><br><span class="line">  <span class="comment">// 前n个结点存储叶子 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    HT[i] = &#123;w[i],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后n-1存储非叶子</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i ++) HT[i] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">    <span class="comment">// 选择最小的两个, </span></span><br><span class="line">    Select(HT,i<span class="number">-1</span>,s1,s2);  <span class="comment">// 每次选中的两个叶子都无法再使用了 ，但是父结点还可以加入选择 </span></span><br><span class="line">    HT[i].w = HT[s1].w + HT[s2].w;</span><br><span class="line">    HT[s1].p = i; HT[s2].p = i; </span><br><span class="line">    HT[i].left = s1; HT[i].right = s2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4></li><li><em>利用哈夫曼编码，我们可以得到平均长度最短的编码</em>*<br>在理解哈夫曼编码之前，我们现需要知道<strong>前缀码</strong><br>前缀码：一组编码中，互不为前缀。</li></ul><p><strong>哈夫曼编码:</strong> 对于哈夫曼树，左子树编为0，右子树编为1，每个分支得到的二进制串就是哈夫曼编码</p><p><strong>哈夫曼树是最优前缀码。用n个叶子结点来编码n个字符,可以使由这n个字符构成的文本的二进制串的平均长度最短。</strong><br>注意，权重是字符使用频率。</p><p><strong>哈夫曼编码算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树与森林与二叉树"><a href="#树与森林与二叉树" class="headerlink" title="树与森林与二叉树"></a>树与森林与二叉树</h2><p>下面是就树，森林具体展开。</p><h3 id="树的存储结构（区别对比二叉树的存储）"><a href="#树的存储结构（区别对比二叉树的存储）" class="headerlink" title="树的存储结构（区别对比二叉树的存储）"></a>树的存储结构（区别对比二叉树的存储）</h3><ol><li>双亲表示法：层序顺序对结点从1-n编号，结点分为数据域和双亲域（int类型）；一棵树则是结点数组。（结点数组）</li><li>孩子表示法：每个结点都有一条孩子单链表（叶子节点的孩子链表为空表）；使用数组存储n条单链表  （链表数组）</li><li>孩子兄弟表示法：每个结点两个指针域，指向第一个孩子和自己的右兄弟。</li></ol><h3 id="树与森林与二叉树的相互转换"><a href="#树与森林与二叉树的相互转换" class="headerlink" title="树与森林与二叉树的相互转换"></a>树与森林与二叉树的相互转换</h3><p>//TODO:待补充</p><h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历见二叉树<br>森林的遍历也分为先序中序和后序。（<strong>树去掉根结点就分成多棵树了，也就是森林</strong>）<br>拿先序来说，1.先第一棵树的根结点 2. 先序第一棵树的子树<br>3. 先序其它树</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TODO:2023/08/18 19:00: 1.递归非递归遍历 2.线索树&lt;br&gt;TODO:2023/08/21 20:00: 1.取消stl的使用 2.树，森林，二叉树 3. 哈夫曼编码 4. 并查集的应用&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://aspect-ux.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之查找与排序算法</title>
    <link href="https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/"/>
    <id>https://aspect-ux.github.io/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</id>
    <published>2023-09-06T14:22:12.209Z</published>
    <updated>2023-09-06T14:39:06.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找与排序"><a href="#查找与排序" class="headerlink" title="查找与排序"></a>查找与排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>本文主要包括查找算法和经典排序算法两个部分</li><li>使用语言：c/c++</li><li>仅用于个人学习记录，如有细节错误望理解（欢迎指正）</li><li>持续更新中,完整可运行代码见文末</li><li>参考<a href="https://www.runoob.com/w3cnote/merge-sort.html">https://www.runoob.com/w3cnote/merge-sort.html</a> (归并排序开始)</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>首先要理解什么是查找。</strong><br>查找是在相同数据类型的集合中，使用唯一标识（关键字K）来查找数据元素（V）。</p><p><strong>平均查找长度</strong> ASL = $P_1C_1 + P_1C_2 + ……$<br>其中$P_i$是概率，$C_i$是查找第i个元素比较过的次数。<br>用于分析算法性能。</p><p><strong>查找有哪些方法：</strong></p><ul><li>比较式查找法 (1).线性表的查找 (2).树的查找</li><li>计算式查找法 (1).hash查找</li></ul><p>理解以上三点后开始进一步学习具体的查找方法。</p><h3 id="比较式查找-基于线性表的查找"><a href="#比较式查找-基于线性表的查找" class="headerlink" title="比较式查找-基于线性表的查找"></a>比较式查找-基于线性表的查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>存储方式可以是顺序结构，也可以是链式结构<br>按顺序与关键字比对查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;KeyValueType;</span><br></pre></td></tr></table></figure><p>具体查找代码省略。只需在顺序表中逐个查找对比。</p><p><strong>平均查找长度：</strong><br>设列表中每个数概率相同 P = 1/n。<br>ASL = $1/n * (1 + 2 + 3 + … + n)$ = $(1+n)*n/2 * (1/n)$ = $(1+2)/n$</p><h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p><strong>使用折半查找的先前条件：必须是有序排列的顺序表</strong><br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方便起见不用结构体，直接在int数组里查找，key就是要查找的值x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = n,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] = x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均查找长度：</strong><br>设每个数的概率一致为P = $1/n$。</p><ul><li><p>简单计算方法，可以将长度为n的数组看成n个结点的满二叉树（不妨设刚好满足），这样一来，我们发现，每一次选择一半，就相当于从二叉树底层开始向上攀爬。假设最多选择比较了h次，刚好就是二叉树的高度。</p></li><li><p><em>根据满二叉树的性质 $h = log_2(n+1)$</em>*<br>换而言之只需要查找h次就一定能找到答案。</p></li><li><p>公式计算：<br>ASL = $1/n * Σ_{i=1-&gt;n}i*2^{i-1} = (n+1)/n * log_2(n+1) - 1$<br>当n足够大时，趋近于$log_2(n+1)$</p></li></ul><p>折半查找效率很高，但是要求必须为有序表,导致插入删除很麻烦。</p><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>通俗来讲，将数组分为多个块，块内数据无序，但是块与块之间有序（如 块0所有元素小于块1的任意元素）。<br>这是一种结合了折半查找和顺序查找的方法。性能介于两者之间。</p><p><strong>模拟一下过程：</strong></p><ul><li>建立索引表，用于指出块的起始位置和最大值。</li><li>使用折半查找，找到x所在的块，比较方法是比对每个块的最大值maxv。假设块是递增的，那么找到第一个大于等于x的maxv就行。</li><li>使用顺序查找，在块内逐个比对。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的key有两个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxKey;     <span class="comment">// 索引区间的最大键值</span></span><br><span class="line">    <span class="type">int</span> address;    <span class="comment">// 索引区间的起始地址（下标）</span></span><br><span class="line">&#125;Index;</span><br></pre></td></tr></table></figure><p>具体查找代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BlockSearch</span><span class="params">(Index *index, <span class="type">int</span> indexLen, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先折半查找索引表，找到关键值的索引区间</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = n,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// index.maxKey存储了最大的值 </span></span><br><span class="line">        <span class="keyword">if</span> (x == index[mid].maxKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; index[mid].maxKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span>这里尤其注意，我们是用最大值进行比较</span></span><br><span class="line">            <span class="comment">// 但是同时，如果我们发现该最大值大于x，我们没有把握说这个x是在找到的这个块，还是前一个。</span></span><br><span class="line">            <span class="comment">// 所以如果high = mid - 1,有可能会错过正确答案。 </span></span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳出循环，mid就是要找的索引,就能确定块的start和end </span></span><br><span class="line">    <span class="type">int</span> start = index[mid].address, end;</span><br><span class="line">    <span class="keyword">if</span> (mid == indexLen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        end = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        end = index[mid + <span class="number">1</span>].address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后顺序查找返回索引下标 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == arr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>平均查找长度：</strong><br>TODO:待计算</p><img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/blockSearchCaculate.png" class><h3 id="基于树的查找"><a href="#基于树的查找" class="headerlink" title="基于树的查找"></a>基于树的查找</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h4><p>二叉排序树就是二叉搜索树或者二叉查找树<br>根结点上的左子树结点均小于根结点，右子树结点则大于根结点<br>中序遍历后得到递增有序序列</p><p>简单二叉排序树的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于二叉搜索树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 存储key </span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : key(<span class="number">-1</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) : key(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : key(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> TreeNode *root;</span><br></pre></td></tr></table></figure><h5 id="创建和插入二叉树排序树"><a href="#创建和插入二叉树排序树" class="headerlink" title="创建和插入二叉树排序树"></a>创建和插入二叉树排序树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二叉搜索树（排序树）,使用int作key </span></span><br><span class="line"><span class="comment">// key是唯一标识不重复 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode *bst = nullptr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(bst,key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归插入，用于向二叉树中插入某一结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(TreeNode *bst,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bst == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = new TreeNode(key);</span><br><span class="line">        bst = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bst-&gt;key &gt; key)</span><br><span class="line">        Insert(bst-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        Insert(bst-&gt;right,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####排序树的查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* <span class="title function_">Search</span><span class="params">(TreeNode *bst,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bst) <span class="keyword">return</span> nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == bst-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> Search(bst-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> Search(bst-&gt;right,key);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>平均查找长度与分支均衡程度有关。<br>树深度越小，ASL越小。</p><h4 id="平衡二叉树（排序树）"><a href="#平衡二叉树（排序树）" class="headerlink" title="平衡二叉树（排序树）"></a>平衡二叉树（排序树）</h4><p>又叫做AV树，属于二叉排序树。</p><ul><li>左子树和右子树高度相差小于等于1</li><li>平衡因子 = 左 - 右 = {0，1，-1}<br>//TODO:代码<h4 id="B树（排序树）-TODO-b树补充"><a href="#B树（排序树）-TODO-b树补充" class="headerlink" title="B树（排序树）//TODO:b树补充"></a>B树（排序树）//TODO:b树补充</h4>B树属于m插排序树</li><li><em>要求</em>*</li><li>每个结点最多m棵子树</li><li>根结点至少两棵子树</li><li>除根结点外非叶子结点至少有一棵子树</li><li>叶子节点在同一层，称为失败结点，不存储信息，用于分析性能。<br>存储结构如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RANK 10 </span></span><br><span class="line"><span class="comment">// 用于m叉搜索树 也就是B树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> keyNum;  <span class="comment">// 存储key的数量 </span></span><br><span class="line">    <span class="type">int</span> key[RANK]; <span class="comment">// 因为叶子结点不放信息了，所以只能让父结点存储子结点的信息 </span></span><br><span class="line">    BTreeNode *p; <span class="comment">// 父结点 </span></span><br><span class="line">    BTreeNode *ptr[RANK]; <span class="comment">//子树数组 </span></span><br><span class="line">    BTreeNode() : keyNum(RANK),p(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; RANK; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            key[i] = i;</span><br><span class="line">            ptr[i] = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="计算式查找-哈希查找"><a href="#计算式查找-哈希查找" class="headerlink" title="计算式查找-哈希查找"></a>计算式查找-哈希查找</h3><h4 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h4><h5 id="构造原则"><a href="#构造原则" class="headerlink" title="构造原则"></a>构造原则</h5><ul><li>函数便于计算</li><li>设关键字为k,f(k)的地址概率一致，减少冲突。<h5 id="具体构造方法"><a href="#具体构造方法" class="headerlink" title="具体构造方法"></a>具体构造方法</h5></li><li>数字分析法：事先知道关键字集合，并且关键词比地址码位数多，可以使用,选取均匀的若干位。<br>//TODO:待补充</li></ul><p>构造哈希函数要考虑的东西：</p><ul><li>计算函数的时间</li><li>关键字长度</li><li>哈希表大小</li><li>关键字分布</li><li>查找频率<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4></li><li>开放定址法：关键字冲突则以冲突的地址为基础产生新的地址，如此递归，直到不冲突。<ul><li>线性探测再散列：顺序表查看下一个单元</li><li>二次探测再散列：左右探测</li><li>伪随机探测再散列：建立伪随机发生器重新给到新地址</li></ul></li><li>再哈希算法：不断构造不同哈希函数，直到不冲突</li><li>链地址法：构造同义词单链表，相同key放到同一个单链表。<br>整个哈希表存储单链表头指针。<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4>除了哈希函数本身，处理冲突的方法以外，填装因子也影响着性能，<br>$α = n / length$ n表示哈希表元素个数，length则是哈希表长度。</li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插排"><a href="#插排" class="headerlink" title="插排"></a>插排</h3><ol><li><p>数组存储，边插入，边排序，双重循环</p></li><li><p>内循环用将要插入的数从后往前比较，随着已插入的数增加，比较的次数也会增加</p></li></ol><p>时间复杂度为O(n^2)</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><ol><li>将待插入数组看成有序表（初始为0个元素）</li><li>每插入一个元素，都对有序表循环二分，直到找到合适位置插入</li><li>虽然二分的复杂度只有$O(log_2n)$,但是移动后续的元素仍然有O(n)，最终复杂度仍然为O（n^2)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> insert;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> low = <span class="number">0</span>, high = i,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line"><span class="comment">// 假设边输入边插入，也可以用事先存储的数据 </span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; insert;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个数直接放在第一位 </span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">arr[<span class="number">0</span>] = insert;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; insert)</span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line">mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为要想插入还需要移动后面的数据</span></span><br><span class="line"><span class="comment">// 数组中已有i个数,正在插入第i+1个数 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= low; j --)</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j]; </span><br><span class="line">arr[low] = insert;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出排序结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h4><p>使用链表存储进行插入排序</p><p>原理与普通插排一样，时间复杂度为O(n^2)</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>选择出第i小（大）的数。注意区别冒泡排序</p><p>复杂度O（n^2)s</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡,冒泡虽然也是将第i小（大）的数找出来，但是经历了一定次数交换</span></span><br><span class="line"><span class="comment">// n + n-1 + n-2 + ... </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t[ARRSIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRSIZE - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ARRSIZE; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[i],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反观选择排序，则是将第i小（大）的数的下标保存下来，虽然比较次数不变，但是省略了数据交换(swap)的环节</span></span><br><span class="line"><span class="comment">// 简单选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SimpleSelect</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">k = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k != i) </span><br><span class="line">swap(arr[i],arr[k]);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="树选择排序"><a href="#树选择排序" class="headerlink" title="树选择排序"></a>树选择排序</h4><p>树形结构，因为二叉树的特殊结构，比较次数每次除以2，时间复杂度为O（nlog_2n）。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是基于树选择排序的改进</p><p>将数据放在完全二叉树中，根结点&gt;=子结点为大根堆，反之为小根堆。</p><p>下图为小根堆</p><img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/image-20230904220812088.png" class title="image-20230904220812088"><p>实际使用中将数据放在数组中便于存储<br>下标从0开始<br>父结点：$（i-1）/2$,左子：$2*i+1$，右子：$2 * i+2$</p><p><strong>基本过程</strong></p><ol><li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p></li><li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</p></li><li><p>将剩余的n-1个数再构造成大根堆，再将顶端数与当前大根堆末尾位置的数交换，如此反复执行。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="comment">// 让当前堆顶的数下沉，值最小的话就沉入最底 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMaxHeap</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            swap(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 从小到大排序，创建大根堆，从最后一个非叶子父结点开始往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (len<span class="number">-1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        createMaxHeap(i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        createMaxHeap(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>时间复杂度为$O(nlog_2n)$</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分解-解决-合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="comment">// 非递归 </span></span><br><span class="line">template&lt;typename T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = new T[len]; <span class="comment">// 存储归并排序后的结果 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) <span class="comment">// 比较 </span></span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] b;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// -------递归---------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> reg[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="type">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="type">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">    reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">    reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">    reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">    arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序时间复杂度O(nlog_2n)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快排，递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Paritition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">        --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">        ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = Paritition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">        QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h3 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h3><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><strong>可以采用链式和顺序表两种结构存储。</strong><br>一般使用链式，整体思路是：</p><ul><li>先按照个位进行分类，建立0到9号链表，个位数数值一致则归类到一个链表</li><li>然后是十位数，百位数进行分类，以此类推，直到排序完成。<br>时间复杂度为O(d(n+rd))<br>显然基数排列适合位数小的序列。<br>其中d是数的位数，<br>代码略</li></ul><p>github仓库地址：<a href="https://github.com/aspect-ux/kanodesu.github.io/tree/main">https://github.com/aspect-ux/kanodesu.github.io/tree/main</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找与排序&quot;&gt;&lt;a href=&quot;#查找与排序&quot; class=&quot;headerlink&quot; title=&quot;查找与排序&quot;&gt;&lt;/a&gt;查找与排序&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://aspect-ux.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>如何手写光追</title>
    <link href="https://aspect-ux.github.io/2023/07/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E8%B7%B5%E5%8F%8A%E4%BD%9C%E4%B8%9A/RayTracing/"/>
    <id>https://aspect-ux.github.io/2023/07/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E8%B7%B5%E5%8F%8A%E4%BD%9C%E4%B8%9A/RayTracing/</id>
    <published>2023-07-18T07:52:23.822Z</published>
    <updated>2023-07-18T08:03:16.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>本文参考了《Ray Tracing in one weekend》</p><p>闫令琪老师的Games系列课程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Refs&quot;&gt;&lt;a href=&quot;#Refs&quot; class=&quot;headerlink&quot; title=&quot;Refs&quot;&gt;&lt;/a&gt;Refs&lt;/h2&gt;&lt;p&gt;本文参考了《Ray Tracing in one weekend》&lt;/p&gt;
&lt;p&gt;闫令琪老师的Games系列课程&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="C++" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/C/"/>
    
    
  </entry>
  
  <entry>
    <title>RayTracing(下)---Radiometry(辐射度量学)</title>
    <link href="https://aspect-ux.github.io/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/"/>
    <id>https://aspect-ux.github.io/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/</id>
    <published>2023-07-17T09:09:37.180Z</published>
    <updated>2023-07-17T13:09:06.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-Radiometry"><a href="#What-is-Radiometry" class="headerlink" title="What is Radiometry"></a>What is Radiometry</h2><p>辐射度量学主要是对光的描述测量,是在物理意义上对光的确切定义。</p><p>Measurement system and units for illumination</p><p>之所以需要这样一个确切的描述性的东西，是因为无论是之前着色的布林冯，还是whitted风格光线追踪，其实都是不准确，效果不好的。这些方法做了太多简化和trick，以至于实际效果不能满足要求。</p><h2 id="Basic-concepts-of-Radiometry"><a href="#Basic-concepts-of-Radiometry" class="headerlink" title="Basic concepts of Radiometry"></a>Basic concepts of Radiometry</h2><h3 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux (Power)"></a>Radiant Energy and Flux (Power)</h3><p>Radiant Energy 是电磁辐射的能量，用Q表示，单位是joules(焦耳)</p><p>Radiant Flux(power) 是单位时间的能量，其实就是功率，单位瓦特W；</p><p>另一个别称叫做流明，类似于水的功率叫流量</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717181920698.png" class title="image-20230717181920698"><h3 id="Light-Measurements-光照测量"><a href="#Light-Measurements-光照测量" class="headerlink" title="Light Measurements(光照测量)"></a>Light Measurements(光照测量)</h3><p>【基本英文名词】differential(微分) derivative(导数)</p><p>下图为三个表示光照能量的三个量</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/95.png" class title="image-20230213145057013"><ol><li><p><strong>Radiant Intensity</strong> 光源发出的光照</p><p>Definition: The radiant (luminous) intensity is the <strong>power per unit solid angle</strong> emitted by a point light source；单位立体角所表示的功率；或者单位立体角且单位时间的光照能量</p></li></ol><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/96.png" class title="image-20230213145610092"><p><strong>angle and solid angle</strong></p><p>什么是立体角？</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717183805902.png" class title="image-20230717183805902"><p>在任意球上，极小面积为</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/102.svg" class><p>因此，极小立体角（单位球面上的极小面积）为：</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/103.svg" class><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/97.png" class title="image-20230213150222154"><ul><li><p><strong>Irradiance</strong> 照射到物体表面的光照</p><p>Power per unit area</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/98.png" class title="image-20230215142634425"><p>注意，光垂直于表面接受的光越大（上式没写cos)</p></li><li><p>注意，光垂直于表面接受的光越大（上式没写cos)</p><p>![image-20230215143222574](../../../../../trial/github/Books/Obsidian Vault/Books/计算机图形学/99.png)</p><p>接受光照强度可以根据光源计算</p><p>![image-20230215144008523](../../../../../trial/github/Books/Obsidian Vault/Books/计算机图形学/100.png)</p></li><li><p><strong>Radiance</strong> 传播中的光照</p><p>Definition: The radiance(luminace) is the power emitted,</p><p>reflected,transmitted or received by a surface,</p><p><strong>per unit solid angle,per projected unit area</strong>.两次微分</p><p><strong>incident radiance</strong>入射辐射</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/101.png" class title="image-20230215144416607"></li></ul><p>radiance 和irradiance的差别在于是否有方向性</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/104.png" class title="image-20230215145514770"><p><strong>Irradiance versus Radiance</strong></p><p>可以理解成，irradiance是surface上某一点附近的光照</p><p>而radiance是从某个方向照射到surface的某一点附近的光照</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/105.png" class title="image-20230215150213248"><h2 id="BRDF-Bidirectional-Reflectance-Distribution-Function"><a href="#BRDF-Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="BRDF(Bidirectional Reflectance Distribution Function)"></a>BRDF(Bidirectional Reflectance Distribution Function)</h2><p>双向反射分布函数: 从某个方向来的光，反射到不同方向的能量有多少</p><p>irradiance-&gt;power(surface)-&gt;radiance</p><p><strong><code>radiance / irradiance</code></strong> 任意一个出射除以入射</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/106.png" class title="image-20230215153709373"><p>由此，输入入射角，入射irradiance就可以得到</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/107.png" class title="image-20230215154529157"><p>Challenge: Recursive Equation</p><h3 id="渲染方程-The-Rendering-Equation"><a href="#渲染方程-The-Rendering-Equation" class="headerlink" title="渲染方程(The Rendering Equation)"></a><strong>渲染方程(The Rendering Equation)</strong></h3><p><code>result = 自己辐射+brdf反射</code>,注意下半球贡献的光是0</p><p>n*w是cosθ</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/108.png" class title="image-20230215155813155"><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/109.png" class title="image-20230215160925868"><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/110.png" class title="image-20230215161350535"><p>移项、合并、泰勒展开</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/111.png" class title="image-20230215161810833"><p>自发光emission + 直接光 + 一次间接光 + … = L</p><p>其中直接光与间接光的和为<strong>全局光照（global illumination)</strong></p><h2 id="Probability-概率论基础待补充"><a href="#Probability-概率论基础待补充" class="headerlink" title="Probability(概率论基础待补充)"></a>Probability(概率论基础待补充)</h2><p>概率分布函数</p><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717205956558.png" class title="image-20230717205956558"><h2 id="Monte-Carlo-Path-Tracing（蒙特卡洛路径追踪）"><a href="#Monte-Carlo-Path-Tracing（蒙特卡洛路径追踪）" class="headerlink" title="Monte Carlo Path Tracing（蒙特卡洛路径追踪）"></a>Monte Carlo Path Tracing（蒙特卡洛路径追踪）</h2><p><strong>正确地解出渲染方程</strong></p><h3 id="Monte-Carlo-Integration（蒙特卡洛积分）"><a href="#Monte-Carlo-Integration（蒙特卡洛积分）" class="headerlink" title="Monte Carlo Integration（蒙特卡洛积分）"></a>Monte Carlo Integration（蒙特卡洛积分）</h3><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/112.png" class title="image-20230216202106177"><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/113.png" class title="image-20230216202345788">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;What-is-Radiometry&quot;&gt;&lt;a href=&quot;#What-is-Radiometry&quot; class=&quot;headerlink&quot; title=&quot;What is Radiometry&quot;&gt;&lt;/a&gt;What is Radiometry&lt;/h2&gt;&lt;p&gt;辐射度量学主</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Ray Tracing(光线追踪)(上)</title>
    <link href="https://aspect-ux.github.io/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/"/>
    <id>https://aspect-ux.github.io/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/</id>
    <published>2023-07-16T08:15:20.200Z</published>
    <updated>2023-07-17T13:04:25.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h1><p>光线追踪和光栅化是两种不同的成像方式，为什么要选择光线追踪呢？</p><p>光栅化的局限性在于全局效果的控制： 1. 不能实现软阴影 2. 光照不能反射超过1次（目前技术可行效果不好）</p><p>光栅化很快，效果却不好。</p><p>相反，光线追踪很慢，但是很精确</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716162845299.png" class title="image-20230716162845299"><h1 id="Light-Rays"><a href="#Light-Rays" class="headerlink" title="Light Rays"></a>Light Rays</h1><p>Three ideas about light rays(满足三个假设的前提)</p><ul><li>Light travels in straight lines(though this is wrong) 光线沿直线传播</li><li>Light rays do not “collide” with each other if they cross(also wrong) 光线之间无碰撞</li><li>Light rays travel from the light source to the eye(but the physics is in variant under path reversal - reciprocity) (光线可逆性，可以理解为光的方向互逆)</li></ul><p>正常情况下，我们的理解是光源打光到物体上，物体反射光照到人眼，根据反射的颜色我们看到物体。</p><p>而在光线追踪的过程中，我们在做这样一件事：</p><p>从眼睛（相机）出发，投射光线，光线看到的就是人看到的。终点变成了起点，也即上述第三点中的可逆性。</p><ol><li>记录最近的点 2. 判断这个点是否看得见</li></ol><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/76.png" class width="76"><p>上图中，眼睛就是入射光，指向光源就是出射光，法线确定后，着色就确定了。</p><p>光线如何反射多次呢？</p><h1 id="Basic-Ray-Tracing-Algorithm-基本光线追踪算法"><a href="#Basic-Ray-Tracing-Algorithm-基本光线追踪算法" class="headerlink" title="Basic Ray Tracing Algorithm(基本光线追踪算法)"></a>Basic Ray Tracing Algorithm(基本光线追踪算法)</h1><p><strong>Whitted-Style</strong></p><p>射线经过递归弹射（recursively bounce),得到了若干弹射点，如果光源能够照射到该点，着色则会add到结果中</p><p>eye : primary ray</p><p>light: shadow ray</p><p>ref: secondary rays</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716170734885.png" class title="image-20230716170734885"><h2 id="Ray-Surface-Intersection-求交点"><a href="#Ray-Surface-Intersection-求交点" class="headerlink" title="Ray Surface Intersection(求交点)"></a>Ray Surface Intersection(求交点)</h2><p>如何定义光线？一个起点，一个方向，随时间变化</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/78.png" class width="78"><p>如何求交？</p><p><strong>拿光线与球（隐式表面）</strong>进行求交来说。满足下图两个式子，联立后得二次方程。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/79.png" class width="79"><p>求解后得</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716180041106.png" class title="image-20230716180041106"><p>光线求交需要最近的点，在确保t是有意义的后，选取最小的t就是光线与求的交点</p><p>总结，光线与隐式表面求交方程</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716180332940.png" class title="image-20230716180332940"><p><strong>Ray intersection with triangle mesh(explicit显示表面)</strong></p><p>封闭几何中，光线与几何交点数为奇数，则光线在三角内；否则在三角形外。</p><p>查看所有三角形是否与光线有交点。</p><p>将求交问题分解成两个</p><ol><li>如何让光线与平面求交</li><li>交点是否在三角形内（已知）</li></ol><p>问题聚焦到如何求光线与平面交点。</p><p>用一条法线+一个点定义一个平面。接下来只用判断交点连线已知点得到的向量与法线的关系。</p><p>设平面上已知一点p’,p为交点，N是法线向量。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716181507181.png" class title="image-20230716181507181"><p><strong>Moller Trumbore Algorithm</strong></p><p>光线与三角形求交的另一个更快的方法。</p><p><strong>【注意】</strong>这里有一个理解上的问题，也即是o+td到底是什么的问题。在一定时间范围内，它是一条射线；但是在某一个时刻，它是一个点。在计算中，我们考虑交点，其实也就是某一个时刻的角度来看。所以在涉及计算的时候，我们都是把它当作一个点来看。</p><p>与球求交时，把o+td当作交点来联立；上一个与三角形求交则是转换成了和平面求交，也是同理。</p><p>然后到了MT算法对三角形求交，通过观察下图，发现联立的表达式原本的点都变成了向量。所以可能存在理解上的障碍。</p><p>本来应该为<code>o+t * D(vec) = (1-b1 - b2)P0 + b1 P1 + b2P2</code> </p><p>其实观察发现这两个式子是等价的。</p><p>之前提到过，点的重心坐标中α，β，γ均大于0且相加等于1，那么点在三角形内。</p><p>通过克莱姆法则求解</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716181923313.png" class title="image-20230716181923313"><h2 id="Accelerating-Ray-Surface-Intersection-加速求交"><a href="#Accelerating-Ray-Surface-Intersection-加速求交" class="headerlink" title="Accelerating Ray-Surface Intersection(加速求交)"></a>Accelerating Ray-Surface Intersection(加速求交)</h2><p>求交的简单方式： 光线遍历所有物体，找到最近的点</p><p><code>naive algorithm</code> : pixel x object x bounce,计算量太大，很慢</p><p>如果使用<strong>Bounding Volume</strong>(包围盒，包围体)，好处是能够筛掉连包围盒都不相交的物体，极大地剪枝。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717130952068.png" class title="image-20230717130952068"><p>我们经常使用的包围盒是Axis-Aligned Bounding Box(AABB，轴对齐包围盒)，好处是与轴平行，便于计算光线与平面求交。三维情况下理解成三个对面（slabs)包围而成。</p><p>如何判断与盒子相不相交（二维与三维类似，下图为二维）</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717132837004.png" class title="image-20230717132837004"><p>包围盒中对面（pairs of slabs) 全部进入才能算进入，只要有一个对面出去了，就算出去了。</p><p>核心ideas:(选取进入时间的最大时间，出去时间的最小时间)</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717132744508.png" class title="image-20230717132744508"><p>结论</p><ol><li><p>t(exit) &gt; t(enter) &gt;=0 在包围盒中呆过一段时间, 有交点（入和出）</p></li><li><p>t(exit) &lt; 0,包围盒在光线反向延长的背后，由于是射线，所以不可能有交点。</p></li><li><p>t(enter) &lt; 0,t(exit) &gt;= 0,说明光线光源就在盒子里，有交点（只有出）</p></li></ol><p>综上，当t(exit) &gt; 0 &amp;&amp; t(exit) &gt; t(enter) 有交点。</p><p>我们已经知道包围盒的用处和用法了</p><p>那么如何具体地用AABB包围盒进行求交加速呢？</p><h3 id="Uniform-Grids（相同的格子）"><a href="#Uniform-Grids（相同的格子）" class="headerlink" title="Uniform Grids（相同的格子）"></a>Uniform Grids（相同的格子）</h3><p><strong>Preprocess - Build Acceleration Grid</strong>（预处理-创建加速网格）</p><p>预处理指的是在光线追踪之前。</p><ol><li>Find bounding box(找到整个场景的包围盒，将所有物体包围)</li><li>Create grid(设计合适的分辨率来创建网格，划分包围盒)</li><li>Store each object in overlapping cells（标记相交的小盒子，储存起来）</li></ol><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/87.png" class title="image-20230212125454507"><p>光线与盒子求交视为简单操作，当盒子中有物体，再与物体求交，没有则进入下一个盒子。</p><p>【问题】那么如何知道光线下一个进入的盒子是哪个呢？</p><p>这与光栅化一条直线类似（有确定的算法实现）。一个思路是光线从左下角射出，就只用判断右上的临近网格是否有交点。这样就能判断下一个盒子。</p><p>这种算法在<code>Teapot in a stadium</code> 的问题中，效果并不好，场景很大很不均匀，想要找到一个茶壶会很麻烦。求交就会变得很困难。</p><h3 id="Spatial-partitions（空间划分）"><a href="#Spatial-partitions（空间划分）" class="headerlink" title="Spatial partitions（空间划分）"></a>Spatial partitions（空间划分）</h3><p>Examples</p><p>从左到右（represented with 2d, but both in 2d and 3d)</p><ul><li>八叉树（每个维度切成2份，下图为二维状态，是四叉树），与维度呈2的<em>指数幂</em>，不是很理想。</li><li>KD-Tree 类似于二叉树（x，y交替切分），一个格子切一刀，递归</li><li>BSP-Tree 每个空间（非横平竖直地）划分一次</li></ul><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/89.png" class title="image-20230212130527576"><p>KD-Tree预处理Pre-Processing</p><p>【注意】</p><ol><li>划分要沿着x,y,z轴(split axis)</li><li>划分位置不限，一般是在中点。</li><li>数据结构是二叉树，只有叶子节点才有数据</li></ol><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/90.png" class title="image-20230212131538921"><p>具体判断是否有交点的流程：</p><ol><li>和left有交点，发现left是叶子节点，对left中所有物体进行求交，return；如果left不是叶子节点，进一步往下走，直到叶子节点位置。</li><li>然后查看right,同样的道理。</li></ol><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717160634433.png" class title="image-20230717160634433"><p><strong>局限性</strong></p><ol><li><p>KD-Tree会出现一个几何结构，被拆分到多个叶子节点里,划分本身是单纯的直线切割，难免会拆分原来的几何。</p></li><li><p>因为需要对指定包围盒中的所有物体进行求交，但是KD-Tree判断三角形是否与AABB的包围盒有交点很困难，因为顶点不在包围盒里，也有可能有交点。近年间不太使用这个方法。</p></li></ol><h3 id="Object-partition-amp-Bounding-Volume-Hierarchy-物体划分和BVH"><a href="#Object-partition-amp-Bounding-Volume-Hierarchy-物体划分和BVH" class="headerlink" title="Object partition &amp; Bounding Volume Hierarchy(物体划分和BVH)"></a>Object partition &amp; Bounding Volume Hierarchy(物体划分和BVH)</h3><p>上述两种划分方法都有一定局限性。</p><p>而BVH很好的解决了一些问题。BVH是一种得到非常广泛运用的方法。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717162403173.png" class title="image-20230717162403173"><p>BVH划分包围盒是以物体为单位进行划分，不需要考虑三角形与物体求交，结构依旧是二叉树。</p><p>BVH的划分很有讲究，需要保证重叠部分尽可能少。 </p><p>总结：先找包围盒，然后递归地分成两个子集，计算子集地包围盒。当叶子节点的三角形足够少就可以停止了。</p><p>最后储存叶子节点的数据。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717164847097.png" class title="image-20230717164847097"><p><strong>划分的方法 Heuristic</strong></p><p>优先选长轴开始划分，优先划分中间物体，保证左右平衡。</p><p>划分顺序是一个选择的过程。</p><img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717165500868.png" class title="image-20230717165500868"><p><strong>Whitted</strong>风格的光线追踪到此为止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Why-Ray-Tracing&quot;&gt;&lt;a href=&quot;#Why-Ray-Tracing&quot; class=&quot;headerlink&quot; title=&quot;Why Ray Tracing?&quot;&gt;&lt;/a&gt;Why Ray Tracing?&lt;/h1&gt;&lt;p&gt;光线追踪和光栅化是两种不同的成像</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Geometry(几何)</title>
    <link href="https://aspect-ux.github.io/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/"/>
    <id>https://aspect-ux.github.io/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/</id>
    <published>2023-07-13T01:35:24.619Z</published>
    <updated>2023-07-16T06:36:57.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduce-to-Geometry"><a href="#Introduce-to-Geometry" class="headerlink" title="Introduce to Geometry"></a>Introduce to Geometry</h1><h2 id="Examples-of-Geometry"><a href="#Examples-of-Geometry" class="headerlink" title="Examples of Geometry"></a>Examples of Geometry</h2><p>机械</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094334796.png" class title="image-20230713094334796"><p>水</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094400111.png" class title="image-20230713094400111"><p>毛发</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094451880.png" class title="image-20230713094451880"><h1 id="Representation-of-Geometry"><a href="#Representation-of-Geometry" class="headerlink" title="Representation of Geometry"></a>Representation of Geometry</h1><p><strong>Implicit(隐式表达)</strong></p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094634138.png" class title="image-20230713094634138"><p>隐式表达，一般看表达式，但是光看表达式并不直观。algebraic方式。</p><p>另一种方法是constructive solid geometry（csg,构造立体几何法)</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713095753987.png" class title="image-20230713095753987"><p>距离函数Distance Function</p><p>希望blend得到AB的中间状态，SDF是有向距离场</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713100223756.png" class title="image-20230713100223756"><p>如果是第一行的图，结果不能得到左黑右白的中间态</p><p>第二行使用SDF，通过blend，可以得到0的位置，颜色围绕0开始渐变。</p><p>插值得到的SDF再转回原图像</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/166.png" class><p><strong>Explicit(显式表达)</strong></p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094802801.png" class title="image-20230713094802801"><p>直接通过uv映射方式定义</p><p>隐式不知道函数的结果是哪个变量，显示知道；显示通过已知的自变量就能得出图形的结果样子。</p><p><code>Geometry is hard!</code></p><ol><li><p>Point Cloud（最简单）,lists of point,点足够多就成了面</p></li><li><p>Polygon Mesh(多边形网格)，如三角网格</p></li><li><p>The Wavefront Object File(.obj) Format，这种.obj文件不是目标文件，而是一种文本格式，记录了顶点（vertices)，法线（normal),纹理（texture),坐标（coordinates)</p><p>还有它们的connectivities；本质上就是一个3d白模文件。</p></li></ol><h3 id="Curve（曲线）"><a href="#Curve（曲线）" class="headerlink" title="Curve（曲线）"></a><strong>Curve</strong>（曲线）</h3><p>以上讲了两种几何的两种表达方式。接下来主要学习曲线这种几何的实现与应用。</p><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a><strong>贝塞尔曲线</strong></h4><p>类似于ps钢笔工具，选择控制点，帮助绘制曲线（<strong>显示表达</strong>）</p><p>如何绘制贝塞尔曲线？</p><p>de Casteljau Algorithm</p><p>举例：要求从b0开始，b2结束，t是时间记为【0，1】，共计三个控制点，如下图</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713152733714.png" class title="image-20230713152733714"><p>以时间t为单位进行划分，得到b01,b11,连线后再划分，recursively直到无法划分</p><p>最后我们得到曲线过三个点。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713160355108.png" class title="image-20230713160355108"><p><strong>更普遍地</strong></p><p>两个控制点画直线</p><p>三个控制点，绘制二次贝塞尔曲线。</p><p>…</p><p>若干个无限递归下去，n个点逐渐递归成一个点，不难发现<code>（1-t + t) ^n</code>的展开项正是控制点bj的权重</p><p>称之为伯因斯坦多项式，以下是n阶贝塞尔曲线的解析式</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713160850476.png" class title="image-20230713160850476"><p>有关贝塞尔曲线的性质，1. 起点终点都固定 2.初始方向，最后方向确定 3. affine property仿射性质，想要移动变换曲线可以通过变换控制点。 </p><p>4.凸包性质（Convex Hull)：</p><p>想象蓝色线条为橡皮筋，橡皮筋包围的区域就是凸包</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715160538189.png" class title="image-20230715160538189"><p>贝塞尔曲线一定在凸包里面</p><p>【补充】</p><ol><li>二项展开：</li></ol><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161623637.png" class title="image-20230713161623637"><p>​    简记为：</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161650108.png" class title="image-20230713161650108"><ol start="2"><li><p>莱布尼兹多项式展开</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161755950.png" class title="image-20230713161755950"></li></ol><p>​    展开通项为（又叫做多项式定理）</p>   <img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161934995.png" class title="image-20230713161934995"><ol start="3"><li><p>伯因斯坦多项式</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715154925547.png" class title="image-20230715154925547"></li></ol><h4 id="Piecewise-Bezier-逐段贝塞尔"><a href="#Piecewise-Bezier-逐段贝塞尔" class="headerlink" title="Piecewise Bezier(逐段贝塞尔)"></a>Piecewise Bezier(逐段贝塞尔)</h4><p>多段3阶贝塞尔的连接。</p><p>示意图，曲线要连续，最后两个点决定终点导数，如果终点导数和下一个起点导数相等（蓝色标记共线等长），则认为曲线光滑连续。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/60.png" alt="60"><p>【补充】</p><p><strong>Spline 样条</strong></p><p>有多个控制点，保持连续。一个可控的曲线。</p><p>用的多的有B-Spline(复杂度高)</p><h3 id="Surface-曲面"><a href="#Surface-曲面" class="headerlink" title="Surface(曲面)"></a>Surface(曲面)</h3><p>如何用贝塞尔曲线拓展到曲面，下图中，有一个4x4=16控制点的几何。</p><p>一共有四行，每行一条3阶贝塞尔曲线，只要控制贝塞尔曲线的高度，进而就能控制面的形状。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715182508405.png" class title="image-20230715182508405"><p>具体操作如下图，其实上述有一个问题，竖轴（假设贝塞尔曲线所在轴）可以随意控制，但是横轴的变形却未提及</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715183005306.png" class title="image-20230715183005306"><p>根据上图我们可以发现，四条贝塞尔分别插值，最后得到4个点再做二维的插值。由此可以实现贝塞尔曲面。</p><p>设参数为（u，v)，横轴和竖轴的时间参数。显然这里也验证了贝塞尔曲线是显示的表达方式。</p><h1 id="Mesh-Operations-Geometry-Processing"><a href="#Mesh-Operations-Geometry-Processing" class="headerlink" title="Mesh Operations(Geometry Processing)"></a>Mesh Operations(Geometry Processing)</h1><h2 id="Mesh-subdivision-网格细分"><a href="#Mesh-subdivision-网格细分" class="headerlink" title="Mesh subdivision(网格细分)"></a>Mesh subdivision(网格细分)</h2><p>什么是细分？</p><p>可以理解为提高模型网格的精度（分辨率）</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716120504980.png" class title="image-20230716120504980"><p>如何细分？</p><ol><li>创建更多三角形</li><li>调整三角形的位置</li></ol><h3 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h3><p>循环细分，拿一个三角形来举例，首先分成4个小三角形，然后调整位置。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/61.png" class width="61"><p>具体如何tune position(调整位置)呢？</p><ol><li>得到的<strong>新顶点</strong>会根据与老顶点相对位置进行加权平均，如下图</li></ol><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/62.png" class width="62"><ol start="2"><li><p>原来的**老顶点（old vertices)**也会进行一定程度的调整，其中n是degree,下图对于中间的白点，</p><p>由于度为6，连接了多个三角形，重要性相对就会比较低（n越大，白点的权重越小）；同时邻点权重会变大。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/63.png" class width="63"></li></ol><h3 id="Catmull-Clark-Subdivision"><a href="#Catmull-Clark-Subdivision" class="headerlink" title="Catmull-Clark Subdivision"></a>Catmull-Clark Subdivision</h3><p>使用Loop subdivision的条件是网格为三角形。但是如果网格为下图这样的情况。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716131744281.png" class title="image-20230716131744281"><p>Catmull-Clark可以用作不同形状的面。</p><p>【条件】extraordinary vertices(定义度为不等于4的点为奇异点)</p><p>下图中，将边的中点连接交会到一个新的点（注意这个新的点同时也是面的中心）；最后得到的两个新点再连接。发现已经没有三角形了。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/64.png" class width="64"><p>再细分多次</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716132324232.png" class title="image-20230716132324232"><p>Catmull-Clark细分方法总结，1. 增加图元的方法是通过连接中点和图元中心 2.调整顶点位置（tune position)的方法依然是通过加权平均得到。图元中心为f，边的中点为e，图元顶点为v。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/65.png" alt="65"><h2 id="Mesh-simplification"><a href="#Mesh-simplification" class="headerlink" title="Mesh simplification"></a>Mesh simplification</h2><p>减少mesh图元的同时不改变形状</p><p>下图为不同数量三角面的结果。类似于mipmap不同层级用不同图片。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716140137989.png" class title="image-20230716140137989"><p>如何做网格简化</p><p><strong>边坍缩</strong></p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716140449449.png" class title="image-20230716140449449"><p>Quadric Error Metric(二次误差度量)实现边坍缩，下图中，我们需要将上面三个顶点坍缩成一个蓝色点。</p><p>需要找到一个最小的蓝点，使得该点（边）到其他三个点（面）的距离平方和最小。这个平方和就是二次度量误差，新建优先队列，将最小的误差放在前面，每次坍缩最小的那个。</p><img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716142333331.png" class title="image-20230716142333331">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduce-to-Geometry&quot;&gt;&lt;a href=&quot;#Introduce-to-Geometry&quot; class=&quot;headerlink&quot; title=&quot;Introduce to Geometry&quot;&gt;&lt;/a&gt;Introduce to Geometry&lt;/</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Shading(着色)</title>
    <link href="https://aspect-ux.github.io/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/"/>
    <id>https://aspect-ux.github.io/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/</id>
    <published>2023-07-11T02:58:51.658Z</published>
    <updated>2023-07-17T03:50:04.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading(着色)"></a>Shading(着色)</h1><h2 id="Visibility-Occulusion-可见性-遮蔽"><a href="#Visibility-Occulusion-可见性-遮蔽" class="headerlink" title="Visibility/Occulusion(可见性/遮蔽)"></a>Visibility/Occulusion(可见性/遮蔽)</h2><p><strong>Painter’s Algorithm</strong> 从后往前画</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711122733524.png" class title="image-20230711122733524"><p>但是由于自遮挡的关系，有些无法具体描述远近的（如上图左右面的绘制），绘制顺序显得尤为重要。</p><p>左，下，右，上，这个顺序结果正确</p><p>但是右，上，左，下，由于左下两面的错误遮挡，导致结果错误。</p><p>假如一个模型是两个蛇状管道相互缠绕组合而成的，那渲染先后的问题就更加困难，正方体能够区分不同面无非是一个面遮挡另一个，后者不规则的分区有着非单一的复杂遮挡关系，如此看来这种算法局限性也很大</p><p><strong>结论：</strong> 一定程度上画家算法是有效的，但是sorting layer的问题是难以解决的。</p><p><strong>ZBuffer</strong> 深度缓存</p><p>为了解决画家算法的问题，引入深度缓存</p><p>简而言之，对每个像素的深度进行保存，保留最近的那个深度值</p><ul><li>framebuffer存颜色值</li><li>depth buffer(z-buffer)存深度值</li></ul><p>效果如下图，记z值为positive</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711125920188.png" class title="image-20230711125920188"><p>具体代码实现算法，记初始zbuffer的值都是无限大，每绘制一个图元都来一次二重循环遍历所有像素，不断装填覆盖更小的z</p><p>时间复杂度O(n),设三角形个数为n,三角形之间覆盖的个数为常数个。</p><p>zbuffer的算法显然是一个很好的解决方法。</p><p>【提高】</p><p>MSAA常用于反走样，一个像素中有多个采样点，然后根据采样点的分布率来评判该像素颜色深浅</p><p>如果绘制有重叠部分的两个三角形，对于抗锯齿的部分，如果只是对像素进行z-buffer，然后边缘锯齿用MSAA,</p><p>结果也还行。</p><p>想要更好的结果，我们也许可以对采样点进行zbuffer,毕竟像素是呆板的块状，如果能够进一步细化，或许分布率不会变，却也能让先后关系更精确，进而结果更精确。</p><h2 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination&amp;Shading"></a>Illumination&amp;Shading</h2><p><strong>BlinnPhong Model</strong></p><p>布林冯光照模型</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711133718085.png" class title="image-20230711133718085"><p>三个相加等于着色结果</p><p>着色是局部的</p><p><strong>着色不等于阴影（shading != shadow)</strong></p><p>n是法线向量，h是半程向量（入射光向量l与眼睛视线向量v的和的单位向量）</p><p>以下为布林冯的高光</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711140322707.png" class title="image-20230711140322707"><p>最终结果</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711141207203.png" class title="image-20230711141207203"><p><strong>Shading Frequency</strong> 着色频率问题</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711142158445.png" class title="image-20230711142158445"><h2 id="Graphics-Pipeline-Real-time-rendering"><a href="#Graphics-Pipeline-Real-time-rendering" class="headerlink" title="Graphics Pipeline(Real-time rendering)"></a>Graphics Pipeline(Real-time rendering)</h2><p>图形渲染管线，实时渲染管线</p><p>Application 应用阶段，输入顶点数据</p><p>Geometry 几何阶段</p><p>Rasterization 光栅化阶段</p><ul><li><p>Shading 着色（shaded fragment)</p></li><li><p>framebuffer （严格来说属于光栅化）</p></li></ul><p>输出屏幕</p><p>除了常规的fragment shader,vertex shader</p><p>现在还有compute shader(通用)，geometry shader(几何shader)等可编程部分</p><h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>每个三角形顶点都有一个uv坐标（0，1），可以反复平铺</p><h3 id="Barycentric-coordinates-重心坐标"><a href="#Barycentric-coordinates-重心坐标" class="headerlink" title="Barycentric coordinates(重心坐标)"></a>Barycentric coordinates(重心坐标)</h3><p><strong>【注意】</strong> 我们首先要区别点的重心坐标和三角形的重心坐标</p><p>interporate across triangle在三角形内进行插值，希望三角形内部得到平滑过渡</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712105733661.png" class title="image-20230712105733661"><p>α，β，γ均大于等于0，重心在三角形内</p><p>A点在重心坐标系的重心坐标（α，β，γ）为（1，0，0），B为（0，1，0）</p><p>三角形的重心坐标计算公式就是相加除以3，重心坐标为（A.x+B.x+C.x/3，A.y+B.y+C.y/3，A.z+B.z+C.z/3）</p><p>三角形内任意一点的重心坐标计算结论如下</p><p><strong>结论</strong></p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712110740529.png" class title="image-20230712110740529"><p>【补充】</p><ul><li>α+β+γ = 1，是重心坐标的性质，同时是重心坐标在ABC平面上的要求</li><li>三维中的属性在三维中做插值，否则投影到屏幕再做可能会因为重心不一致而错误；</li></ul><h3 id="Texture-queries"><a href="#Texture-queries" class="headerlink" title="Texture queries"></a>Texture queries</h3><p>a pixel on a texture is a texel(纹素)</p><p>texture mapping简单应用：通过查uv来将纹理的值作为Diffuse Color</p><p>纹理太小，采样后会被拉大texture magnification</p><p>最后结果不精确，得到的会是明显的像素块的非连续结果</p><p><strong>解决方法：</strong>纹素，屏幕分辨率差别大，texture queries的时候，用屏幕像素坐标查询texture的uv,</p><p>使用双线性插值（Bilinear Interpolation) 来解决非连续的问题。</p><p>水平、竖直都进行下述插值操作，对texel的4个像素进行插值</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712134134465.png" class title="image-20230712134134465"><p>另有Bicubic的方法，取周围16个像素</p><p><strong>1. Point Sample problem</strong></p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712175243366.png" class title="image-20230712175243366"><p>采样纹理的时候为什么会出现这样的走样（artifact)？</p><p>当纹理特别大，哪怕一个纹素也包括了很多高频信息，人眼跟不上变化频率，于是产生了走样。</p><p>或者，texture queries 的时候，采样一个像素的时候只使用一个采样点，采样频率不够，导致最后结果表现不够精确连续。</p><p>增加采样点虽然理论可行，但是计算量太大。</p><p><strong>2. Range Query Problem</strong></p><p>范围查询不像点查询一样进行采样，而是直接查询一个范围的结果，这样就避免了上述的计算量。</p><p>范围查询根据功能可以分为平均，最大，最小….很多种不同类的方式。</p><p>引入<strong>Mipmap</strong>的概念，(fast,approximate,square)，分为多级，分辨率逐级减半，D = log(L)</p><p>使用mipmap比原来多用了1/3的空间存储</p><p>如何使用mipmap?</p><p>离人眼近的地方，使用低级别的，分辨率更高的，离人眼远的地方，对精度要求低，可以用分辨率更低的mipmap。</p><p>【注】实际操作中，由于mipmap本身是方块，查询方式离散，层与层之间还需再进行插值。本身xy两轴上分别做了插值让纹理适配原像素，然后又在层与层直接插值，称之为三线性插值（trilinear interpolation)</p><p><strong>3. mipmap limitation &amp; Anisotropic Filter</strong></p><p>mipmap远处会出现<strong>过度模糊</strong>的问题，</p><p>问题在哪？其实还是出在三线性插值上，之前提到mipmap的approximate的特性，本身插值方法就是人为近似的，而且又只能处理方形区域的查询。</p><p>引入效果更好的方法。</p><p>Anisotropic Filter各向异性过滤（ripmap)</p><p>游戏中2x指的是左上角两层的范围，存储量收敛到原来的3倍，游戏中一般都可以开到最高，对性能不会有任何影响。</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193451568.png" class title="image-20230712193451568"><p>这种方法由于x,y方向都有拉伸，查询不局限于方形，扩展到矩形</p><p><strong>但是</strong>如下图，screen上的一块像素表达的内容在texture上也许是斜着的，使用各向异性查询，就要求将整块斜块用矩形包围，最后结果overblur。irregular footprint（覆盖区） in texture的问题</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193630633.png" class title="image-20230712193630633"><p>竖着的长条可以解决，但是斜着的就不好解决。</p><p><strong>EWA filtering</strong></p><p>将查询范围用多个圆包围，多次查询</p><p>可以处理不规则图形，但是计算量很大</p><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712195236130.png" class title="image-20230712195236130"><h3 id="Application-of-textures"><a href="#Application-of-textures" class="headerlink" title="Application of textures"></a>Application of textures</h3><p>现代GPU中，texture = memory + range query(filtering)</p><ol><li><p>Environment Map 环境贴图，物体反射周围的光;描述不同方向的光照信息。</p><p>Shperical Map,发生扭曲；Cube Map</p></li><li><p>Bump/Normal Map</p><p>凹凸贴图如何绘制法线制造凹凸感？</p><ul><li>设原来法线为（0，0，1）</li><li>求偏导（derivatives),假设u,v变化单位1</li></ul><img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230713090701583.png" class title="image-20230713090701583"><p>切线逆时针旋转90度得到法线</p><p>得到法线（-dp/du,-dp/dv,1)</p><p>这样，通过凹凸贴图的纹理映射，制造假的法线，实现结果的凹凸。</p></li><li><p>Displacement Map,位移贴图，真正的移动了原模型，不同于凹凸贴图。</p><p>要求三角形很细，三角形的频率要比纹理高；采样率高，模型足够细致</p><p>DX上有一个方法叫动态细分，即便是模型不是很精细，但是可以根据需要进行选择性移动</p></li></ol><p>其它</p><p><strong>Provide Precompute shading</strong></p><p><strong>3d textures and volume rendering</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shading-着色&quot;&gt;&lt;a href=&quot;#Shading-着色&quot; class=&quot;headerlink&quot; title=&quot;Shading(着色)&quot;&gt;&lt;/a&gt;Shading(着色)&lt;/h1&gt;&lt;h2 id=&quot;Visibility-Occulusion-可见性-遮蔽&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio下Cpp的配置</title>
    <link href="https://aspect-ux.github.io/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/"/>
    <id>https://aspect-ux.github.io/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/</id>
    <published>2023-05-24T06:18:26.100Z</published>
    <updated>2023-07-18T08:42:55.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VS-CPP-配置"><a href="#VS-CPP-配置" class="headerlink" title="VS CPP 配置"></a>VS CPP 配置</h1><p>在VS上编写cpp程序时，经常出现少了xx库或者xx undefined</p><p>分为静态和动态配置方法</p><ol><li><p>下载对应资源包</p></li><li><p>认识配置方法</p></li></ol><p>属性面板有三个选项，</p><img src="/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/1.png" class title="image-20230524142140450"><p><strong>动态载入：</strong> ①对于下载的include 在”C/C++”下配置；②lib在linker下配置，具体lib文件在linker-&gt;input下配置；③dll一般放在根目录（或者32dll放在sysWOW64,64dll放在system32下）</p><p><strong>静态载入：</strong> 前两步和之前一样，但是第三步变成在linker-&gt;proprocessor中加入对应宏</p><p>注意对应版本文件夹</p><h2 id="常用文件解释"><a href="#常用文件解释" class="headerlink" title="常用文件解释"></a>常用文件解释</h2><p><strong>bin文件夹</strong></p><p>放置二进制文件，也即可执行二进制文件</p><p><strong>.lib文件和.dll文件</strong></p><p>在了解”.lib”文件之前，我们得清楚几个点</p><p>①首先，程序编译和运行是两个过程</p><p>②其次，语言分两种，编译型语言和解释型语言：<br>a.编译型语言里程序执行一般是有编译-&gt;链接这两个过程的<br>b.解释型语言没有这两个过程，你可以说没有链接过程，也可以说随时都在链接</p><p>③大家看到的静态链接、动态链接实际都发生在编译阶段！</p><p>④链接简单来说就是把编译的代码里的对象符号与软件、库中的对象关联的过程</p><p>lib文件是静态链接库文件，其中存放的是函数调用的信息，在windows操作系统中起到链接程序和函数的作用。其意义在于代码重用，程序员将常用的功能写成函数，保存为lib文件，在以后编程要实现这些功能的时候，就不需要再重新编写代码，而是直接调用写好的lib文件，这很大程度上减轻程序员的负担。</p><p>dll文件是动态链接库文件，你可以简单的把DLL看成一种仓库，它提供给你一些可以直接拿来用的变量、函数或类。</p><p>对于动态链接，其在运行时，会由操作系统动态加载所需的库<br>动态链接和静态链接主要区别就是加载过程</p><p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VS-CPP-配置&quot;&gt;&lt;a href=&quot;#VS-CPP-配置&quot; class=&quot;headerlink&quot; title=&quot;VS CPP 配置&quot;&gt;&lt;/a&gt;VS CPP 配置&lt;/h1&gt;&lt;p&gt;在VS上编写cpp程序时，经常出现少了xx库或者xx undefined&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="随记" scheme="https://aspect-ux.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Rasterization(光栅化)</title>
    <link href="https://aspect-ux.github.io/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/"/>
    <id>https://aspect-ux.github.io/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/</id>
    <published>2023-05-23T12:15:23.290Z</published>
    <updated>2023-07-16T03:51:26.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization(光栅化)"></a>Rasterization(光栅化)</h1><p>前一节讲了变换（transform),过程总览如下图</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/1.png" class><h2 id="光栅化流程"><a href="#光栅化流程" class="headerlink" title="光栅化流程"></a>光栅化流程</h2><p>之前提到了MVP过程，在这之后,所有的物体都会停留在【-1，1】^3</p><p>立方体(Canonical Cube)空间中，然后要进行光栅化。</p><h3 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a>Viewport Transformation(视口变换)</h3><p>也就是将物体“画”到屏幕上，这里具体要做的是上图中的viewport mapping</p><p><strong>即将【-1，1】拉伸(重映射remapping)到【width,height】的屏幕上</strong></p><p>设置什么样的变换矩阵才能变换成功呢？</p><p>（其实在半兰伯特光照模型中就有这个思路，先乘以1/2，然后加上1/2，就转换到【0，1】区间了。）</p><p>根据这个思路得到转换矩阵</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230523205240615.png" class title="image-20230523205240615"><p>需要注意：这个变换与z值无关</p><h3 id="Rasterizing-triangles-into-pixels"><a href="#Rasterizing-triangles-into-pixels" class="headerlink" title="Rasterizing triangles into pixels"></a>Rasterizing triangles into pixels</h3><p>上面只是说了光栅化是画物体到屏幕，具体来说，物体是由一个又一个多边形构成，最基本的元素是三角形，我们要做的是让这个三角行用像素画出来(或填充)，进而在屏幕上显示。</p><p>具体实现算法就是通过遍历像素，判断像素中心是否在三角形内。</p><p><strong>如何判断是否在三角形内</strong></p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_2.png" class><p>假设从ABC逆时针方向来看，</p><p>我们发现一个规律，但凡P点在三角形内，一定满足</p><p>n1 = AB x AP</p><p>n2 = BC x BP</p><p>n3 = CA x CP</p><p>三个方向都是朝着纸面向上，也就是说z分量大于0(充要条件),否则，则不在三角形内。</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_3.png" class title="homework2_3"><p>这样就可以判断是否在三角形内</p><p><strong>另外遍历像素很麻烦，这里引入包围盒(Bounding Box)</strong></p><p> 引入axis-aligned bounding box(AABB)轴对齐包围盒</p><p>每一行都根据三角形边界用一个包围盒，这样就不会浪费，从而实现光栅化的加速。</p><p>但是并不简单。</p><p>在这里如果要单纯光栅化一个三角形，我们只知道三个顶点的坐标，这里可以粗略地将三角形用方形框住，只遍历方形中的像素。</p><h2 id="光栅化细节之反走样"><a href="#光栅化细节之反走样" class="headerlink" title="光栅化细节之反走样"></a>光栅化细节之反走样</h2><p>如果只是按照上述流程，结果其实并不理想。</p><p>最明显的就是，像素是方形，那么填充三角形会产生锯齿Jaggies</p><h3 id="Aliasing-走样"><a href="#Aliasing-走样" class="headerlink" title="Aliasing(走样)"></a>Aliasing(走样)</h3><p>sample artifacts,采样所造成的瑕疵</p><ul><li>Jaggies(锯齿)</li><li>Moire (摩尔纹)</li><li>Wagon Wheel Illusion(车轮效应) 时间上采样的问题</li></ul><p>信号变化太快，采样跟不上</p><h3 id="如何反走样？-Antialiasing-Ideas"><a href="#如何反走样？-Antialiasing-Ideas" class="headerlink" title="如何反走样？(Antialiasing Ideas)"></a>如何反走样？(Antialiasing Ideas)</h3><h4 id="卷积、时域、频域、空间域和滤波"><a href="#卷积、时域、频域、空间域和滤波" class="headerlink" title="卷积、时域、频域、空间域和滤波"></a>卷积、时域、频域、空间域和滤波</h4><ol><li>首先：这里用信号的方式表示反走样如下图，不同的函数，相同的采样点，采样结果却一样，导致不同信号无法区分，于是产生了走样</li></ol><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145800199.png" class title="image-20230706145800199"><ol start="2"><li><p><strong>反走样的方法是Blurring</strong>：采样前做滤波(pre-filtering)，什么是滤波？抹除特定的频率。</p><p>滤波 = 卷积 = 平均，顺序不能反先滤波后采样，不然不过是将走样后的图像再模糊了一下，还是走样的。</p></li><li><p>什么是卷积、时域、频域？</p><p>下图说明了卷积的过程，特定的卷积核对信号本身进行加权操作</p></li></ol><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706152137019.png" class title="image-20230706152137019"><ul><li><p><strong>时域（time domain）</strong>自变量是时间,即横轴是时间,纵轴是信号的变化。其动态信号x（t）是描述信号在不同时刻取值的函数。</p></li><li><p><strong>频域（frequency domain）</strong>自变量是频率,即横轴是频率,纵轴是该频率信号的幅度,也就是通常说的频谱图。</p></li><li><p><strong>空间域(spatial domain)</strong>     简称空域，又称图像空间(image space)，一般这个概念会出现在数字图像处理中，指由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。</p></li></ul><h4 id="Fourier-Transform-傅里叶变换"><a href="#Fourier-Transform-傅里叶变换" class="headerlink" title="Fourier Transform(傅里叶变换)"></a>Fourier Transform(傅里叶变换)</h4><p>傅里叶变换能做什么？将信号从时域转换到频域（对于一张图像，时域指不同空间的信号？；频域指的是信号随频率变化的函数）</p><p>傅里叶展开：任何周期函数都可以写成正弦余弦和的函数</p><p>傅里叶变换和逆傅里叶变换，将不同的函数之间相互转换</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145241029.png" class title="image-20230706145241029"><p>如以下例子</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150533898.png" class title="image-20230706150533898"><p>首先确定信号变换时一般都是默认为周期性函数，但是对于非周期性的图像，则会水平竖直平铺多张图像，</p><p>边界变化剧烈，于是有了两条白线。</p><p>任何信号在不同频率的样子叫做频谱。</p><p>下图为高通</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150930320.png" class title="image-20230706150930320"><p>下图为低通</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151033905.png" class title="image-20230706151033905"><p>下图为高低频都去掉的结果（中通滤波）</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151222306.png" class title="image-20230706151222306"><h4 id="Convolution-Theorem-卷积定理"><a href="#Convolution-Theorem-卷积定理" class="headerlink" title="Convolution Theorem(卷积定理)"></a>Convolution Theorem(卷积定理)</h4><p>spatial domain上的卷积（平均）模糊等价于</p><p>frequency domain上的乘积</p><p>时域的卷积等于频域的乘积（暂时不清楚spatial domain和time domain的区别）</p><p>尤其注意，卷积定理有两个，时域的乘积 也等于 频域的卷积，对偶性（详情查询）</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706153322488.png" class title="image-20230706153322488"><p>上图的卷积核，也叫做滤波器，由于上图将低频信息保存了下来，也叫做低通滤波器low box filter</p><p>越大的box结果越模糊。</p><p>走样现象的另一种解释</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706155140903.png" class title="image-20230706155140903"><p>像素很大，采样很稀疏，频谱密集</p><p>采样速度不够快，导致频谱混叠，信息损失，造成走样</p><h4 id="归纳反走样或减少走样方法"><a href="#归纳反走样或减少走样方法" class="headerlink" title="归纳反走样或减少走样方法"></a>归纳反走样或减少走样方法</h4><ol><li><p>Increase sample rate(reduce aliasing error)</p></li><li><p>先模糊后反走样，先低通，后采样，高频滤掉，就不会产生重叠；</p><p>关键点在于，频谱混叠导致结果失真，但是模糊只会丢掉高频细节。后者显然更好</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706160213696.png" class title="image-20230706160213696"></li></ol><h3 id="实际应用中的反走样"><a href="#实际应用中的反走样" class="headerlink" title="实际应用中的反走样"></a>实际应用中的反走样</h3><h4 id="MSAA-Multi-Sample-Anti-Aliasing"><a href="#MSAA-Multi-Sample-Anti-Aliasing" class="headerlink" title="MSAA(Multi Sample Anti-Aliasing)"></a>MSAA(Multi Sample Anti-Aliasing)</h4><p>将一个像素分成多个“小像素”</p><p>如4x4</p><img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706161007121.png" class title="image-20230706161007121"><p>根据小像素覆盖率来进行模糊，这样能够更准确的确定模糊度，然后采样</p><p>注意：MSAA并不是通过提高分辨率真的增加”小像素“，只不过是在一个像素里采样若干个点</p><p>但是上述例子的代价是增加了4x4共16倍的采样量</p><p>另外还有FXAA（后处理，得到锯齿才处理）和TAA等方法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rasterization-光栅化&quot;&gt;&lt;a href=&quot;#Rasterization-光栅化&quot; class=&quot;headerlink&quot; title=&quot;Rasterization(光栅化)&quot;&gt;&lt;/a&gt;Rasterization(光栅化)&lt;/h1&gt;&lt;p&gt;前一节讲了变换（</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Transformation(变换)</title>
    <link href="https://aspect-ux.github.io/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/"/>
    <id>https://aspect-ux.github.io/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/</id>
    <published>2023-05-17T16:09:51.767Z</published>
    <updated>2023-07-14T09:06:40.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h1><h2 id="变换的数学意义-介绍"><a href="#变换的数学意义-介绍" class="headerlink" title="变换的数学意义(介绍)"></a>变换的数学意义(介绍)</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation"></a>Why Transformation</h3><p><strong>Q1： 为什么要学习变换呢？</strong></p><p>A1： 动画的实现，光栅化图像变换投射进“人眼”。由于计算机最终的变换服务于数学世界，于是同一用矩阵来表示变换，线性代数中学过对应知识。</p><p><strong>Q2: 举例有哪些变换？</strong></p><p>A2： Scale Matrix，缩放；Reflection Matrix,对称(镜像)；</p><p>Shear Matrix,切变(有称”错切“，”斜切“)；</p><p>Rotate Matrix…</p><p>旋转矩阵推导</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/推导旋转矩阵.jpg" alt="image-20230518004250114" style="zoom: 67%;"><p>到目前为止的变换，我们都可以对(x,y…)进行线性变换(Liner transformation)得到变换结果(x’,y’)</p><p><strong>但是平移变换不行？</strong></p><p>试想一下，如果对x平移一个单位，那么变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/平移变换.jpg" alt="image-20230518005707401" style="zoom:80%;"><p>无法用一个矩阵就解决变换，（上面的变换形式引出仿射变换(Affine Transformation)的概念），同时进行线性和平移变换</p><p>接下来</p><h3 id="Homogeneous-coordinates-齐次坐标"><a href="#Homogeneous-coordinates-齐次坐标" class="headerlink" title="Homogeneous coordinates(齐次坐标)"></a>Homogeneous coordinates(齐次坐标)</h3><p>要想用一个矩阵表示所有变换</p><p>这里引入了齐次坐标的概念，以二维举例，引入第三维度</p><p>设点的第三维度为1，向量为0.</p><ul><li>之所以向量为0，是因为向量具有方向不变性，假设进行平移变换，我们希望这个向量前后不变的；但是如果但三维度不是0，那么结果就有可能出现向量方向的变化。</li><li>之所以点为1，是因为这样就解决了<strong>平移问题</strong>，通过增加维度，使得一个矩阵同时表示平移和线性变换。</li></ul><p>另外</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/%E7%82%B9%E4%B8%8E%E5%90%91%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="image-20230518012256246"><p>在齐次坐标系下，不难推导出，点+点等于中点，只需同时除以w=2,使得w回归为1</p><p>最后放一张仿射变换的图片和常见变换公式的图片</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/affineTransformation.png" class title="image-20230518012637415"><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518013201379.png" class title="image-20230518013201379"><h3 id="Composing-Transform-变换组合"><a href="#Composing-Transform-变换组合" class="headerlink" title="Composing Transform(变换组合)"></a>Composing Transform(变换组合)</h3><ul><li><p>我们需要知道，复杂的一连串的变换是可以组合的，因为虽然变换越多，矩阵越多，但是由于都是乘法，根据矩阵结合律可以最终合成一个</p></li><li><p>平移和旋转具有严格先后顺序，毕竟先加后乘，与先乘后加结果不一样；具体来说是先乘后加，先变换后平移</p></li></ul><p><strong>Decomposing complex transform(解构复杂变换)</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518014414740.png" class title="image-20230518014414740"><p>由图知，直接从图一到图四其实并不方便。</p><p>我们先把物体的旋转中心移平移回原点，然后旋转，最后平移回去。（因为我们只能做原点为旋转中心的旋转，不然就无法用之前的固定结论）。</p><p><strong>如果不以原点为旋转中心，以某个轴为旋转中心轴</strong></p><p>绕z轴旋转(本来二维的扩展成三维后等价绕z轴旋转)</p><ul><li>绕哪个轴，哪个轴的坐标为位置不变</li></ul><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518205820940.png" class title="image-20230518205820940"><p><strong>拓展到3d transformation也是一样</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518210227508.png" class title="image-20230518210227508"><p><strong>ps:</strong> 按照直觉可能会觉得绕y轴的旋转矩阵有问题，其实是因为该图表示的是右手坐标系的变换；已知<code>x.crossproduct(z) = -z.crossproduct(x)</code>(右手法则)，这里XxZ = -Y,所以需要对α取反。</p><p><strong>Rodrigues’s Rotation Formula</strong></p><p>描述了绕任意轴旋转任意角度的变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518213219770.png" class title="image-20230518213219770"><p>下面来推导一下这个公式同时引入四元数的学习</p><p>参考：<a href="https://www.zhihu.com/tardis/zm/art/78987582?source_id=1005">四元数和旋转(Quaternion &amp; rotation) (zhihu.com)</a></p><p>前提：axis n是一个单位向量，并且n过原点(如果不过原点，参考前面的方法先平移回原点)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230520235749777.png" class title="image-20230520235749777"><p><strong>有关四元数</strong></p><p>定义：</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230521000033200.png" class title="image-20230521000033200"><h2 id="MVP-Transformation（实际操作）"><a href="#MVP-Transformation（实际操作）" class="headerlink" title="MVP Transformation（实际操作）"></a>MVP Transformation（实际操作）</h2><p>拍照过程</p><ol><li>摆放好待拍摄的物品，或者人物。（model transformation)</li><li>调整好拍摄(相机)角度。(view transformation)</li><li>调整焦距,拍摄。(projection transformation)</li></ol><p>也就是常说的MVP变换</p><p><strong>这里Viewing Transformation包括了View Transformation(视图变换)和Projection Transformation(投影变换)</strong></p><h3 id="View-Camera-Transformation-视图变换"><a href="#View-Camera-Transformation-视图变换" class="headerlink" title="View/Camera Transformation(视图变换)"></a>View/Camera Transformation(视图变换)</h3><p>视图变换就是把相机放好。把相机移回原点，相机的三个向量分别和世界坐标的三个轴对齐。先平移后旋转</p><ul><li>平移回原点</li><li>旋转对齐轴</li></ul><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523214954945.png" class title="image-20230523214954945"><p>平移矩阵很好得到</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215056433.png" class title="image-20230523215056433"><p>然后是旋转矩阵</p><p>但是要想将相机三向量t,g,x转换到世界坐标轴XYZ(单位向量)上，其实不好算，所以这里反过来算</p><p>所以首先明确目标矩阵(1 0 0 0；0 1 0 0； 0 0 1 0； 0 0 0 1)，由于反过来算，所以变成了起始矩阵</p><p><strong>细节:</strong> g to -Z,相机对准Z的负方向，t to Y, gxt to X，x由g、t叉乘得到</p><p>R(view)的逆矩阵很好得到，毕竟（0，0，1）旋转到一个位置很好做</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215450184.png" class title="image-20230523215450184"><p>至此实现了从世界坐标轴到相机坐标轴的旋转，只要额外再取个逆，就能得到R(view)</p><h3 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h3><h4 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h4><p>正交投影假设物体和相机无限远，这样物体通过视锥体投影到相机没有近大远小</p><p>以下这张图解释了这个过程(<strong>先平移后缩放</strong>)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523221856008.png" class title="image-20230523221856008"><p><strong>注意：这里是右手系，相机往-z方向看</strong>，OpenGL就是右手坐标系。</p><p>但是unity 和 dx都是左手坐标系</p><p>再这样的前提下|f|要比|n|要小</p><p>由此得到正交变换的变换矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523222223893.png" class title="image-20230523222223893"><p>如何理解r,l,b,n,f,t这些东西，可以理解成物体左右上下前后的“坐标”，</p><p>平移矩阵好理解，缩放矩阵本质上是用【2/左右距离】作为缩放倍数，最后结果为2，使得物体缩放到【-1，1】的cube中。</p><p>至此正交投影结束</p><h4 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h4><p>视锥体原平面投影到近平面就能产生透视效果</p><p><strong>这里做透视投影的过程是，先将视锥体squish(挤)成cuboid(长方体）再做正交投影</strong></p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224143182.png" class title="image-20230523224143182"><p>由远近平面的关系，我们可以根据相似三角形得到比例关系</p><p><code>y&#39; = (n/z)y</code></p><p>首先明确我们的目标是将(x,y,z)变换到(x’,y’,z’)</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224929643.png" class title="image-20230523224929643"><p>进而在齐次坐标上是</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225031775.png" class title="image-20230523225031775"><p>从透视投影到正交投影的矩阵可以写成</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225322150.png" class title="image-20230523225322150"><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225545132.png" class title="image-20230523225545132"><p>这里我们要具体推导一下第三行的值</p><p>本质上就是用远近平面上的点带入，完成二元方程组，进而推导出第三行</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233910281.png" class title="image-20230523233910281"><p>最后合成透视矩阵</p><img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233933492.png" class title="image-20230523233933492"><p>推导结束</p><p>至此，坐标被变换到了Clip Space(裁剪空间)，也称作Projection Space(投影空间)</p><p>这块空间用于裁剪掉不需要的内容，使用视锥体（view frustum)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Transformation-变换&quot;&gt;&lt;a href=&quot;#Transformation-变换&quot; class=&quot;headerlink&quot; title=&quot;Transformation(变换)&quot;&gt;&lt;/a&gt;Transformation(变换)&lt;/h1&gt;&lt;h2 id=&quot;变换的</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始的图形学</title>
    <link href="https://aspect-ux.github.io/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%A6%82%E8%BF%B0/"/>
    <id>https://aspect-ux.github.io/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-17T15:21:24.887Z</published>
    <updated>2023-07-14T03:15:20.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于实在觉得有必要细致、全面、通透地学习一遍图形学相关基础理论知识，于是开了这个坑。</p><p>但是，就我个人而言，该系列不会局限单纯的理论。目前的想法是，除开基础理论推导</p><ul><li><p>会添加一些引擎中的原理和实现，games系列闫令琪老师101，202的作业，以及流行图形API规范如OpenGL的理论实践。</p></li><li><p>同时PBR,RTR等图形学进阶书籍阅读笔记也可能会不定期更新。</p></li></ul><p>总的来说，理论性会更强，实验性的记录和学习也会占相当一部分，包罗图形学及其相关应用。个人的意义算是这个方向的<strong>笔记或“个人百科全书”</strong>。后续也会不断完善。</p><h2 id="Overview-of-Computer-Graphics"><a href="#Overview-of-Computer-Graphics" class="headerlink" title="Overview of Computer Graphics"></a>Overview of Computer Graphics</h2><p>这里借games101开个头</p><h3 id="Why-Study-CG"><a href="#Why-Study-CG" class="headerlink" title="Why Study CG"></a>Why Study CG</h3><ul><li><p>Fundamental Intellectual Challenges: </p><ul><li>Creates and interacts with realistic virtual world(与虚拟交互)</li><li>Require understanding of all aspects of physical world(了解物理世界)</li><li>New computing methods,displays,technologies(新技术，方法)</li></ul></li><li><p>Technical Challenges:</p><ul><li>Math of(perspective) projections,curves,surfaces(数学)</li><li>Physics of lighting and shading(物理)</li><li>Representing / operating shapes in 3D(图形/3d)</li><li>Animation / simulation(动画/模拟)</li><li>3D graphics software programming and hardware(3d编程/硬件)</li></ul></li><li><p>Forget about the previous reason: <strong>Graphics is awesome!</strong></p></li></ul><p><strong>总而言之，图形学真的很有趣！！！</strong></p><h3 id="What-will-be-in-the-corner"><a href="#What-will-be-in-the-corner" class="headerlink" title="What will be in the corner"></a>What will be in the corner</h3><ul><li><p>Mathematics theories</p></li><li><p>Rasterization</p></li><li><p>Curves and Meshes</p></li><li><p>Ray Tracing</p><p>and so on…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于实</summary>
      
    
    
    
    <category term="计算机图形学" scheme="https://aspect-ux.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/"/>
    <id>https://aspect-ux.github.io/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/</id>
    <published>2022-12-01T15:42:33.960Z</published>
    <updated>2022-12-01T16:33:14.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Signal-Processing"><a href="#Signal-Processing" class="headerlink" title="Signal Processing"></a>Signal Processing</h1><p>在图形中，我们经常要处理具有连续变量的函数：一开始你只看到一张图像，但是随着你的探索，你将会看到更多。本质上，连续函数不能直接在电脑上表达，我们必须用优先的比特来表达他们。</p><p>最有用的方法之一是存储这个函数在不同点的值，然后在需要的时候进行重构。</p><p>你现在位置应该熟悉使用二维网格像素来表达图像，所以你已经见过一个采样的表现。</p><p>另一个关于sampled representation 的粒子是二维的数字化平板。</p><p>例如平板电脑，或者艺术家使用的数位屏。这种情况下，最原式的函数是数位笔的移动</p><p>（stylus数位笔触针手写笔)</p><p>…</p><h3 id="Digital-Audio-Sample-in-1d"><a href="#Digital-Audio-Sample-in-1d" class="headerlink" title="Digital Audio : Sample in 1d"></a>Digital Audio : Sample in 1d</h3><p>即使sampled representation 已经用于电子交流很久了，激光唱片（compact disc)在1982年的引入，紧随着音频数字记录器的使用增长，在过去的10年里，是第一个高度可视的消费者应用采样。</p><p>…</p><h3 id="Sampling-Artifacts-and-Aliasing"><a href="#Sampling-Artifacts-and-Aliasing" class="headerlink" title="Sampling Artifacts and Aliasing"></a>Sampling Artifacts and Aliasing</h3><p>数字音频记录可以为sampling 和reconstruction处理更加具体的模型。</p><p>Aliasing 展示了不管什么时候，采样重构失效导致人工结果是一个令人惊讶的频率</p><p>在音频中，走样以一种奇怪的声音和额外的声调–一个10Hz的bell ring,当采样到8Hz,就变成一个6Hzd的声调</p><p>在图像中，走样经常因为采样网格的interaction和图像中常规特点。以moire pattern的形式出现。</p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669910518267.png" class width="1669910518267"><h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><p>在我们讨论sampling和reconstruction算法之前，我们首先要检验它们基于的数学该奶奶</p><p>convolution卷积。</p><p>卷积是一个简单的数学概念，为算法作基础用来采样，过滤，重构。</p><p>同时它也是我们如何分析这些算法的基础。</p><p>卷积是一个function:它使用两个functions，然后将它们结合成一个新的function</p><p>这本书中，卷积运算符用一个*标记。f * g,f is convolved with g</p><p>卷积可以被用于连续方法或者离散的序列。</p><p>同时也可以被用于定义在1d,2d,3d或者更高维度.</p><p>为了定义方便，我们通常假设函数定义域区域无限。</p><p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/Website\Blog\source_posts\虎书\07\1669911797075.png" alt="1669911797075"></p><h3 id="Moving-Average"><a href="#Moving-Average" class="headerlink" title="Moving Average"></a>Moving Average</h3><p>为了得到一个基础的卷积图像。</p><p>思考：使用moving average来平滑一个函数。</p><p>为了在任意一个点得到平滑的值，我们需要计算函数超出范围拓展到每个方向，距离长度为r 的平均值。</p><p>距离r是平滑的radius，控制平滑度</p><p>我们用数学方法表示，如果平滑一个连续的函数g(x)，平均化（averaging)意味着在区间内对g进行求积分</p><p>（integrating)</p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669912247511.png" class width="1669912247511"><h3 id="Discrete-Convolution"><a href="#Discrete-Convolution" class="headerlink" title="Discrete Convolution"></a>Discrete Convolution</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Signal-Processing&quot;&gt;&lt;a href=&quot;#Signal-Processing&quot; class=&quot;headerlink&quot; title=&quot;Signal Processing&quot;&gt;&lt;/a&gt;Signal Processing&lt;/h1&gt;&lt;p&gt;在图形中，我们经常要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/12/01/naive/Games%E7%B3%BB%E5%88%97/101/Lecture03%20Transformation/"/>
    <id>https://aspect-ux.github.io/2022/12/01/naive/Games%E7%B3%BB%E5%88%97/101/Lecture03%20Transformation/</id>
    <published>2022-12-01T15:26:12.558Z</published>
    <updated>2022-12-01T15:42:22.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture03-Transformation"><a href="#Lecture03-Transformation" class="headerlink" title="Lecture03 Transformation"></a>Lecture03 Transformation</h1><h2 id="Last-Lecture"><a href="#Last-Lecture" class="headerlink" title="Last Lecture"></a>Last Lecture</h2><ul><li><p>Basic operations : addition, multiplication</p></li><li><p>Dot Product - Forward/backward  (dot product positive/negative)</p><p>如果点乘结果为正，则向前；否则向后</p></li><li><p>Cross Product - Left/right (cross product outward/inward)</p><p>如果叉乘结果指向外面，则为左；否则为右</p></li><li><p>Matrice</p></li></ul><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation?"></a>Why Transformation?</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture03-Transformation&quot;&gt;&lt;a href=&quot;#Lecture03-Transformation&quot; class=&quot;headerlink&quot; title=&quot;Lecture03 Transformation&quot;&gt;&lt;/a&gt;Lecture03 Tran</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Homework/homework1/"/>
    <id>https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Homework/homework1/</id>
    <published>2022-11-13T13:11:29.406Z</published>
    <updated>2022-11-13T13:11:29.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p>需要eigen和opencv</p><p>注意include( ),下载地址<a href="https://www.raoyunsoft.com/opencv/opencv-4.5.2/">Index of /opencv/opencv-4.5.2/ (raoyunsoft.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01&quot;&gt;&lt;a href=&quot;#01&quot; class=&quot;headerlink&quot; title=&quot;01&quot;&gt;&lt;/a&gt;01&lt;/h1&gt;&lt;p&gt;需要eigen和opencv&lt;/p&gt;
&lt;p&gt;注意include( ),下载地址&lt;a href=&quot;https://www.raoyunsoft</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Lecture01%20Overview%20of%20Computer%20Graphics/"/>
    <id>https://aspect-ux.github.io/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Lecture01%20Overview%20of%20Computer%20Graphics/</id>
    <published>2022-11-13T12:11:45.520Z</published>
    <updated>2022-11-13T12:12:40.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lecture01-Overview-of-Computer-Graphics"><a href="#Lecture01-Overview-of-Computer-Graphics" class="headerlink" title="Lecture01 Overview of Computer Graphics"></a>Lecture01 Overview of Computer Graphics</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lecture01-Overview-of-Computer-Graphics&quot;&gt;&lt;a href=&quot;#Lecture01-Overview-of-Computer-Graphics&quot; class=&quot;headerlink&quot; title=&quot;Lecture01 Over</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软链接c盘</title>
    <link href="https://aspect-ux.github.io/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/"/>
    <id>https://aspect-ux.github.io/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/</id>
    <published>2022-11-12T08:53:28.016Z</published>
    <updated>2022-11-15T13:05:34.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软链接c盘"><a href="#软链接c盘" class="headerlink" title="软链接c盘"></a>软链接c盘</h1><p>c盘文件链接到d盘，减小c盘占用<br>将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接<br>mklink /D “C:\Program Files\Adobe” “D:\MySoftware\Adobe”</p><h1 id="Unity-Cache"><a href="#Unity-Cache" class="headerlink" title="Unity Cache"></a>Unity Cache</h1><p>参考<a href="https://blog.csdn.net/baidu_39447417/article/details/117829765">(36条消息) 修改Unity的Cache缓存位置_GA博客的博客-CSDN博客_unity缓存</a></p><h1 id="SP字体太小"><a href="#SP字体太小" class="headerlink" title="SP字体太小"></a>SP字体太小</h1><p>QT_SCALE_FACTOR 1.3  用户变量</p><p>但是有副作用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软链接c盘&quot;&gt;&lt;a href=&quot;#软链接c盘&quot; class=&quot;headerlink&quot; title=&quot;软链接c盘&quot;&gt;&lt;/a&gt;软链接c盘&lt;/h1&gt;&lt;p&gt;c盘文件链接到d盘，减小c盘占用&lt;br&gt;将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接&lt;b</summary>
      
    
    
    
    <category term="随记" scheme="https://aspect-ux.github.io/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要12</title>
    <link href="https://aspect-ux.github.io/2022/11/10/UnityShader/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/"/>
    <id>https://aspect-ux.github.io/2022/11/10/UnityShader/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/</id>
    <published>2022-11-10T12:01:33.562Z</published>
    <updated>2022-11-10T12:02:24.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕后处理"><a href="#屏幕后处理" class="headerlink" title="屏幕后处理"></a>屏幕后处理</h1><p>顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。</p><p><code>onRenderImage</code>属于抓取屏幕的函数，应用在所有透明和不透明渲染完成后</p><h3 id="Unity中实现屏幕后处理"><a href="#Unity中实现屏幕后处理" class="headerlink" title="Unity中实现屏幕后处理"></a>Unity中实现屏幕后处理</h3><p><code>PostEffectsBase.cs </code>用于检验shader和material，并且通过脚本面板更改数据；如果不符合要求，则脚本失效.</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先注意</span></span><br><span class="line"><span class="comment">//unity 有三种模式，player mode,edit mode(正常模式)，prefab mode(进入预制体更改)</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResource</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;This platform does not support image effects or render texture....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 如果shader，material同时有效；如果shader有效。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;shader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;material&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有shader就直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material) <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整屏幕亮度、饱和度、对比度"><a href="#调整屏幕亮度、饱和度、对比度" class="headerlink" title="调整屏幕亮度、饱和度、对比度"></a>调整屏幕亮度、饱和度、对比度</h4><p><em>代码</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                //Apply Brightness</span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                //Apply Saturation</span><br><span class="line">                fixed luminance= 0.2125 * renderTex.r + 0 . 7154 * renderTex . g + 0.0721 * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation); //饱和度是色彩的鲜艳程度或纯度</span><br><span class="line">                </span><br><span class="line">                //Apply Contrast</span><br><span class="line">                fixed3 avgColor = fixed3(0.5,0.5,0.5);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast);</span><br><span class="line">                </span><br><span class="line">                return fixed4(finalColor,renderTex.a);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>1.直接相乘得到亮度</p><p>2.计算亮度值luminance;</p><p>3.使用饱和度在上一步颜色和亮度值之间插值</p><p>4.对比度类似。</p><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>利用边缘检测算子对图像进行<strong>卷积</strong></p><p>如果我们想要对图像进行均值模糊，可以使用一个 3x3 的卷积核，核内每个元素的值均为 1/9。</p><p>见P249</p><p>在进行边缘检测时，我们需要对每个像素进行卷积计算，有两个方向的梯度。</p><p>整体梯度公式为<br>$$<br>G = sqrt(Gx^2 + Gy^2)<br>$$<br>出于性能考虑，一般也用绝对值取代开根号。</p><p><strong>使用Sobel算子实现描边</strong></p><p><strong>顶点着色器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.uv;</span><br><span class="line">                </span><br><span class="line">                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);</span><br><span class="line">o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);</span><br><span class="line">o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);</span><br><span class="line">o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);</span><br><span class="line">o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);</span><br><span class="line">o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);</span><br><span class="line">o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);</span><br><span class="line">o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);</span><br><span class="line">o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>使用Sobel算子采样，并且将采样代码转到顶点着色器，减少运算。并且由于顶点到片元的插值是线性的，所以并不会影响结果。</p><p><strong>edge计算</strong></p><p>计算9块像素的亮度，并且将水平和竖直方向的对应梯度和计算出来。最后1减去两者绝对值。</p><p><em>得到的edge越小，越有可能是边缘</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line">        const half Gx[9] = &#123;-1,  0,  1,</span><br><span class="line">        -2,  0,  2,</span><br><span class="line">        -1,  0,  1&#125;;</span><br><span class="line">        const half Gy[9] = &#123;-1, -2, -1,</span><br><span class="line">        0,  0,  0,</span><br><span class="line">        1,  2,  1&#125;;</span><br><span class="line">        half texColor;</span><br><span class="line">        half edgeX = 0;</span><br><span class="line">        half edgeY = 0;</span><br><span class="line">        for (int it = 0; it &lt; 9; it++) &#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"></span><br><span class="line">        return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>片元着色器</strong></p><p>利用Sobel得到梯度值edge后，分别计算贴图和纯色背景下的颜色值。</p><p>最后利用<code>_EdgeOnly</code>在两者之间取值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><p>卷积的另一个应用是高斯模糊</p><p>见P253</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line"><span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render the vertical pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render the horizontal pass</span></span><br><span class="line">Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">buffer0 = buffer1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graphics.Blit(buffer0, dest);</span><br><span class="line">RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Graphics.Blit(src, dest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情见P257</p><p>使用五个高斯核</p><p><strong>注：</strong>使用<code>CGINCLUDE</code>可以将顶点片元着色器包住，达到多个pass使用同一份着色器代码及其声明。</p><p>没看懂…….</p><h4 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a>Bloom效果</h4><p>根据某个阈值提取出画面中较亮的区域，然后通过高斯模糊，模拟光线扩散的结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;屏幕后处理&quot;&gt;&lt;a href=&quot;#屏幕后处理&quot; class=&quot;headerlink&quot; title=&quot;屏幕后处理&quot;&gt;&lt;/a&gt;屏幕后处理&lt;/h1&gt;&lt;p&gt;顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onRenderIm</summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Games101 Material_01</title>
    <link href="https://aspect-ux.github.io/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/"/>
    <id>https://aspect-ux.github.io/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/</id>
    <published>2022-11-10T11:42:22.996Z</published>
    <updated>2022-11-10T12:05:07.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><h2 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse/Lambertian Material"></a>Diffuse/Lambertian Material</h2><p>对半球costheta积分结果是PI</p><p>关于这个证明</p><img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668081297856.png" class title="uTools_1668081297856"><p>半球上的立体角定义为覆盖半球表面区域的面积初一半径的平方</p><img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668080586079.png" class title="uTools_1668080586079">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Material&quot;&gt;&lt;a href=&quot;#Material&quot; class=&quot;headerlink&quot; title=&quot;Material&quot;&gt;&lt;/a&gt;Material&lt;/h1&gt;&lt;h2 id=&quot;Diffuse-Lambertian-Material&quot;&gt;&lt;a href=&quot;#Di</summary>
      
    
    
    
    <category term="Games101" scheme="https://aspect-ux.github.io/categories/Games101/"/>
    
    
  </entry>
  
  <entry>
    <title>unityshader精要11</title>
    <link href="https://aspect-ux.github.io/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/"/>
    <id>https://aspect-ux.github.io/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/</id>
    <published>2022-11-09T14:04:17.719Z</published>
    <updated>2023-05-16T14:24:26.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter11-让画面动起来"><a href="#Chapter11-让画面动起来" class="headerlink" title="Chapter11-让画面动起来"></a>Chapter11-让画面动起来</h2><h3 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h3><p>1.序列帧动画</p><p>….</p><p>2.滚动背景</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//frac函数返回标量或每个矢量中各分量的小数部分。return v - floor(v);</span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex) + frac(float2(_ScrollX,0.0)*_Time.y);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord,_DetailTex) + frac(float2(_Scroll2X,0.0)*_Time.y);</span><br><span class="line">//可以发现当x乘上一个小于1的值时，系数越小，呈现的图像结果会越稀疏</span><br></pre></td></tr></table></figure><p>函数如下图</p><img src="/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661861601610.png" class title="uTools_1661861601610"><p>frac(float)等价上图</p><p>frac(float2())则等价于以圆心为原点，以这个点为起点的线为半径，每过v的长度，为一个周期。最后构成多重圆环。而横坐标</p><p>的倍率则影响密度。倍率大于1，噪声越大，间隔小，密度大。</p><p><font color="red">如果渲染2d物体，可以将相机模式转换成正交模式</font></p><p>3.水波动画</p><p>由于本例中需要移动模型空间坐标，而批处理会使得相关模型合并，使得相关模型丢失原来模型空间；所以一般有顶点移动anime的shader要考虑关闭batch;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123;</span><br><span class="line">    &quot;RenderType&quot;=&quot;Transparent&quot;,</span><br><span class="line">    &quot;IgnoreProjector&quot; = &quot;True&quot;,</span><br><span class="line">    &quot;RenderType&quot; = &quot;Transparent&quot;,</span><br><span class="line">    &quot;DisableBatching&quot; = &quot;True&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如何形成水波？顶点着色器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 offset;</span><br><span class="line">offset.yzw = float3(0.0,0.0,0.0);</span><br><span class="line">offset.x = sin(_Frequency * _Time.y +v.vertex.x * _InWaveLength + v.vertex.y *</span><br><span class="line">_InWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line">o.pos = mul(UNITY_MATRIX_MVP,v.vertex + offset);</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); //将纹理进行uv映射</span><br><span class="line">o.uv += float2(0.0,_Time.y * Speed);      //将uv的v根据时间变化进行增长</span><br></pre></td></tr></table></figure><p>等价于<br>$$<br>x = Magnitude * sin(_Frequency * t+w * vertex)<br>$$<br>由此使得水波水平变化。</p><p>同时还用了纹理动画，产生水平的纹理动画。</p><p>4.广告牌技术</p><p>效果：星星始终面朝摄像机，向上的位置并未改变，当y轴转动，也会跟着转动</p><p><em>代码</em></p><p>1.获取模型空间的中心和相机点</p><p>2.将法线设为从中心点指向相机的方向</p><p>3.将法线y方向乘以_VerticalBillboarding，并归一化</p><p>4.一般来说，法线并不等于up向量，up向量为（0，1，0）,但是随着视点的转变，法线也会变，如果法线等于up，</p><p>​    那么后续叉乘的结果会出错。此时up会变成向前的向量。</p><p>5.然后是right向量，由前两个向量叉乘得到，需要归一化，至此三个正基向量得到。</p><p>6.<code>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</code></p><p>​    最后实现顶点坐标在模型空间，三个分量不同程度的形变，</p><p>​    <strong>结果是：</strong><font color="red">错误</font>_VerticalBillboarding=1，星星就像是跟踪屏幕；</p><p>​    _VerticalBillboarding= 0星星固定，有透视效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//顶点动画都是在模型空间变换</span><br><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">//1.</span><br><span class="line">float3 center = float3(0, 0, 0);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));</span><br><span class="line"></span><br><span class="line">//2.</span><br><span class="line">float3 normalDir = viewer - center;</span><br><span class="line"></span><br><span class="line">//3.</span><br><span class="line">// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span><br><span class="line">// Which means the normal dir is fixed</span><br><span class="line">// Or if _VerticalBillboarding equals 0, the y of normal is 0</span><br><span class="line">// Which means the up dir is fixed</span><br><span class="line">normalDir.y =normalDir.y * _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line">//4.</span><br><span class="line">// Get the approximate up dir</span><br><span class="line">// If normal dir is already towards up, then the up dir is towards front</span><br><span class="line">float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">// Use the three vectors to rotate the quad</span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">             </span><br><span class="line">o.pos = UnityObjectToClipPos(float4(localPos, 1));</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661943292280.png" class title="uTools_1661943292280">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter11-让画面动起来&quot;&gt;&lt;a href=&quot;#Chapter11-让画面动起来&quot; class=&quot;headerlink&quot; title=&quot;Chapter11-让画面动起来&quot;&gt;&lt;/a&gt;Chapter11-让画面动起来&lt;/h2&gt;&lt;h3 id=&quot;纹理动画&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="unity shader" scheme="https://aspect-ux.github.io/categories/unity-shader/"/>
    
    
    <category term="shader动画" scheme="https://aspect-ux.github.io/tags/shader%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
