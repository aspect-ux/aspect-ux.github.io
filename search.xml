<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2022/10/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建静态网页</title>
    <url>/2022/10/21/buildWebsiteBasedonGithub/</url>
    <content><![CDATA[<h1 id="搭建静态网页"><a href="#搭建静态网页" class="headerlink" title="搭建静态网页"></a>搭建静态网页</h1><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><ul>
<li><p>创建仓库,命名为<code>aspect-ux.github.io</code>,找到Pages,发现site 是显示了。</p>
</li>
<li><p>安装node.js 参考<a href="https://blog.csdn.net/chanyeolchichi/article/details/121348541">(26条消息) Node.js详细安装教程（2021）_cheerileeyoki的博客-CSDN博客_node安装教程</a></p>
</li>
<li><p>安装hexo,报错有可能是权限，删去c盘下的.npmrc???</p>
<p>大抵是nodejs版本太高了</p>
<p>主要参考<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?from=search&seid=6808372371406518307&vd_source=2b3a7e4dffb44c07076538fe075cb1cf">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>
</li>
<li><p>配置<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> 		<span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">		<span class="attr">repo:</span> <span class="string">https://github.com/aspect-ux/aspect-ux.github.io.git</span></span><br><span class="line"> 		<span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后</p>
<ul>
<li><p>更改主题git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia </p>
<p>更改yml文件</p>
<p>主题配置参照：<a href="https://blog.csdn.net/wugenqiang/article/details/88373990">(26条消息) 使用 Github 空间搭建 Hexo 技术博客——使用NexT优化博客（五）_WuGenQiang的博客-CSDN博客</a></p>
</li>
</ul>
<p>hexo c<br>hexo g<br>hexo d</p>
<ul>
<li><p>值得注意的是，传统的markdown语法无法显示图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: false` 修改为 `post_asset_folder: true</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>最后需要新建与文章同名的文件夹存放图片</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要1</title>
    <url>/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/</url>
    <content><![CDATA[<h3 id="Unity-Shader01"><a href="#Unity-Shader01" class="headerlink" title="Unity Shader01"></a>Unity Shader01</h3><h4 id="什么是渲染流水线？"><a href="#什么是渲染流水线？" class="headerlink" title="什么是渲染流水线？"></a>什么是渲染流水线？</h4><p>流水线的概念早已学过，那么渲染流水线又是什么。首先要区别于GPU（硬件)流水线。</p>
<p>分为三个概念上的阶段，每个阶段又有子流水线。</p>
<p>应用阶段：开发者支配的阶段，输入场景、贴图、摄像机、光源等等；输出点、线、三角面等渲染图元。</p>
<p>几何阶段（geometry): 这个阶段主要决定渲染哪些图元，以及将这些图元映射到二维平面上，包括着色，深度值，坐标。</p>
<p>光栅化阶段（rasterization): 这个阶段同上一个阶段都是在GPU上进行，利用上一阶段的数据绘制出像素。先是逐顶点处理，然后是像素处理。</p>
<h4 id="CPU与GPU之间"><a href="#CPU与GPU之间" class="headerlink" title="CPU与GPU之间"></a>CPU与GPU之间</h4><p>CPU控制数据从HDD(硬盘)中加载到显卡的显存（VRAM)中，数据包括位置、顶点着色、法线方向等。</p>
<p>指定渲染状态，例如使用哪个顶点/片元着色器，使用哪个光源属性、材质。</p>
<p>准备好后CPU发起Draw Call命令，GPU开始渲染。</p>
<p>对应上面三个阶段。</p>
<h4 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h4><p>已知几何与光栅化阶段在GPU上进行。</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712135412678.png" alt="image-20220712135412678"></p>
<p>—-几何阶段</p>
<p><strong>顶点着色器（Vertex Shader)</strong> 负责顶点几何变换和顶点着色</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712141429317.png" alt="image-20220712141429317"></p>
<p>曲面细分、几何着色器均为可选着色器，分别用来细分图元和产生图元（增加）。</p>
<p><strong>裁剪</strong></p>
<p>位置分为完全在相机内，部分在相机内，完全不在相机内</p>
<p>裁剪用来处理部分在相机内的部分，将与相机交点替代相机外的部分。</p>
<p>需要注意的是顶点着色器是可编程的，但裁剪却是不可编程的，是硬件上的固定操作。</p>
<p><strong>屏幕映射</strong></p>
<p>输入三维坐标，映射二维，z不做处理</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712142739290.png" alt="image-20220712142739290"></p>
<p>——光栅化阶段</p>
<p>三角形设置</p>
<p>已知顶点着色器不会记录点与点之间的关系</p>
<p>该过程用来得到三角形边界表达方式，计算像素覆盖情况。</p>
<p><strong>三角形遍历</strong></p>
<p>（Triangle Traversal)</p>
<p>找到覆盖的像素，生成片元。</p>
<p>一个片元并不是真正意义上的像素，而是包含了很多状态的集合 这些状态用于计算每个像素的最终颜色</p>
<p>对三个顶点进行插值，然后三角形内部颜色由三点渐变(gradient)混合而成。</p>
<p><strong>片元着色器</strong></p>
<p>DX中又称为像素着色器（Pixel Shader),不过片元不是真正意义上的像素</p>
<p>可编程</p>
<p>纹理采样，对三个顶点插值后，就可以得到片元的纹理坐标，仅可以影响单个片元，无法传递给邻居</p>
<p><strong>逐片元操作</strong></p>
<p>为OpenGL的说法，DX</p>
<p>具体较复杂</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712145900074.png" alt="image-20220712145900074"></p>
<p>片元着色器执行后，进行模板测试，再开始深度测试</p>
<p>深度测试在坐标屏幕进行，屏幕空间坐标与glViewport所定义的视口大小相关</p>
<p>可用glFragCoord(x,y,z)访问屏幕坐标，z为深度值</p>
<p>现代GPU硬件特性，深度测试可以在片着之前，但是不能同时。</p>
<p>参照<a href="https://zhuanlan.zhihu.com/p/371245442">深度测试 - 知乎 (zhihu.com)</a></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>OpenGL、DX是CPU和GPU之间的桥梁，图形接口（api)</p>
<p>显卡中除了图形处理单元GPU,还有显存(VRAM)。</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要2</title>
    <url>/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/</url>
    <content><![CDATA[<h3 id="Unity-Shader-精要02"><a href="#Unity-Shader-精要02" class="headerlink" title="Unity Shader 精要02"></a>Unity Shader 精要02</h3><h4 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader?"></a>什么是Shader?</h4><p>Shader 翻译为着色器，GPU流水线中对于高度可编程的阶段来说，Shader是可以在GPU上运行的渲染代码；而对于固定流水线来说，</p>
<p>则起着渲染设置的作用。前者有顶点着色器，片元着色器等。</p>
<p>顶点着色器负责顶点变换和数据传递、顶点着色等，片元着色器负责渲染片元（几何处理后的像素）</p>
<p>首先搞清楚Shader的语言，分为GLSL,HLSL和Cg;</p>
<p>Unity Shader 则是在Unity上的实现手段，是一种与渲染打交道的抽象，而与之对应的则是ShaderLab语言</p>
<h4 id="Shader基础"><a href="#Shader基础" class="headerlink" title="Shader基础"></a>Shader基础</h4><p>Untiy 主要有Standard Surface Shader, Unlit Shader, Image Effect Shader 以及 Compute Shader。</p>
<p><strong>Unity Shader基本结构</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;ShaderName&quot;</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡A</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡B</span></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Properties 声明</strong></p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713074058424.png" alt="image-20220713074058424"></p>
<p>Properties 语义块的作用仅仅是为了让这些属性可以出现在材质面板中。</p>
<p><strong>SubShader</strong></p>
<p>Tags可以进行设置</p>
<p><code>Tags&#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;</code>  设置渲染顺序</p>
<p><strong>Pass</strong></p>
<p>设置渲染状态</p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713090702796.png" alt="image-20220713090702796"></p>
<p>首先Pass的命名<code>Name&quot;MyPassName&quot;</code></p>
<p>调用其他Unity Shader中的Pass <code>UsePass &quot;MyShader/MyPassName&quot;</code></p>
<p>Pass中的Tags与SubShader中的不一样</p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713091457211.png" alt="image-20220713091457211"></p>
<p>有关FallBack</p>
<p>FallBack “name”如果都没用，就用这个sub shader</p>
<p>FallBack off 关闭，不管了</p>
<p>FallBack “VertexLit” 调用内置的Shader中的Pass</p>
<p><strong>结构</strong></p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713092133474.png" alt="image-20220713092133474"></p>
<h4 id="各种着色器"><a href="#各种着色器" class="headerlink" title="各种着色器"></a>各种着色器</h4><p><strong>表面着色器</strong></p>
<p>(Surface Shader)</p>
<p>可以理解为顶点、片元着色器的进一步抽象，Unity中的Shader代码一般如上图所示。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Simple Surface Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">        <span class="keyword">struct</span> Input&#123;</span><br><span class="line">            float4 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顶点/片元着色器</strong></p>
<p>（Vertex/Fragment Shader)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Simple VertexFragment Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">    </span><br><span class="line">        CGPROGRAM <span class="comment">//用来包裹ShaderLab语言</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">float4 <span class="title">vert</span>(<span class="params">float4 v : POSITION</span>) :SV_POSITION</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">float4 <span class="title">frag</span>() : SV_Target</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>固定函数着色器落后不讨论</p>
<p>从本质上来讲，Unity Shader只包含后两种</p>
<p>表面着色器中SubShader的CG代码会被Unity细分到Pass</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要3</title>
    <url>/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/</url>
    <content><![CDATA[<h3 id="Unity-Shader03"><a href="#Unity-Shader03" class="headerlink" title="Unity Shader03"></a>Unity Shader03</h3><h4 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h4><h4 id="顶点的坐标空间变换"><a href="#顶点的坐标空间变换" class="headerlink" title="顶点的坐标空间变换"></a>顶点的坐标空间变换</h4><p><strong>模型空间</strong></p>
<p>指的是模型物体前、上、右</p>
<p><strong>裁剪空间</strong></p>
<p>视锥体有六面，称为裁剪平面</p>
<p>其中又有两个平面特殊，分别为靠近摄像机的近裁剪平面和远离摄像机的远裁剪平面。</p>
<p>透视中视锥体呈金字塔状，正交中呈长方体</p>
<p>已知处于几何处理的阶段</p>
<p>现进行投影矩阵</p>
<p><img src="/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/image-20220713173712165.png" alt="image-20220713173712165"></p>
<p><strong>总结</strong></p>
<p>从模型空间到世界空间，再到观察空间，然后裁剪空间，最后屏幕映射到屏幕空间。需要许多变换矩阵。</p>
<p><img src="/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/image-20220714095415512.png" alt="image-20220714095415512"></p>
<p><code>float4 a = float4(1.0,1.0,1.0,1.0);</code>该变量是矩阵还是矢量取决于运算种类和位置。</p>
<p>点积（dot)</p>
<p>矩阵乘法(mul)</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要4</title>
    <url>/2022/10/26/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8104/</url>
    <content><![CDATA[<h3 id="Unity-Shader04"><a href="#Unity-Shader04" class="headerlink" title="Unity Shader04"></a>Unity Shader04</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chaper5/Simple Shader&quot;</span> &#123; </span><br><span class="line">    SubShader &#123; </span><br><span class="line">    Pass &#123; <span class="comment">//自定义渲染设置</span></span><br><span class="line">        CGPROGR</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert </span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line">        <span class="function">float4 <span class="title">vert</span>(<span class="params">float4 v: POSITION</span>) : SV POSITION</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> mul (UNITY MATRIX MVP, v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function">fixed4 <span class="title">frag</span>() : SV_Target</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(<span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器中</li>
</ul>
<p>POSITION和SV_POSITION是CG/HLSL中的语义（semantic)不可省略。</p>
<p>POSITION告诉Unity将模型的坐标作为输入参数输入到v中。</p>
<p>而SV_POSITION则告诉Unity返回裁剪坐标。</p>
<p>片元着色器中</p>
<p>SV_TARGET也是一个语义，告诉系统将渲染输出存储到渲染目标，默认输出到帧缓存。（1，1，1）表示白色，这里返回了白色。</p>
<p>结构体</p>
<p>用来定义着色器的输入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> a2v&#123;   <span class="comment">//a2v意思是将应用阶段数据传到顶点着色器</span></span><br><span class="line">    <span class="comment">//用模型坐标填充</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    <span class="comment">//用法线方向填充</span></span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    <span class="comment">//TEXCOORD0告诉系统用第一条纹理坐标填充</span></span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unity <strong>支持的语义有：</strong> POSITION, TANGENT, NORMAL, TEXCOORDO, TEXCOORDJ, TEXCOORD2, TEXCOORD3, COLOR 等。</p>
<p><code>struct StructName&#123;TypeName name : Semantic;&#125;;</code></p>
<h4 id="顶点与片元着色器通信"><a href="#顶点与片元着色器通信" class="headerlink" title="顶点与片元着色器通信"></a>顶点与片元着色器通信</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f&#123; <span class="comment">//从顶点着色器到片元</span></span><br><span class="line">    <span class="comment">//pos中包含了裁剪空间的位置信息</span></span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    <span class="comment">//COLOR0用来存储颜色信息</span></span><br><span class="line">    float3 color : COLOR0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为完整代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Simple Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			<span class="comment">//将模型坐标输入到顶点着色器</span></span><br><span class="line">            <span class="keyword">struct</span> a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">			<span class="comment">//将顶点数据输出到片元</span></span><br><span class="line">            <span class="keyword">struct</span> v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//顶点着色器，逐顶点调用</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span>+fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//逐片元调用</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">	_Color(<span class="string">&quot;Color Tint&quot;</span>,Color) = (<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意的是，在CG代码中需要定义出名称类型都一致的变量</span></span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">    Pass&#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别ShaderLab和CG的变量</p>
<p><img src="/2022/10/26/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8104/image-20220714112206997.png" alt="image-20220714112206997"></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>已知真正的Shader不是简单的一个<code>.shader</code>文件。</p>
<p>UnityShader 的方便性使得不用开发者自己转换法线方向，处理光照阴影等。</p>
<p>类似于C++的头文件,写在CG中，根据情况下载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ENGCG</span><br></pre></td></tr></table></figure>

<h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>ColorPicker.cs绑定摄像机，获取屏幕RGB值</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>有关CG/HLSL的语义，可参照微软DX文档</p>
<p>语义主要是用来限定输入输出的字符串，决定输入输出来源去向，方式等。</p>
<p>SV（system value semantics)</p>
<p>定义复杂变量类型时，需要注意，一个语义，寄存器只能存储4个浮点数，所以可以采取分成4个变量表示一个矩阵</p>
<p>shader中不要除以0</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 01</title>
    <url>/2022/10/27/%E8%99%8E%E4%B9%A6/01/</url>
    <content><![CDATA[<h1 id="Computer-Graphics-01"><a href="#Computer-Graphics-01" class="headerlink" title="Computer Graphics 01"></a>Computer Graphics 01</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p><code>However, for the foreseeable future, a good heuristic is that programmers</code></p>
<p><code>should pay more attention to memory access patterns than to operation counts.</code></p>
<p>因为内存的速度跟不上处理器的速度</p>
<h2 id="Miscellaneous-Math"><a href="#Miscellaneous-Math" class="headerlink" title="Miscellaneous Math"></a>Miscellaneous Math</h2><p>2.1 集合和映射</p>
<p>2.2 解决二次等式</p>
<p>2.3 三角学（trigonometry) 勾股，三角函数，角</p>
<p>…</p>
<p>2.4.4 叉乘（cross product)</p>
<p><strong>a</strong> x <strong>b</strong> = |ab| sin (theta)</p>
<p>…</p>
<h4 id="Curve-and-Surface"><a href="#Curve-and-Surface" class="headerlink" title="Curve and Surface"></a>Curve and Surface</h4><p>从1d 到3d的积分，参数方程</p>
<h4 id="Linear-Interpolation"><a href="#Linear-Interpolation" class="headerlink" title="Linear Interpolation"></a>Linear Interpolation</h4><p><code>p = (1 - t)a + tb</code></p>
<p>barycentric 重心坐标</p>
<p>cardinality 集合基数</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要5</title>
    <url>/2022/10/27/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8105/</url>
    <content><![CDATA[<h3 id="UnityShader-05"><a href="#UnityShader-05" class="headerlink" title="UnityShader 05"></a>UnityShader 05</h3><h4 id="Unity中的基本光照"><a href="#Unity中的基本光照" class="headerlink" title="Unity中的基本光照"></a>Unity中的基本光照</h4><p>光线是如何产生的，光源发射光，一些物体与光交互，吸收一些光，散射一些光，而摄像机吸收一些光，形成了图像。</p>
<p>在光学中，使用<strong>辐照度</strong>（irradiance)来量化光。</p>
<p>那么如何计算辐照度呢？</p>
<p>辐照度与照射到物体表面光线之间的距离<code>d/cosx</code>成反比。</p>
<p>当光垂直下落<code>cosx=1</code>,那么距离为d</p>
<p>当光与竖直方向呈x度角，距离为<code>d/cosx</code></p>
<p>其中x可以由表面法线n和光源方向l的点积得到。</p>
<h5 id="散射与吸收"><a href="#散射与吸收" class="headerlink" title="散射与吸收"></a>散射与吸收</h5><p>散射（scatering)只改变光线方向，不改变光线的密度和颜色。散射的光线一般有两种方向，一种是向物体内部折射（refraction)或透射（transmission);另一种是反射（reflection)到外部。</p>
<p>为了区分两种散射，用<strong>高光反射</strong>（specular)和<strong>漫反射</strong>（diffuse)分别表示物体如何反射以及计算多少光线折射、吸收(absorption)、反射出表面。</p>
<p>根据光线的入射方向和入射量可以得到出射度（exitance)</p>
<h5 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h5><p>根据一系列的信息得到计算出射度的等式，也即光照模型。（lighting model )</p>
<h5 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h5><ul>
<li><p>自发光（emissive) 光线直接由光源进入摄像机，直接用材质的自发光颜色。</p>
</li>
<li><p>高光反射（specular)</p>
</li>
<li><p>漫反射（diffuse)</p>
<p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间角的余弦值 成正比。因此， 漫反射部分的计算如下</p>
<p><img src="/2022/10/27/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8105/image-20220715170258041.png" alt="image-20220715170258041"></p>
<p>c light 和 m diffuse 分别表示光源颜色和漫反射颜色</p>
</li>
<li><p>环境光（ambient) 一般是全局变量</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要6</title>
    <url>/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/</url>
    <content><![CDATA[<h2 id="Chapter6-Diffuse"><a href="#Chapter6-Diffuse" class="headerlink" title="Chapter6_Diffuse"></a>Chapter6_Diffuse</h2><h3 id="逐顶点计算漫反射"><a href="#逐顶点计算漫反射" class="headerlink" title="逐顶点计算漫反射"></a>逐顶点计算漫反射</h3><p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间</p>
<p>角的余弦值 。因此， 漫反射部分的计算如下</p>
<p>c_diffuse=( light * m_diffuse) max( n . I ) </p>
<p>中， n是表面法线,I 是指向光源的单位矢量 ,m_diffuse 是材质的漫反射颜色 ,light 是光源颜色。</p>
<p>需要注意的是 我们需要防止法线和光源方向点乘的结果为负值，为此 我们使用取最大值的函数来将其截取到 o, 这可以防止物体被从后面来的光源照亮。</p>
<p><em>以下为具体代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顶点着色器代码</span><br><span class="line">          v2f vert(a2v v)&#123;</span><br><span class="line">              v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">              //将顶点信息从模型空间传递到投影空间</span><br><span class="line">              o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line"></span><br><span class="line">              //获取环境光</span><br><span class="line">              fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">              //将法线从模型空间传递到世界空间,</span><br><span class="line">              fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line"></span><br><span class="line">              //获取世界空间的光照方向</span><br><span class="line">              fixed3 worldLight = normalizze(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line"></span><br><span class="line">              //计算漫反射  saturate：饱和,用于将数据截取到【0，1】之间</span><br><span class="line">              fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line">              o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">              return o;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>详情见P128.</p>
<p>矩阵变换见P86</p>
<p>要注意，非统一缩放，<strong>经计算得知</strong>会导致，法线不再垂直，所以不能用M(A-B)矩阵</p>
<p>需要用变换矩阵的<em>逆转置矩阵</em></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>1.进行漫反射计算，需要法线，光照，但是需要两者在同一空间下，这里是世界空间，并且法线变换不同于顶点变换</p>
<p><em>法线变换mv方法</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//右乘mv逆矩阵</span><br><span class="line">fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line">//因为左乘逆转置矩阵，</span><br><span class="line">//it为逆转置，其实对于正交来说，等于原来变换矩阵，但不是正交矩阵，会出现上述法线问题</span><br></pre></td></tr></table></figure>

<p>2.一个矩阵可以左乘达成mv变换，那么它的逆矩阵就可以达成vm变换；逆=换方向，转=换位置</p>
<p><img src="/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660737217984.png" alt="uTools_1660737217984"></p>
<h3 id="逐像素计算漫反射"><a href="#逐像素计算漫反射" class="headerlink" title="逐像素计算漫反射"></a>逐像素计算漫反射</h3><p>类似于顶点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Books/Chapter6/Pixel_Level&quot;&#123;</span><br><span class="line">     Properties&#123;</span><br><span class="line">        //初始化Color属性,得到并控制漫反射颜色,设置为白色</span><br><span class="line">        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        // Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        //顶点片元着色器代码要写在pass通道中</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //正确定义lightmode才可以得到unity内置光照变量，该Tag用于定义pass的角色</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">            //获取properties中的变量</span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            //定义顶点着色器的输入输出结构体,同时输出也是片元的输入</span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal :NORMAL;  //将模型顶点法线信息保存</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0;  //将光照颜色传递给片元着色器，也可以用 XCOORDO 语义。</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //顶点着色器代码,由于顶点着色器不参加计算，只要获取到坐标和世界法线</span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">                //将顶点信息从模型空间传递到投影空间</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                // //获取环境光</span><br><span class="line">                // fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                //将法线从模型空间传递到世界空间</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line">                // //获取世界空间的光照方向</span><br><span class="line">                // fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line">                // //计算漫反射  saturate：饱和</span><br><span class="line">                // fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line">                // o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //逐像素计算</span><br><span class="line">            fixed4 frag(v2f i) :SV_TARGET&#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                //法线</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //获取光照方向</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                return fixed4(color,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果全黑</p>
<p><img src="/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660751437397.png" alt="uTools_1660751437397"></p>
<p>在片元着色器计算结果更加平滑，但是光照不到的地方全黑；</p>
<p>全黑可以通过添加环境光</p>
<p>但是背光区却和向光区明暗一致，这时可以用<strong>半兰伯特模型</strong></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 02</title>
    <url>/2022/10/28/%E8%99%8E%E4%B9%A6/02/</url>
    <content><![CDATA[<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="Raster-Images"><a href="#Raster-Images" class="headerlink" title="Raster Images"></a>Raster Images</h2><ul>
<li><p>光栅以矩形像素数组的形式展示图片</p>
</li>
<li><p>光栅在需要图片的输入设备中也很流行。电子相机包含一个图片传感器，这个传感器由一个光敏像素网格组成。每个像素记录颜色和照在上面的光强。</p>
</li>
<li><p>光栅图片常用于存储和处理图片。光栅图片是一个简单的二维数组，存储每个像素的像素值。</p>
</li>
<li><p>除了光栅图片，还有vector image 用于存储描述形状，颜色范围，存储直线和曲线。</p>
</li>
</ul>
<p><strong>以下讨论raster image的基础和展示，特别关注于标准显示的非线性。其中像素值如何关联光强将会是很重要的</strong></p>
<h2 id="Raster-Device"><a href="#Raster-Device" class="headerlink" title="Raster Device"></a>Raster Device</h2><p>当今的显示器，包括电视，数字电影投影仪和电脑的显示器和投影仪一样，几乎都是基于固定像素数组。</p>
<p>他们可以被分为<strong>放射显示器</strong>（利用像素直接放射可控量的光）</p>
<p>和<strong>透射显示器</strong>（自己不发光，但是其他光源能够透过），需要一个lamp照射到screen上</p>
<h2 id="Images-Pixels-and-Geometry"><a href="#Images-Pixels-and-Geometry" class="headerlink" title="Images,Pixels,and Geometry"></a>Images,Pixels,and Geometry</h2><p><strong>首先我们要知道gamma校正</strong>，见本文末“补充”</p>
<p>然后</p>
<p>设定一个处于黑和白中间的强度 <code>0.5 = a ^ gamma</code></p>
<p>1.一个黑像素与白像素像交替的图片</p>
<p>2.一张灰色像素的图片</p>
<p>如果你是近视的，从远处看，这两张图会差不多</p>
<p>=&gt;根据这个道理</p>
<p>我们可以得到<code>a‘ = a^(1/gamma)</code></p>
<p>其中a为输入值，a’是输出值，由于有8bits的存储量</p>
<p>=&gt;a可能的值为{0/255，1/255，…,255/255} ^ gamma</p>
<h2 id="RGB-Color"><a href="#RGB-Color" class="headerlink" title="RGB Color"></a>RGB Color</h2><p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/image-20221028231837391.png" alt="image-20221028231837391"></p>
<p>大部分计算机图像都是用rgb来定义颜色</p>
<p>颜色叠加公式</p>
<p>详情见P75</p>
<h2 id="Image-Storage"><a href="#Image-Storage" class="headerlink" title="Image Storage"></a>Image Storage</h2><p>大部分rgb格式的图片,为三个通道，每个分配8bit</p>
<p>并且大部分格式的图片支持压缩（compression)</p>
<p>压缩又分为有损压缩和无损压缩</p>
<p><strong>为什么不让monitor(显示器)变成线性的，来避免gamma校正呢？</strong></p>
<blockquote>
<p>Ideally, the 256 possible intensities of a monitor should <em>look</em> evenly spaced as</p>
<p>opposed to being linearly spaced in energy. Because human perception of in</p>
<p>tensity is itself nonlinear, a gamma between 1.5 and 3 (depending on viewing</p>
<p>conditions) will make the intensities approximately uniform in a subjective sense.</p>
<p>In this way, gamma is a feature. Otherwise, the manufacturers would make the</p>
<p>monitors linear.</p>
</blockquote>
<p>理想情况下，256种强度的显示器应该是看起来能量均匀分布而不是线性分布。</p>
<p>因为人类感知本来就不是线性的。一个1.5到3的gamma值可以几乎让人从主观的感觉区分每种强度。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><font jump="补充">补充</font></h3><p><strong>根据百度</strong>：</p>
<p><code>Gamma源于CRT（显示器/电视机）的响应曲线，即其亮度与输入电压的非线性关系。</code></p>
<ul>
<li><p><strong>为什么显示器要Gamma校正</strong> 因为人眼对亮度的感知与物理功率不成正比，而是幂函数的关系，这个指数通常是2.2，称为Gamma值。</p>
</li>
<li><p>例如，功率为50%的灰色，人眼实际感知亮度为<code>pow(0.5,1/2.2) * 100% = 72.97%</code></p>
<p>但是人眼认为的50%的灰色，实际功率为<code>pow(0.5,2.2) * 100% = 21.76%</code></p>
<p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/uTools_1667052564080.png" alt="uTools_1667052564080"></p>
<p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/uTools_1667052057309.png" alt="uTools_1667052057309"></p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Gamma校正的应用之一，就是明度和灰度计算公式。</p>
<p><strong>RGB明度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/6e778b35764a65eed7a22fa000b7dcf4.svg" alt="img"></p>
<p>L取值范围为0~1</p>
<p><strong>RGB灰度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/61b798fe6cddb99adc44b1aae1c92c22.svg" alt="img"></p>
<p><strong>注意这里的2.2次方和2.2次方根，RGB颜色值不能简单直接相加，而是必须用2.2次方换算成物理光功率。</strong>因为RGB值与功率并非简单的线性关系，而是幂函数关系，这个函数的指数称为Gamma值，一般为2.2，而这个换算过程，称为Gamma校正。</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7</title>
    <url>/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/</url>
    <content><![CDATA[<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们通常用一张纹理代替物体漫反射</p>
<h3 id="单纹理贴图"><a href="#单纹理贴图" class="headerlink" title="单纹理贴图"></a>单纹理贴图</h3><p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line"></span><br><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter7/SingleTexture&quot;&#123;</span><br><span class="line"></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Specular(&quot;Specular&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;,Range(8.0,256)) = 20</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed3 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST; //TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算， 确保材质球里的缩//放和偏移设置是正确的。 （v.texcoord就是顶点的uv）</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex :POSITION;</span><br><span class="line">                float3 normal :NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                o.uv = v.texcoord.xy + _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                //get normal</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //get lightdir</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); //输入世界坐标，返回该点到光源方向</span><br><span class="line">                //拿采样结果和color的乘积作为反射率</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //计算环境光</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse =  _LightColor0.rgb * albedo.rgb * max(0,dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                //朝向光源</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));//_WorldCameraPos - o.wroldPos(not normalized)</span><br><span class="line">                //halfDir代替出射光,worldLightDir指向交点</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                //计算高光,发现reflect*viewDir 变成了normal*halfDir</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal , halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/uTools_1660877749523.png"></p>
<p>中间由于将halfDir 、diffuse声明为fixed，导致高光方向错误</p>
<p><code>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code></p>
<p>tilling 和 offset==&gt; 平铺和偏移系数</p>
<h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><p><em>分为高度贴图和法线贴图；前者记录深度值，后者记录法线</em>，一般法线映射认为是凹凸贴图的等价（实际不然）</p>
<p>而法线纹理中，又分为模型空间下的和切线空间下的，一般用切线空间下的法线贴图更方便</p>
<p><strong>切线空间指的是以某点切线、副切线、法线为三个坐标轴的空间（副切线有时也称为Binormal)</strong></p>
<h4 id="切线空间下的光照模型的计算"><a href="#切线空间下的光照模型的计算" class="headerlink" title="切线空间下的光照模型的计算"></a>切线空间下的光照模型的计算</h4><p><em>计算副法线Binormal</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Compute the binormal </span><br><span class="line">//float3 binormal = cross (normalize (v . normal), normalize (v. tangent. xyz )) * </span><br><span class="line">v . tangent.w; </span><br><span class="line">//Cons rue matrix which transform vectors from object space to tangent spac e </span><br><span class="line">//float3x3 rotation= float3x3(v . tangent . xyz , binormal, no mal)</span><br><span class="line">//Or just use the built-in macro </span><br><span class="line">TANGENT SPACE ROTATION;</span><br></pre></td></tr></table></figure>

<p>如果再法线纹理中没有设置为Normal Map,需要再代码中手动设置；这是为了方便Unity优化法线纹理的存储压缩</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Or mark the texture as &quot;Noramal Map&quot;</span></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale; <span class="comment">//控制凹凸程度</span></span><br><span class="line">tangentNormal.z = sqrt(<span class="number">1.0</span>-saturate(dot(tangentNormal.xy,tangentNormal.xy)));<span class="comment">//由于是单位矢量，直接计算出z</span></span><br></pre></td></tr></table></figure>

<p>使用tex2D返回_BumpMap的采样</p>
<p><code> fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw);</code></p>
<p><strong>结果</strong></p>
<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/uTools_1660905878189.png" alt="uTools_1660905878189"></p>
<h4 id="世界空间下计算光照"><a href="#世界空间下计算光照" class="headerlink" title="世界空间下计算光照"></a>世界空间下计算光照</h4><p>插值寄存器只能存放最大float4,无法存放矩阵，所以声明三个float4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                // float3 lightDir : TEXCOORD1;</span><br><span class="line">                // float3 viewDir : TEXCOORD2;</span><br><span class="line"></span><br><span class="line">                //WorldSpace</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                Float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //一个uv存两张图</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; </span><br><span class="line"></span><br><span class="line">                //WorldSpace-----------</span><br><span class="line">                fixed3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal,worldTangent) * v.tangent.w;//叉乘</span><br><span class="line">                </span><br><span class="line">                //Compute transform matrix</span><br><span class="line">                o.TtoW0 = float4(worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);</span><br><span class="line"></span><br><span class="line">                //---------------------</span><br><span class="line">                // //计算副法线</span><br><span class="line">                // TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line">                // //将模型空间的光线变换到切线空间中</span><br><span class="line">                // o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex).xyz);</span><br><span class="line">                // //同时将视角方向传递到切线空间</span><br><span class="line">                // o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex).xyz);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                </span><br><span class="line">                //get worldpos</span><br><span class="line">                fixed3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">                //compute light and view dir</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                fixed3 bump= UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump.xy *= _BumpScale ; </span><br><span class="line">                bump.z = sqrt(1.0- saturate(dot(bump.xy, bump.xy))); </span><br><span class="line">                // Transform the normal from tangent space to wo ld space </span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz,bump), </span><br><span class="line">                dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //-------------</span><br><span class="line">                 //tex2d 返回float4,普通纹理返回颜色值 bump则是法向量</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(bump,lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(bump,halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/image-20220820083553612.png" alt="image-20220820083553612"></p>
<p><strong>CreateFromGrayscale</strong> 用高度图生成切线空间法线纹理</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 03</title>
    <url>/2022/10/31/%E8%99%8E%E4%B9%A6/03/</url>
    <content><![CDATA[<h1 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h1><p><strong>Why Ray Tracing?</strong></p>
<ul>
<li>rasterization : real-time,ray tracing: offline</li>
<li>ray tracing is accurate,but is very slow</li>
</ul>
<p><strong>Whitted-Style Ray Tracing</strong></p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667388590899.png" alt="uTools_1667388590899"></p>
<p>渲染3d物体时计算机图形的工作之一。</p>
<p>同一场景的物体渲染需要考虑每个物体贡献的像素。</p>
<p>有两种常规的方法来考虑</p>
<ul>
<li>object-order rendering ,通过找物体来计算对应像素</li>
<li>image-order rendering，通过找像素来判断物体，然后计算像素</li>
</ul>
<p>差别可以这么来看</p>
<p>前者双重循环外循环是物体，后者则是像素</p>
<p>宽泛来说，image-order rendering 是更加简单和灵活的，一般来说也会有更长的执行事件来制造同样的图片。</p>
<p><strong>Ray Tracing 就是image-order algorithm</strong>因为这样不需要像前者一样用数学器械就能实现光线追踪器。</p>
<h2 id="The-Basic-Ray-Tracing-Algorithm"><a href="#The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="The Basic Ray-Tracing Algorithm"></a>The Basic Ray-Tracing Algorithm</h2><p>基本的光线追踪器有三个部分</p>
<p>某种意义上，在引擎中，可以认为“眼睛发光”</p>
<ol>
<li><p>ray generation. 计算每个像素的view射线的来源和方向</p>
</li>
<li><p>ray intersection. 计算与view射线相交的最近物体</p>
</li>
<li><p>shading. 在原有的射线相交的基础上进行着色</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667218571247.png" alt="uTools_1667218571247"></p>
</li>
</ol>
<h2 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h2><p>标准的方法来为计算机图形，艺术和照片制作图片，是使用linear perspective(线性透视)</p>
<p>parallel projection(平行投影)是最简单的投影方式，平移。一般用于机械和建筑</p>
<p>如果image plane和视线方向垂直，成为orthograph(正交投影)  orthonormal(正交的)</p>
<h2 id="Compute-View-Ray"><a href="#Compute-View-Ray" class="headerlink" title="Compute View Ray"></a>Compute View Ray</h2><p>phase 1</p>
<p>为了生成ray,我们首先需要一个数学表达</p>
<p><code>p(t) = e + t(s- e)</code></p>
<p>e is eye,    s is image plane point</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667219704846.png" alt="uTools_1667219704846"></p>
<p>在代码中</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667219881824.png" alt="uTools_1667219881824"></p>
<p>详情见P84</p>
<h3 id="Orthographic-Views"><a href="#Orthographic-Views" class="headerlink" title="Orthographic Views"></a>Orthographic Views</h3><p>对于正交投影view ray,</p>
<p>ray generation 使用相机的框架，</p>
<ol>
<li><p>正交投影从image plane的一个像素的位置开始，并且全部共享相同的方向—-view direction.</p>
</li>
<li><p>而透视投影则是选择一个view point 开始，方向则是view point 到image plane的点的位置。</p>
</li>
</ol>
<p><strong>要将nx  ny 的像素投射到(r - l) x (t - b)的矩形上</strong></p>
<p>其中l,r分别是片元，pixel的左右边界坐标，b和t则是下、上边界坐标</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667220608282.png" alt="uTools_1667220608282"></p>
<p>详情见P86</p>
<h3 id="Perspective-Views"><a href="#Perspective-Views" class="headerlink" title="Perspective Views"></a>Perspective Views</h3><h2 id="Ray-Object-Intersection"><a href="#Ray-Object-Intersection" class="headerlink" title="Ray-Object Intersection"></a>Ray-Object Intersection</h2><p>phase 2</p>
<h3 id="Ray-Sphere-Intersection"><a href="#Ray-Sphere-Intersection" class="headerlink" title="Ray-Sphere Intersection"></a>Ray-Sphere Intersection</h3><p>使用implicit surface</p>
<p>隐式表达式f(p(t)) = 0或者f(e + td) = 0</p>
<p>对于一个球来说，设中心点为c</p>
<p><code>(p - c)(p - c) - R^2 = 0</code></p>
<p><strong>注意，当满足上式，说明p对应的点已经在球上，也即intersection</strong></p>
<p><code>(e + t d - c)(e + td - c) - R^2 = 0</code></p>
<p>只有t未知</p>
<p>展开得到quadratic 二次方程，判别式b^2 - 4ac</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667222501427.png" alt="uTools_1667222501427"></p>
<h2 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h2><p>Here we will discuss how a ray tracer computes the inputs to shading</p>
<p>1.从点光源和直线光计算着色需要具体的几何信息。当viewing ray 确定与表面相交，我们需要决定以下4个向量。</p>
<ul>
<li>着色点x可以通过估算viewing ray 以t的值相交</li>
<li>表面的法线向量n</li>
<li>光源方向l</li>
<li>视觉射线viewing direction 是viewing ray的反方向（v = -d/|d|)</li>
</ul>
<p>2.coding</p>
<p>3.一旦你已经在光线追踪器上有基本的着色后，光线和点阴影添加会很容易</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667389464606.png" alt="uTools_1667389464606"></p>
<p>使用directional light 的阴影与点光源类似，但是t=无穷，也即距离无穷，环境光不进行阴影测试（shadow test)</p>
<p>4.Mirror Reflection(镜面反射)</p>
<p>为光线追踪程序添加镜面发射（or specular reflection) 很直接。</p>
<p>由视线计算反射光向量，<strong>易得</strong></p>
<p><code>r = d - 2(d*n)*n</code></p>
<p>其中r是反射向量，d是view(视线)入射的向量</p>
<p><strong>在现实世界中，当光线从表面反射出去，一定会有能量损失</strong></p>
<p>由于光线颜色不同，损失也会不一样，这里使用递归算法(recursive)</p>
<p>调用shader-ray函数。</p>
<p><code>color c = c + k * shader-ray(Ray(p,r),t,infinity)</code></p>
<p>k是specular rgb color, 并且t = infinity,和shadow一样。因为并不想让光线反射到光源上</p>
<h2 id="Frequently-Asked"><a href="#Frequently-Asked" class="headerlink" title="Frequently Asked"></a>Frequently Asked</h2><ul>
<li><p>为什么ray tracing 中没有透视矩阵</p>
</li>
<li><p>可以实现交互式光线追踪吗</p>
<p>对于充分小的模型和图片，任何现代pc都足以支持可交互式光线追踪。现实中，对于全屏的实现，多cpu共享帧缓存区是需要的。</p>
<p>计算机算力进步比屏幕分辨率更快，让传统pc在屏幕分辨率下实现复杂场景光线追踪只不过是时间问题。</p>
</li>
<li><p>ray tracing在硬件图形程序中有用吗</p>
<p>光线追踪经常用于<strong>采集</strong>，当用户点击鼠标3d图形程序的像素，程序需要决定哪个物体的显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7-1</title>
    <url>/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/</url>
    <content><![CDATA[<h2 id="Chapter7"><a href="#Chapter7" class="headerlink" title="Chapter7"></a>Chapter7</h2><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><p>冷色调转暖色调，编写卡通风格Unity Shader（<em>记录：区别BlinnPhong和Phong高光计算</em>，另外如果计算新的漫反射albedo,就不用声明_Diffuse来计算diffuse）</p>
<p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">               fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">               fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">               fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;  //</span><br><span class="line"></span><br><span class="line">               //使用纹理来采样漫反射,使用半兰伯特模型</span><br><span class="line">               fixed halfLambert = 0.5 * dot(worldNormal,worldLightDir) + 0.5;</span><br><span class="line">               fixed3 diffuseColor = tex2D(_RampTex,fixed2(halfLambert,halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">               fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">               //计算高光BlinnPhong模型</span><br><span class="line">               fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">               fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">               fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss);</span><br><span class="line">               </span><br><span class="line">               return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<p>注意使用<code>fixed2(halfLambert,halfLambert)</code>会发生大于1的情况（1.0001）,这样映射到模型上会出现黑点</p>
<p>此时需要将纹理的WrapMode从Repeat(重复，但是最左边是黑色的）换成Clamp(大于1取1)</p>
<p><img src="/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5Cimage-20220820110835470.png" alt="image-20220820110835470"></p>
<h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><p>使用高光遮罩纹理，遮罩纹理用于更加细致地控制高光反射光强度</p>
<p>变量声明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">fixed4 _Color;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line"><span class="comment">//float4 _BumpMap_ST;</span></span><br><span class="line"><span class="built_in">float</span> _BumpScale;</span><br><span class="line">sampler2D _SpecularMask;</span><br><span class="line"><span class="comment">//float4 _SpecularMask_ST;</span></span><br><span class="line"><span class="built_in">float</span> _SpecularScale;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="built_in">float</span> _Gloss;</span><br></pre></td></tr></table></figure>

<p><em>这里 _ BumpMap、_ Specular和_MainTex共用一个ST</em></p>
<p>如果每个纹理都需要不同的平铺系数和偏移系数，那么纹理数目增加顶点着色器中的插值寄存器会迅速被占满。</p>
<p><strong>流程</strong></p>
<p>1.该实验使用了三个纹理，分别是基本纹理，切线空间的法线纹理（凹凸贴图），高光遮罩纹理</p>
<p>2.计算是逐像素计算，计算是在切线空间下进行（一定要明确在哪个空间下进行），diffuse用lambert模型</p>
<p>specular用BlinnPhong模型</p>
<p>3.<code>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex;</code>三张纹理共用同一套uv</p>
<p><strong>结果</strong></p>
<p>加上遮罩贴图后高光更加暗淡和谐</p>
<p><img src="/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5CuTools_1660974045813.png" alt="uTools_1660974045813"></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 04</title>
    <url>/2022/11/02/%E8%99%8E%E4%B9%A6/04/</url>
    <content><![CDATA[<h1 id="Surface-Shading"><a href="#Surface-Shading" class="headerlink" title="Surface Shading"></a>Surface Shading</h1><p>渲染3d场景时，无论使用ray tracing还是rasterization，在实时还是在批处理中，<strong>着色</strong>是对视觉效果影响</p>
<p>最大的过程之一</p>
<p>本章描述基于点光源照射的不透明表面基本着色模型。</p>
<h2 id="Point-source-illumination"><a href="#Point-source-illumination" class="headerlink" title="Point source illumination"></a>Point source illumination</h2><p>点光源包括position,intensity</p>
<p>点光源有isotropic(各向同性)</p>
<p>the irradiance E is  <code>E = P/4PI * 1/pow(r,2)</code></p>
<p>the quantity I = P/4PI,是光强(amount of light)，后者是factor</p>
<p>更普遍地，<code>E = I * cos(theta) / pow(r,2)</code>,其中<code>cos(theta) = n * l</code></p>
<p><img src="/2022/11/02/%E8%99%8E%E4%B9%A6/04/uTools_1667393710823.png" alt="uTools_1667393710823"></p>
<h3 id="Directional-illumination"><a href="#Directional-illumination" class="headerlink" title="Directional illumination"></a>Directional illumination</h3><p>不同于点光源，由于方向光是由很远的点光源产生，这就导致I/(r^2)的占比很小，这里设为一个常数H</p>
<p><code>E = H * cos(theta)</code></p>
<p>其中常量H被称为法向辐射（normal irradiance)</p>
<h3 id="Basic-reflection-models"><a href="#Basic-reflection-models" class="headerlink" title="Basic reflection models"></a>Basic reflection models</h3><p>现在可以计算辐射度（irradiance)了，辐射量可以表示照在物体上的光的量。</p>
<p><strong>1.Lambertian reflection</strong> 这是一种非常简单的模型，用于计算漫反射，光无差别反射。</p>
<p><code>L = kE</code></p>
<p><code>L = R/PI * E</code> 其中R是反射的光的强度</p>
<p>兰伯特模型公式<code>c = _DiffuseColor.rgb * _MainLight.rgb * max(dot(n,l),0);</code></p>
<p>半兰伯特则是点乘结果tilling 0.5,offset 0.5</p>
<p><strong>2. Specular reflection</strong></p>
<p>许多材质具有不同程度的亮度（shininess),例如金属光泽（metal),塑料（plastic)</p>
<p>光泽（gloss),半光泽（semi-gloss)</p>
<p>2.1最简单的高光（镜面反射）发生在完美的平滑表面，例如镜子，或者水的表面。</p>
<p>这种效果来源于一个点光源，点光源有具体的方向，使得表面有一个大的高光点。</p>
<p>2.2但是一般表面并不平滑，一般显示的效果更接近于glossy reflection.</p>
<p>比较知名的简单模型是BlinnPhong模型。</p>
<p>简化公式为<code>specular = _SpecularColor.rgb * _BaseColor * pow(max(0,dot(n,h)),_Gloss);</code></p>
<p>其中<code>h = normalize(l + v)</code></p>
<p>注意phong模型与BlinnPhong的区别（v*r)</p>
<p>一般将高光和漫反射相加统筹</p>
<p><img src="/2022/11/02/%E8%99%8E%E4%B9%A6/04/uTools_1667567665544.png" alt="uTools_1667567665544"></p>
<p><strong>生成因子k的表达式叫做双向反射分布函数（BRDF)</strong></p>
<p>因为它反映了反射光随l,v两个向量的改变而改变</p>
<p>对于lambertian的brdf是常量（constant)</p>
<p>对于specular则不是。irradiance描述了光的“量”，而brdf则描述了表面如何反射光。</p>
<h3 id="Caculating-shading"><a href="#Caculating-shading" class="headerlink" title="Caculating shading"></a>Caculating shading</h3><ul>
<li>光的入射向量<code>l = lightPosition - modelVertex</code></li>
</ul>
<p><img src="/2022/11/02/%E8%99%8E%E4%B9%A6/04/uTools_1667568753509.png" alt="uTools_1667568753509"></p>
<h2 id="Ambient-illumination"><a href="#Ambient-illumination" class="headerlink" title="Ambient illumination"></a>Ambient illumination</h2><p>点光源是非常局部性的光源</p>
<p><code>ambient = UNITY_LIGHTMODE_AMBIENT.rgb * albedo</code></p>
<p><img src="/2022/11/02/%E8%99%8E%E4%B9%A6/04/uTools_1667819295698.png" alt="uTools_1667819295698"></p>
<p>环境光着色是一个有点hack的手段，因为大型扩展光源发出的光是不同的，在角落和凹陷区域都会更暗一些。</p>
<p>但是它却是很重要的，因为它防止阴影变成完全的黑色，并且容易调整场景对比度。</p>
<p>一些系统把环境光看作一种点光源或平行光。还有一些系统则是让环境光Intensity成为一个场景的参数，来模拟环境光。</p>
<h3 id="Frequently-Asked-Questions"><a href="#Frequently-Asked-Questions" class="headerlink" title="Frequently Asked Questions"></a>Frequently Asked Questions</h3><ul>
<li><p>Phong 模型看起来是个很大的hack操作</p>
<p>yes</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要8</title>
    <url>/2022/11/02/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/</url>
    <content><![CDATA[<h2 id="Chapter8-透明效果"><a href="#Chapter8-透明效果" class="headerlink" title="Chapter8 透明效果"></a>Chapter8 透明效果</h2><h3 id="实现透明的方法"><a href="#实现透明的方法" class="headerlink" title="实现透明的方法"></a>实现透明的方法</h3><p>unity中通常使用两种方式实现透明效果</p>
<p>1.透明度测试(alpha test),（无法实现真正的半透明）</p>
<p>2.透明度混合(alpha blending)</p>
<p><strong>使用深度测试，可以不考虑渲染顺序</strong>，但是使用透明度混合时，需要关闭*<code>ZWrite</code>*，关闭了深度写入</p>
<p>虽然<em>透明度测试</em>不需要关闭，但是它的机制是如果透明度不满足某个阈值（通常小于），直接舍弃该片元。</p>
<ul>
<li>为什么关闭<code>ZWrite</code>?</li>
</ul>
<p><em>由于深度测试丢弃远处被遮挡部分，但是透明物体的机制是”可以透过并看见远处的物体”。</em></p>
<p>关闭了ZWrite，渲染顺序则成了问题。</p>
<p><strong>流程</strong></p>
<p>1.渲染时，会进行深度测试，如果先渲染后面的不透明b，将b写入颜色缓冲和深度缓冲；然后渲染前面的透明a,a写入颜色缓冲，会发生透明混合，显示正确。</p>
<p>2.如果先渲染a,进行深度测试，写入颜色缓冲，但是关闭了ZWrite，无法写入深度值，然后渲染b，写入深度值，写入颜色缓冲，b的颜色<strong>覆盖</strong>a,只能看见b。</p>
<p>3.半透明物体之间亦然。</p>
<h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>Unity Shader解决方案为SubShader 中的Tags</p>
<p>以下为透明度测试alpha test示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       Tags&#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;TransparentCutout&quot;</span>&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">//alpha test</span></span><br><span class="line">               clip(texColor.a - _Cutoff);</span><br><span class="line">               <span class="comment">// Equal to </span></span><br><span class="line">               <span class="comment">// if (( exColor - _Cutoff) &lt; 0 . 0) &#123; </span></span><br><span class="line">               <span class="comment">// discard; &#125;</span></span><br><span class="line">           	...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">         &#125;  </span><br></pre></td></tr></table></figure>

<p>每块的透明度都不同，根据面板调整_Cutoff可以看出哪个更低，低的那个会直接被剔除</p>
<p>结果图</p>
<p><img src="/2022/11/02/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/uTools_1660983793621.png" alt="uTools_1660983793621"></p>
<h3 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       //alpha blend</span><br><span class="line">       Tags&#123;&quot;Queue&quot;=/*&quot;AlphaTest&quot;*/&quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">           ZWrite Off</span><br><span class="line">           Blend SrcAlpha OneMinusSrcAlpha  //P170</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br><span class="line">           //去掉clip</span><br></pre></td></tr></table></figure>

<h3 id="解决排序问题"><a href="#解决排序问题" class="headerlink" title="解决排序问题"></a>解决排序问题</h3><p><strong>一般先开启深度测试、写入，先渲染不透明物体，然后关闭写入，对不透明物体排序，先渲染后面的物体</strong></p>
<ul>
<li><strong>但是仍然存在很大问题。</strong></li>
</ul>
<p>比如一个物体，各个部分互相遮挡，又或者多个物体，相互遮挡，而深度排序是像素级别的。</p>
<p><strong>问题在于</strong></p>
<p>现在开启ZWrite</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Pass&#123;</span><br><span class="line"> ZWrite On </span><br><span class="line"> ColorMask 0//ColorMask RGB 、 A 、 0 、其他任何rgba的组合</span><br><span class="line"> //0表示不写入任何颜色通道，即只写入深度缓存，不输出颜色</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新添加一个Pass通道。该Pass专门用来写入深度缓冲，并且先执行。</p>
<p>Pass通道中加上<code>//Cull Front/Back/Off 需要双面渲染时关闭剔除</code></p>
<p>注意如果关闭了深度写入，此时再双面渲染就会出现半透明错误渲染</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要9</title>
    <url>/2022/11/03/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter9/</url>
    <content><![CDATA[<h2 id="Complex-Light-Chapter9"><a href="#Complex-Light-Chapter9" class="headerlink" title="Complex Light - Chapter9"></a>Complex Light - Chapter9</h2><h3 id="渲染路径（Rendering-Path"><a href="#渲染路径（Rendering-Path" class="headerlink" title="渲染路径（Rendering Path)"></a>渲染路径（Rendering Path)</h3><p><strong>分为前向渲染路径，延迟渲染路径(更新），顶点渲染路径（弃用）</strong></p>
<p>1.前向渲染路径，如果深度测试不过关，该片元不可见，反之可见，就进行光照计算</p>
<p>2.如果物体受到多个光源照射，就要写多个Pass,然后在帧缓冲中将这些光照结果混合。</p>
<p>3.前向渲染中，光照类型（平行光parallel light或其他）+光照渲染模式（important)决定了处理光照（照亮物体）的方式。</p>
<p>而处理方式分为逐像素，逐顶点、sh计算。</p>
<p>参见P182</p>
<h3 id="Unity光源类型"><a href="#Unity光源类型" class="headerlink" title="Unity光源类型"></a>Unity光源类型</h3><p>1.平行光、点光源、<em>面光源</em>和<em>聚光灯</em>，面光源只在烘焙时才会产生作用</p>
<p>2.当RenderMode是Auto,Unity自动判断哪些光源逐像素，哪些顶点、sh计算。</p>
<p>3.最亮的平行光是按照逐像素计算，而Auto状态下最多除平行光源外4个逐像素计算，这些在addtional pass中计算</p>
<p><strong>最常用的光源属性有：位置、方向、颜色、强度、衰减</strong></p>
<ul>
<li>光照衰弱</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用纹理来计算衰弱值</span></span><br><span class="line"><span class="keyword">fixed</span> atten = tex2D(_ ghtTextureO, dot(lightCoord, lightCoord) .rr) .UNITY_ATTEN_CHANNEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数学公式进行线性衰弱值计算</span></span><br><span class="line"><span class="built_in">float</span> distance = length (_WorldSpaceLightPosO . xyz - i. worldPosi <span class="keyword">on</span>.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> <span class="comment">// distance; // linear attenuation</span></span><br></pre></td></tr></table></figure>



<h3 id="Unity阴影"><a href="#Unity阴影" class="headerlink" title="Unity阴影"></a>Unity阴影</h3><p>1.如果最重要的平行光开启了阴影，那么Unity会为这个光源生成<em>阴影纹理图</em>，一种由光源出发的深度图。</p>
<p>2.另取一个LightMode为ShadowCaster的Pass,Unity会将摄像头放到光源的地方</p>
<p>3.一个物体想要接收阴影，那么在shader中要对纹理采样；相同地，一个物体想要投射阴影，就要参与纹理计算</p>
<p>见P200</p>
<ul>
<li>如何让正方体接收阴影</li>
</ul>
<p>SHADOWCOORD,TRANSFER_SHADOW,SHADOW_ATTENUATION分别在v2f,vert,frag中调用</p>
<p>实现接收阴影</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHADOW_COORDS(2)</span><br><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure>



<p><strong>光照衰减和阴影的效果是一样的，于是就有了统一光照衰弱和阴影</strong></p>
<p>unity提供一个方法同时管理这两者</p>
<p><code>UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</code></p>
<ul>
<li><p>透明物体的阴影</p>
<p>在AlphaTest的基础上使用上述方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Event System</title>
    <url>/2022/11/06/Unity/EventSystem/</url>
    <content><![CDATA[<h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>两个文件</p>
<p><a href="EventSystem/01/EventManager.cs">EventManager</a></p>
<p><a href="EventSystem/01/IEventListener.cs">EventManager</a></p>
<p><strong>用法</strong></p>
<ul>
<li>使用<code>interface IEventListener</code>注册事件，卸载事件</li>
<li>注册具体方法使用<code>AddEventListener</code>,卸载使用<code>RemoveEventListener</code></li>
<li>如果需要传多个参数，需要适当更新文件具体代码</li>
</ul>
<p><strong>综述</strong></p>
<p>一件事情会有可能会有许多反馈，每当我们要检测一个事件，首先注册这个事件，不断+=添加方法（反馈）,这些都在start(awake)之类中进行，等到游戏结束再取消订阅。</p>
<ul>
<li>包含一个<code>static EventManager instance;</code>单一实例并用于外部访问成员数据和方法</li>
<li>包含一个<code>interface IEventInfo</code>用于外部多态地实现方法</li>
<li>包含一个字典<code>Dictionary&lt;string,IEventInfo&gt; actionDic</code> 用于存储事件，可以理解成”事件池”</li>
<li>包含类<code>EventInfo&lt;T&gt;</code>继承自上述接口，用于添加单参数方法</li>
<li>包含添加、移除、触发事件</li>
</ul>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>文件</p>
<p><a href="EventSystem/02/EventHandler.cs">EventHandler</a></p>
<p>原理与方法一是一样的，使用方法也大差不差。</p>
<p>方法一将事件加入字典，不用每次添加都往一个文件里跑，并且结构也清晰一些。</p>
<p>方法二代码量相对少？好像也没少…。</p>
]]></content>
      <categories>
        <category>Game system with uniy</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要9</title>
    <url>/2022/11/07/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/</url>
    <content><![CDATA[<h2 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h2><h3 id="立方体纹理（CubeMap"><a href="#立方体纹理（CubeMap" class="headerlink" title="立方体纹理（CubeMap)"></a>立方体纹理（CubeMap)</h3><p>立方体纹理映射技术是实现环境映射的一种方法，还应用于Skybox</p>
<p>1.新建skybox类型的材质，填充6张中级篇Chapter10，设置为Wrap Mode设置为Clamp使得衔接顺畅;</p>
<p>2.创建用于环境映射的<code>CubeMap</code></p>
<p>环境映射技术最常见的应用是<strong>反射</strong>和<strong>折射</strong></p>
<ul>
<li>反射</li>
</ul>
<p><code>lerp(y1,y2,weight) = y1 + (y2-y1)*weight;</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">fixed3 reflection = texCUBE(_CubeMap,i.worldRefl).rgb * _Reflection.rgb;<span class="comment">//在立体纹理中采样</span></span><br><span class="line"></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line">float3 color = ambient + lerp(diffuse,reflection,_ReflectionAmount) *atten;<span class="comment">//有反射，无高光</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/07/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213048053.png" alt="uTools_1661213048053"></p>
<ul>
<li>折射(Refraction)</li>
</ul>
<p>​    计算折射</p>
<p><img src="/2022/11/07/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213306951.png" alt="uTools_1661213306951"></p>
<p>**斯涅尔定律(Snell’s law)**，m1 *sin(a) = m2 * sin(a2)，m1,m2 分别为折射率。真空折射率是1，玻璃的折射率是1.5</p>
<p>玻璃一般分为两次折射，但第二次折射较复杂，一般只模拟第一次折射。</p>
<p><img src="/2022/11/07/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661218211269.png" alt="uTools_1661218211269"></p>
<p><strong>菲涅耳反射</strong></p>
<p>（Fresnel Reflection)</p>
<p>比如看远处的水会反光，这就是菲涅耳反射；不仅透明物体，很多不透明物体或多或少都存在菲涅耳反射。</p>
<p>F(V ,D)=F0+(l-F0)(1-v·n)^5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed fresnel = _FresnelScale + (1-_FresnelScale) * pow(1-dot(worldViewDir,worldNormal),5);</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">return fixed4(color, 1.0);</span><br></pre></td></tr></table></figure>



<h3 id="渲染目标纹理"><a href="#渲染目标纹理" class="headerlink" title="渲染目标纹理"></a>渲染目标纹理</h3><p>现代GPU允许将三维场景渲染到中间缓冲，即渲染目标纹理（Render Target Texture)</p>
<p><strong>使用渲染纹理模拟镜子效果</strong></p>
<p>见P219</p>
<p><strong>玻璃效果</strong></p>
<p>to be studyed</p>
<h3 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h3><p>SetProperty，该插件用于在Unity面板上修改材质属性，并通过_UpdateMaterial()函数来使用新的属性生成程序<a href="https://so.csdn.net/so/search?q=%E7%BA%B9%E7%90%86&spm=1001.2101.3001.7020">纹理</a>。</p>
<p><em>示例</em> :<code>ProceduralTextureGeneration.cs</code></p>
<p>代码首先初始化 维纹理，并且提前计算了 些生成纹理时需要的变队。然后，使用了</p>
<p>个两层的嵌套循环遍历纹理中的每个像素，并在纹理七依次绘制 个圆形 。最后，调用</p>
<p>Texture2D.Apply 函数来强制把像素值写入纹理中，并返回该程序纹理。</p>
<p><strong>unity中有一种程序材质专门使用程序纹理。而程序纹理是通过算法实现的效果。</strong></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 05</title>
    <url>/2022/11/07/%E8%99%8E%E4%B9%A6/05/</url>
    <content><![CDATA[<h1 id="Viewing"><a href="#Viewing" class="headerlink" title="Viewing"></a>Viewing</h1><h2 id="Viewing-Transformations"><a href="#Viewing-Transformations" class="headerlink" title="Viewing Transformations"></a>Viewing Transformations</h2><p>视角变换用于映射3d位置。</p>
<p>它是一头复杂的野兽，依赖于包括相机坐标、orientation(取向)，投影的类型，视角的区域，和图片的清晰度(resolution);</p>
<p>它是通过几个简单变换点乘获得</p>
<ul>
<li>相机变换(camera/eye  transformation)</li>
<li>投影变换(projection transformation)</li>
<li>视口(窗口)变换(viewport transformation)</li>
</ul>
<p><img src="/2022/11/07/%E8%99%8E%E4%B9%A6/05/uTools_1667821796670.png" alt="uTools_1667821796670"></p>
<p>模型空间-&gt;世界空间-&gt;相机空间-&gt;规范化视线空间-&gt;屏幕空间</p>
<h3 id="The-Viewport-Transformation"><a href="#The-Viewport-Transformation" class="headerlink" title="The Viewport Transformation"></a>The Viewport Transformation</h3><p>假设我们想要看到的几何体在规范的视图体积空间(canonical view volume)</p>
<p>然后我们想要在z轴方向用**正交(orthographic)**相机观察</p>
<p>canonical view volume(规范视图空间)是一个包含了所有3d坐标的正方体，这些坐标</p>
<p>在笛卡尔坐标系(cartesian coordinates)中处于（-1，1）之间</p>
<p>我们将x = -1投射到屏幕的左边，y = -1投射到屏幕的底部，像素坐标的定义是围绕着</p>
<p>以整数坐标为中心的方形。这样图像的边缘就有半个unit的overshoot</p>
<p>如果我们想要在图片上画nx * ny个像素,我们需要将square[-1.1]映射到[-0.5，nx - 0.5]</p>
<p>x [-0.5,ny - 0.5]</p>
<p><strong>这里是假设线段完全在规范视角空间里，后面会放下这个假设,讨论clipping(裁剪)</strong></p>
<p><img src="/2022/11/07/%E8%99%8E%E4%B9%A6/05/uTools_1667823244143.png" alt="uTools_1667823244143"></p>
<p><code>Xscreen = nx/2 * Xcanonical + (nx - 1) / 2</code></p>
<p>…</p>
<p>注意这个矩阵忽略了z分量，因为这不影响投影到图片，但是在正式称呼这个矩阵为视口矩阵</p>
<p>(transform to screen),我们需要增加一一行和一列来存储z分量，不改变z分量</p>
<p><img src="/2022/11/07/%E8%99%8E%E4%B9%A6/05/uTools_1667824528183.png" alt="uTools_1667824528183"></p>
<p>最终这个投影到屏幕</p>
<h3 id="The-Orthographic-Projection-Transformation"><a href="#The-Orthographic-Projection-Transformation" class="headerlink" title="The Orthographic Projection Transformation"></a>The Orthographic Projection Transformation</h3><p>当然，我们通常想要在除了canonical view volume空间的一些区域渲染几何体。我们的第一步是生成视图，这个视图保持view dir,orrientation不变，looking alone -z with +y up. </p>
<p>我们将在右边乘以另一个矩阵来增广这个矩阵。</p>
<p><img src="/2022/11/07/%E8%99%8E%E4%B9%A6/05/uTools_1667909557536.png" alt="uTools_1667909557536"></p>
<p>the six params are respectively left,right,bottom,top,near,far</p>
<p>正交视图空间是在-z轴上，所以f是更小的负数</p>
<p>在z轴上，这样近视图反而比远视图更大，这是非直觉性的(uninstuitive)</p>
<p><img src="/2022/11/07/%E8%99%8E%E4%B9%A6/05/uTools_1667910750246.png" alt="uTools_1667910750246"></p>
<p>omit …..</p>
<h3 id="相机变换"><a href="#相机变换" class="headerlink" title="相机变换"></a>相机变换</h3><h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2>]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要11</title>
    <url>/2022/11/09/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/</url>
    <content><![CDATA[<h2 id="Chapter11-让画面动起来"><a href="#Chapter11-让画面动起来" class="headerlink" title="Chapter11-让画面动起来"></a>Chapter11-让画面动起来</h2><h3 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h3><p>1.序列帧动画</p>
<p>….</p>
<p>2.滚动背景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//frac函数返回标量或每个矢量中各分量的小数部分。return v - floor(v);</span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex) + frac(float2(_ScrollX,0.0)*_Time.y);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord,_DetailTex) + frac(float2(_Scroll2X,0.0)*_Time.y);</span><br><span class="line">//可以发现当x乘上一个小于1的值时，系数越小，呈现的图像结果会越稀疏</span><br></pre></td></tr></table></figure>

<p>函数如下图</p>
<p><img src="/2022/11/09/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661861601610.png" alt="uTools_1661861601610"></p>
<p>frac(float)等价上图</p>
<p>frac(float2())则等价于以圆心为原点，以这个点为起点的线为半径，每过v的长度，为一个周期。最后构成多重圆环。而横坐标</p>
<p>的倍率则影响密度。倍率大于1，噪声越大，间隔小，密度大。</p>
<p><font color="red">如果渲染2d物体，可以将相机模式转换成正交模式</font></p>
<p>3.水波动画</p>
<p>由于本例中需要移动模型空间坐标，而批处理会使得相关模型合并，使得相关模型丢失原来模型空间；所以一般有顶点移动anime的shader要考虑关闭batch;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags&#123;</span><br><span class="line">    &quot;RenderType&quot;=&quot;Transparent&quot;,</span><br><span class="line">    &quot;IgnoreProjector&quot; = &quot;True&quot;,</span><br><span class="line">    &quot;RenderType&quot; = &quot;Transparent&quot;,</span><br><span class="line">    &quot;DisableBatching&quot; = &quot;True&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如何形成水波？顶点着色器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 offset;</span><br><span class="line">offset.yzw = float3(0.0,0.0,0.0);</span><br><span class="line">offset.x = sin(_Frequency * _Time.y +v.vertex.x * _InWaveLength + v.vertex.y *</span><br><span class="line">_InWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line">o.pos = mul(UNITY_MATRIX_MVP,v.vertex + offset);</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); //将纹理进行uv映射</span><br><span class="line">o.uv += float2(0.0,_Time.y * Speed);      //将uv的v根据时间变化进行增长</span><br></pre></td></tr></table></figure>

<p>等价于<br>$$<br>x = Magnitude * sin(_Frequency * t+w * vertex)<br>$$<br>由此使得水波水平变化。</p>
<p>同时还用了纹理动画，产生水平的纹理动画。</p>
<p>4.广告牌技术</p>
<p>效果：星星始终面朝摄像机，向上的位置并未改变，当y轴转动，也会跟着转动</p>
<p><em>代码</em></p>
<p>1.获取模型空间的中心和相机点</p>
<p>2.将法线设为从中心点指向相机的方向</p>
<p>3.将法线y方向乘以_VerticalBillboarding，并归一化</p>
<p>4.一般来说，法线并不等于up向量，up向量为（0，1，0）,但是随着视点的转变，法线也会变，如果法线等于up，</p>
<p>​    那么后续叉乘的结果会出错。此时up会变成向前的向量。</p>
<p>5.然后是right向量，由前两个向量叉乘得到，需要归一化，至此三个正基向量得到。</p>
<p>6.<code>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</code></p>
<p>​    最后实现顶点坐标在模型空间，三个分量不同程度的形变，</p>
<p>​    <strong>结果是：</strong><font color="red">错误</font>_VerticalBillboarding=1，星星就像是跟踪屏幕；</p>
<p>​    _VerticalBillboarding= 0星星固定，有透视效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顶点动画都是在模型空间变换</span><br><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			</span><br><span class="line">			//1.</span><br><span class="line">			float3 center = float3(0, 0, 0);</span><br><span class="line">			float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));</span><br><span class="line">			</span><br><span class="line">			//2.</span><br><span class="line">			float3 normalDir = viewer - center;</span><br><span class="line">			</span><br><span class="line">			//3.</span><br><span class="line">			// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span><br><span class="line">			// Which means the normal dir is fixed</span><br><span class="line">			// Or if _VerticalBillboarding equals 0, the y of normal is 0</span><br><span class="line">			// Which means the up dir is fixed</span><br><span class="line">			normalDir.y =normalDir.y * _VerticalBillboarding;</span><br><span class="line">			normalDir = normalize(normalDir);</span><br><span class="line">			</span><br><span class="line">			//4.</span><br><span class="line">			// Get the approximate up dir</span><br><span class="line">			// If normal dir is already towards up, then the up dir is towards front</span><br><span class="line">			float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">			float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">			upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line">			</span><br><span class="line">			// Use the three vectors to rotate the quad</span><br><span class="line">			float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">			float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">             </span><br><span class="line">			o.pos = UnityObjectToClipPos(float4(localPos, 1));</span><br><span class="line">			o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">			return o;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2022/11/09/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661943292280.png" alt="uTools_1661943292280"></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 06</title>
    <url>/2022/11/08/%E8%99%8E%E4%B9%A6/06/</url>
    <content><![CDATA[<h1 id="The-Graphics-Pipeline"><a href="#The-Graphics-Pipeline" class="headerlink" title="The Graphics Pipeline"></a>The Graphics Pipeline</h1><p>前面几章已经建立了所需的数学基础(scaffolding)</p>
<p>现在主要讨论第二种主要的rendering 方式。</p>
<p>—在屏幕上一个接着一个绘制物体，也即<strong>object order rendering</strong></p>
<p>不同于ray tracing 的方式，通过像素找物体，现在会反过来通过物体找像素</p>
<p>**在一张被几何图元(geometric primitive)占满的图像上的所有像素的过程，称之为rasterization(光栅化)**，所以object order rendering也称之为光栅化渲染</p>
<p>而实现这一操作的操作序列，称之为图形渲染管线，<strong>graphics pipeline</strong></p>
<p>这种方法的成功，来源于它的效率。</p>
<p>对于大型场景，对数据存储模式的管理 是至关重要的操作。而且制作一个整个场景的通道来访问几何的每一个bit一次,比重复地搜索场景来检索所需的场景更加有有时。</p>
<p>object-order rendering不只有一种方法。</p>
<p>hardware 硬件pipeline使用OpenGL,Direct3D等API</p>
<p>software pipeline使用鱼电影制作，提供了像RenderMan这样地API</p>
<ul>
<li><p>硬件渲染管线需要运行地很快，使得足以支撑起实时游戏，可视化和用户交互</p>
</li>
<li><p>Production pipeline(生产管线)则追求高质量动画、视觉效果,但是这会花费很多时间。</p>
</li>
</ul>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><h3 id="Line-Drawing"><a href="#Line-Drawing" class="headerlink" title="Line Drawing"></a>Line Drawing</h3><p><strong>使用隐式线条方程</strong></p>
<p>用隐式方程画线条最普遍的算法是<strong>midpoint algorithm</strong></p>
<p>这种算法能够画出和<strong>Bresenham algorithm</strong>一样的线条，但是稍微更加直接。</p>
<p>见P38</p>
<p>常见的斜截式(slope-intercept)    <code>y = mx + b</code></p>
<p>b称为y-intercept,</p>
<p>slope-intercept 有时有点尴尬(awkward)，因为它不能表示x = 0,不然m需要infinite</p>
<p>这时候使用隐式表达式(implicit equation)     <code>Ax + By + C = 0</code></p>
<p>还有两点式<code>(y0 - y1) x + (x1 - x0)y + C = 0</code></p>
<p>C的话代入任意一个点就可以得到</p>
<p><strong>最终</strong></p>
<p><code>(y0 - y1) x + (x1 - x0)y + x0 y1 - x1y0 = 0</code></p>
<p>我们假设x0&lt;=x1,如果不正确，就交换两个点，斜率</p>
<p>slope    <code>m  =(y1  - y 0)/(x1 - x0);</code></p>
<p><strong>以下假设m在（0，1）区间</strong></p>
<p><img src="/2022/11/08/%E8%99%8E%E4%B9%A6/06/uTools_1667998615390.png" alt="uTools_1667998615390"></p>
<p>一个很有效的方法是，通过比较两个预选像素的中点和line，如果line在中点上面，就画（x+1,y+1)</p>
<p>不然就画（x+1,y)</p>
<p>那么如何比较（x+1,y+0.5）和线条呢</p>
<p><code>f(x + 1,y + 0.5) &lt; 0 then y = y + 1</code></p>
<p>详情见P182</p>
<h3 id="Triangle-Rasterization"><a href="#Triangle-Rasterization" class="headerlink" title="Triangle Rasterization"></a>Triangle Rasterization</h3><p>三角形内重心（barycentric coordinates)的颜色</p>
<p>是 <code>c = a * c0 + b * c1 + r * c2</code></p>
<p>另一个rasterizing triangle的细节（subtlety)是共享顶点和边。</p>
<p>这意味着相邻（adjacent)三角形之间没有间隙，我们可以用midpoint algorithm来画每个</p>
<p>三角形的边，然后填充内部像素</p>
<p>光栅化三角形，需要避免顺序问题，消除间隙，而方法则是，按照惯例（convention)，当且仅当像素的中心在三角形内，才进行光栅化。</p>
<p><strong>暴力算法（brute force algorithm)</strong></p>
<p>使用中心判断是否光栅化</p>
<p><img src="/2022/11/08/%E8%99%8E%E4%B9%A6/06/uTools_1668001076663.png" alt="uTools_1668001076663"></p>
<h3 id="Dealing-with-Pixels-on-Triangle-Edges"><a href="#Dealing-with-Pixels-on-Triangle-Edges" class="headerlink" title="Dealing with Pixels on Triangle Edges"></a>Dealing with Pixels on Triangle Edges</h3><p>我们还没有讨论如果像素中心在三角形的边缘该怎么办，</p>
<p>根据上面的思路，如果不光栅化，那么势必会小一圈，相邻三角形可能会有一个大的间隙；如果光栅化，相比较前者好一些，但仍有问题：<strong>如果三角形都是transparent的，这将会造成double-coloring</strong>,毕竟本意是半透明，但是却画了两次。</p>
<p><img src="/2022/11/08/%E8%99%8E%E4%B9%A6/06/uTools_1668001688563.png" alt="uTools_1668001688563"></p>
<p>所以我们真的确实需要裁定（award)具体哪一个像素，然后我们希望这个过程能够很简单。</p>
<p>其中一个方法是，标记任意视线之外的点确定为公共边的一侧，并且指定这个边是要绘制的。</p>
<h3 id="Perspective-Correct-Interpolation"><a href="#Perspective-Correct-Interpolation" class="headerlink" title="Perspective Correct Interpolation"></a>Perspective Correct Interpolation</h3><p>当interpolating quantities 插值大量的，例如纹理坐标或者3d坐标等需要在3d三角上线性改变</p>
<p>的数据时</p>
<p>在实现“纠正视觉透视”有一些subtleties(小方法，精妙的细节)</p>
<p>当透视校正很重要时我们会使用纹理坐标作为一种数量的指标（example)</p>
<p>3d空间线性值很重要是，上述考虑也适用于任何参数</p>
<p>事情不会那么简单的原因是，单纯的屏幕空间纹理坐标插值，会导致不正确的图像。如下图</p>
<p><img src="/2022/11/08/%E8%99%8E%E4%B9%A6/06/uTools_1668078483770.png" alt="uTools_1668078483770"></p>
<p><img src="/2022/11/08/%E8%99%8E%E4%B9%A6/06/uTools_1668079789675.png" alt="uTools_1668079789675"></p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要12</title>
    <url>/2022/11/10/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/</url>
    <content><![CDATA[<h1 id="屏幕后处理"><a href="#屏幕后处理" class="headerlink" title="屏幕后处理"></a>屏幕后处理</h1><p>顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。</p>
<p><code>onRenderImage</code>属于抓取屏幕的函数，应用在所有透明和不透明渲染完成后</p>
<h3 id="Unity中实现屏幕后处理"><a href="#Unity中实现屏幕后处理" class="headerlink" title="Unity中实现屏幕后处理"></a>Unity中实现屏幕后处理</h3><p><code>PostEffectsBase.cs </code>用于检验shader和material，并且通过脚本面板更改数据；如果不符合要求，则脚本失效.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先注意</span></span><br><span class="line"><span class="comment">//unity 有三种模式，player mode,edit mode(正常模式)，prefab mode(进入预制体更改)</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResource</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;This platform does not support image effects or render texture....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 如果shader，material同时有效；如果shader有效。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;shader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;material&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有shader就直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material) <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="调整屏幕亮度、饱和度、对比度"><a href="#调整屏幕亮度、饱和度、对比度" class="headerlink" title="调整屏幕亮度、饱和度、对比度"></a>调整屏幕亮度、饱和度、对比度</h4><p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                //Apply Brightness</span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                //Apply Saturation</span><br><span class="line">                fixed luminance= 0.2125 * renderTex.r + 0 . 7154 * renderTex . g + 0.0721 * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation); //饱和度是色彩的鲜艳程度或纯度</span><br><span class="line">                </span><br><span class="line">                //Apply Contrast</span><br><span class="line">                fixed3 avgColor = fixed3(0.5,0.5,0.5);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast);</span><br><span class="line">                </span><br><span class="line">                return fixed4(finalColor,renderTex.a);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>1.直接相乘得到亮度</p>
<p>2.计算亮度值luminance;</p>
<p>3.使用饱和度在上一步颜色和亮度值之间插值</p>
<p>4.对比度类似。</p>
<h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>利用边缘检测算子对图像进行<strong>卷积</strong></p>
<p>如果我们想要对图像进行均值模糊，可以使用一个 3x3 的卷积核，核内每个元素的值均为 1/9。</p>
<p>见P249</p>
<p>在进行边缘检测时，我们需要对每个像素进行卷积计算，有两个方向的梯度。</p>
<p>整体梯度公式为<br>$$<br>G = sqrt(Gx^2 + Gy^2)<br>$$<br>出于性能考虑，一般也用绝对值取代开根号。</p>
<p><strong>使用Sobel算子实现描边</strong></p>
<p><strong>顶点着色器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.uv;</span><br><span class="line">                </span><br><span class="line">                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);</span><br><span class="line">				o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);</span><br><span class="line">				o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);</span><br><span class="line">				o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);</span><br><span class="line">				o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);</span><br><span class="line">				o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);</span><br><span class="line">				o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);</span><br><span class="line">				o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);</span><br><span class="line">				o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>使用Sobel算子采样，并且将采样代码转到顶点着色器，减少运算。并且由于顶点到片元的插值是线性的，所以并不会影响结果。</p>
<p><strong>edge计算</strong></p>
<p>计算9块像素的亮度，并且将水平和竖直方向的对应梯度和计算出来。最后1减去两者绝对值。</p>
<p><em>得到的edge越小，越有可能是边缘</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line">        const half Gx[9] = &#123;-1,  0,  1,</span><br><span class="line">        -2,  0,  2,</span><br><span class="line">        -1,  0,  1&#125;;</span><br><span class="line">        const half Gy[9] = &#123;-1, -2, -1,</span><br><span class="line">        0,  0,  0,</span><br><span class="line">        1,  2,  1&#125;;		</span><br><span class="line">        half texColor;</span><br><span class="line">        half edgeX = 0;</span><br><span class="line">        half edgeY = 0;</span><br><span class="line">        for (int it = 0; it &lt; 9; it++) &#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"></span><br><span class="line">        return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>片元着色器</strong></p>
<p>利用Sobel得到梯度值edge后，分别计算贴图和纯色背景下的颜色值。</p>
<p>最后利用<code>_EdgeOnly</code>在两者之间取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><p>卷积的另一个应用是高斯模糊</p>
<p>见P253</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">			<span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">			RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">			buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">				material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">				RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the vertical pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">				buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the horizontal pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(buffer0, dest);</span><br><span class="line">			RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>详情见P257</p>
<p>使用五个高斯核</p>
<p><strong>注：</strong>使用<code>CGINCLUDE</code>可以将顶点片元着色器包住，达到多个pass使用同一份着色器代码及其声明。</p>
<p>没看懂…….</p>
<h4 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a>Bloom效果</h4><p>根据某个阈值提取出画面中较亮的区域，然后通过高斯模糊，模拟光线扩散的结果。</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Games101 Material_01</title>
    <url>/2022/11/10/Games%E7%B3%BB%E5%88%97/101/Material/</url>
    <content><![CDATA[<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><h2 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse/Lambertian Material"></a>Diffuse/Lambertian Material</h2><p>对半球costheta积分结果是PI</p>
<p>关于这个证明</p>
<p><img src="/2022/11/10/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668081297856.png" alt="uTools_1668081297856"></p>
<p>半球上的立体角定义为覆盖半球表面区域的面积初一半径的平方</p>
<p><img src="/2022/11/10/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668080586079.png" alt="uTools_1668080586079"></p>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
  </entry>
  <entry>
    <title>软链接c盘</title>
    <url>/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/</url>
    <content><![CDATA[<h1 id="软链接c盘"><a href="#软链接c盘" class="headerlink" title="软链接c盘"></a>软链接c盘</h1><p>c盘文件链接到d盘，减小c盘占用<br>将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接<br>mklink /D “C:\Program Files\Adobe” “D:\MySoftware\Adobe”</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
</search>
