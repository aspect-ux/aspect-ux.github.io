<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Rasterization(光栅化)</title>
    <url>/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/</url>
    <content><![CDATA[<h1 id="Rasterization-光栅化"><a href="#Rasterization-光栅化" class="headerlink" title="Rasterization(光栅化)"></a>Rasterization(光栅化)</h1><p>前一节讲了变换（transform),过程总览如下图</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/1.png" class>

<h2 id="光栅化流程"><a href="#光栅化流程" class="headerlink" title="光栅化流程"></a>光栅化流程</h2><p>之前提到了MVP过程，在这之后,所有的物体都会停留在【-1，1】^3</p>
<p>立方体(Canonical Cube)空间中，然后要进行光栅化。</p>
<h3 id="Viewport-Transformation-视口变换"><a href="#Viewport-Transformation-视口变换" class="headerlink" title="Viewport Transformation(视口变换)"></a>Viewport Transformation(视口变换)</h3><p>也就是将物体“画”到屏幕上，这里具体要做的是上图中的viewport mapping</p>
<p><strong>即将【-1，1】拉伸(重映射remapping)到【width,height】的屏幕上</strong></p>
<p>设置什么样的变换矩阵才能变换成功呢？</p>
<p>（其实在半兰伯特光照模型中就有这个思路，先乘以1/2，然后加上1/2，就转换到【0，1】区间了。）</p>
<p>根据这个思路得到转换矩阵</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230523205240615.png" class title="image-20230523205240615">

<p>需要注意：这个变换与z值无关</p>
<h3 id="Rasterizing-triangles-into-pixels"><a href="#Rasterizing-triangles-into-pixels" class="headerlink" title="Rasterizing triangles into pixels"></a>Rasterizing triangles into pixels</h3><p>上面只是说了光栅化是画物体到屏幕，具体来说，物体是由一个又一个多边形构成，最基本的元素是三角形，我们要做的是让这个三角行用像素画出来(或填充)，进而在屏幕上显示。</p>
<p>具体实现算法就是通过遍历像素，判断像素中心是否在三角形内。</p>
<p><strong>如何判断是否在三角形内</strong></p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_2.png" class>

<p>假设从ABC逆时针方向来看，</p>
<p>我们发现一个规律，但凡P点在三角形内，一定满足</p>
<p>n1 = AB x AP</p>
<p>n2 = BC x BP</p>
<p>n3 = CA x CP</p>
<p>三个方向都是朝着纸面向上，也就是说z分量大于0(充要条件),否则，则不在三角形内。</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/homework2_3.png" class title="homework2_3">

<p>这样就可以判断是否在三角形内</p>
<p><strong>另外遍历像素很麻烦，这里引入包围盒(Bounding Box)</strong></p>
<p> 引入axis-aligned bounding box(AABB)轴对齐包围盒</p>
<p>每一行都根据三角形边界用一个包围盒，这样就不会浪费，从而实现光栅化的加速。</p>
<p>但是并不简单。</p>
<p>在这里如果要单纯光栅化一个三角形，我们只知道三个顶点的坐标，这里可以粗略地将三角形用方形框住，只遍历方形中的像素。</p>
<h2 id="光栅化细节之反走样"><a href="#光栅化细节之反走样" class="headerlink" title="光栅化细节之反走样"></a>光栅化细节之反走样</h2><p>如果只是按照上述流程，结果其实并不理想。</p>
<p>最明显的就是，像素是方形，那么填充三角形会产生锯齿Jaggies</p>
<h3 id="Aliasing-走样"><a href="#Aliasing-走样" class="headerlink" title="Aliasing(走样)"></a>Aliasing(走样)</h3><p>sample artifacts,采样所造成的瑕疵</p>
<ul>
<li>Jaggies(锯齿)</li>
<li>Moire (摩尔纹)</li>
<li>Wagon Wheel Illusion(车轮效应) 时间上采样的问题</li>
</ul>
<p>信号变化太快，采样跟不上</p>
<h3 id="如何反走样？-Antialiasing-Ideas"><a href="#如何反走样？-Antialiasing-Ideas" class="headerlink" title="如何反走样？(Antialiasing Ideas)"></a>如何反走样？(Antialiasing Ideas)</h3><h4 id="卷积、时域、频域、空间域和滤波"><a href="#卷积、时域、频域、空间域和滤波" class="headerlink" title="卷积、时域、频域、空间域和滤波"></a>卷积、时域、频域、空间域和滤波</h4><ol>
<li>首先：这里用信号的方式表示反走样如下图，不同的函数，相同的采样点，采样结果却一样，导致不同信号无法区分，于是产生了走样</li>
</ol>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145800199.png" class title="image-20230706145800199">

<ol start="2">
<li><p><strong>反走样的方法是Blurring</strong>：采样前做滤波(pre-filtering)，什么是滤波？抹除特定的频率。</p>
<p>滤波 = 卷积 = 平均，顺序不能反先滤波后采样，不然不过是将走样后的图像再模糊了一下，还是走样的。</p>
</li>
<li><p>什么是卷积、时域、频域？</p>
<p>下图说明了卷积的过程，特定的卷积核对信号本身进行加权操作</p>
</li>
</ol>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706152137019.png" class title="image-20230706152137019">

<ul>
<li><p><strong>时域（time domain）</strong>自变量是时间,即横轴是时间,纵轴是信号的变化。其动态信号x（t）是描述信号在不同时刻取值的函数。</p>
</li>
<li><p><strong>频域（frequency domain）</strong>自变量是频率,即横轴是频率,纵轴是该频率信号的幅度,也就是通常说的频谱图。</p>
</li>
<li><p><strong>空间域(spatial domain)</strong>     简称空域，又称图像空间(image space)，一般这个概念会出现在数字图像处理中，指由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。</p>
</li>
</ul>
<h4 id="Fourier-Transform-傅里叶变换"><a href="#Fourier-Transform-傅里叶变换" class="headerlink" title="Fourier Transform(傅里叶变换)"></a>Fourier Transform(傅里叶变换)</h4><p>傅里叶变换能做什么？将信号从时域转换到频域（对于一张图像，时域指不同空间的信号？；频域指的是信号随频率变化的函数）</p>
<p>傅里叶展开：任何周期函数都可以写成正弦余弦和的函数</p>
<p>傅里叶变换和逆傅里叶变换，将不同的函数之间相互转换</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706145241029.png" class title="image-20230706145241029">

<p>如以下例子</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150533898.png" class title="image-20230706150533898">

<p>首先确定信号变换时一般都是默认为周期性函数，但是对于非周期性的图像，则会水平竖直平铺多张图像，</p>
<p>边界变化剧烈，于是有了两条白线。</p>
<p>任何信号在不同频率的样子叫做频谱。</p>
<p>下图为高通</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706150930320.png" class title="image-20230706150930320">

<p>下图为低通</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151033905.png" class title="image-20230706151033905">

<p>下图为高低频都去掉的结果（中通滤波）</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706151222306.png" class title="image-20230706151222306">

<h4 id="Convolution-Theorem-卷积定理"><a href="#Convolution-Theorem-卷积定理" class="headerlink" title="Convolution Theorem(卷积定理)"></a>Convolution Theorem(卷积定理)</h4><p>spatial domain上的卷积（平均）模糊等价于</p>
<p>frequency domain上的乘积</p>
<p>时域的卷积等于频域的乘积（暂时不清楚spatial domain和time domain的区别）</p>
<p>尤其注意，卷积定理有两个，时域的乘积 也等于 频域的卷积，对偶性（详情查询）</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706153322488.png" class title="image-20230706153322488">

<p>上图的卷积核，也叫做滤波器，由于上图将低频信息保存了下来，也叫做低通滤波器low box filter</p>
<p>越大的box结果越模糊。</p>
<p>走样现象的另一种解释</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706155140903.png" class title="image-20230706155140903">

<p>像素很大，采样很稀疏，频谱密集</p>
<p>采样速度不够快，导致频谱混叠，信息损失，造成走样</p>
<h4 id="归纳反走样或减少走样方法"><a href="#归纳反走样或减少走样方法" class="headerlink" title="归纳反走样或减少走样方法"></a>归纳反走样或减少走样方法</h4><ol>
<li><p>Increase sample rate(reduce aliasing error)</p>
</li>
<li><p>先模糊后反走样，先低通，后采样，高频滤掉，就不会产生重叠；</p>
<p>关键点在于，频谱混叠导致结果失真，但是模糊只会丢掉高频细节。后者显然更好</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706160213696.png" class title="image-20230706160213696"></li>
</ol>
<h3 id="实际应用中的反走样"><a href="#实际应用中的反走样" class="headerlink" title="实际应用中的反走样"></a>实际应用中的反走样</h3><h4 id="MSAA-Multi-Sample-Anti-Aliasing"><a href="#MSAA-Multi-Sample-Anti-Aliasing" class="headerlink" title="MSAA(Multi Sample Anti-Aliasing)"></a>MSAA(Multi Sample Anti-Aliasing)</h4><p>将一个像素分成多个“小像素”</p>
<p>如4x4</p>
<img src="/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/image-20230706161007121.png" class title="image-20230706161007121">



<p>根据小像素覆盖率来进行模糊，这样能够更准确的确定模糊度，然后采样</p>
<p>注意：MSAA并不是通过提高分辨率真的增加”小像素“，只不过是在一个像素里采样若干个点</p>
<p>但是上述例子的代价是增加了4x4共16倍的采样量</p>
<p>另外还有FXAA（后处理，得到锯齿才处理）和TAA等方法</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>Shading(着色)</title>
    <url>/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/</url>
    <content><![CDATA[<h1 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading(着色)"></a>Shading(着色)</h1><h2 id="Visibility-Occulusion-可见性-遮蔽"><a href="#Visibility-Occulusion-可见性-遮蔽" class="headerlink" title="Visibility/Occulusion(可见性/遮蔽)"></a>Visibility/Occulusion(可见性/遮蔽)</h2><p><strong>Painter’s Algorithm</strong> 从后往前画</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711122733524.png" class title="image-20230711122733524">

<p>但是由于自遮挡的关系，有些无法具体描述远近的（如上图左右面的绘制），绘制顺序显得尤为重要。</p>
<p>左，下，右，上，这个顺序结果正确</p>
<p>但是右，上，左，下，由于左下两面的错误遮挡，导致结果错误。</p>
<p>假如一个模型是两个蛇状管道相互缠绕组合而成的，那渲染先后的问题就更加困难，正方体能够区分不同面无非是一个面遮挡另一个，后者不规则的分区有着非单一的复杂遮挡关系，如此看来这种算法局限性也很大</p>
<p><strong>结论：</strong> 一定程度上画家算法是有效的，但是sorting layer的问题是难以解决的。</p>
<p><strong>ZBuffer</strong> 深度缓存</p>
<p>为了解决画家算法的问题，引入深度缓存</p>
<p>简而言之，对每个像素的深度进行保存，保留最近的那个深度值</p>
<ul>
<li>framebuffer存颜色值</li>
<li>depth buffer(z-buffer)存深度值</li>
</ul>
<p>效果如下图，记z值为positive</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711125920188.png" class title="image-20230711125920188">

<p>具体代码实现算法，记初始zbuffer的值都是无限大，每绘制一个图元都来一次二重循环遍历所有像素，不断装填覆盖更小的z</p>
<p>时间复杂度O(n),设三角形个数为n,三角形之间覆盖的个数为常数个。</p>
<p>zbuffer的算法显然是一个很好的解决方法。</p>
<p>【提高】</p>
<p>MSAA常用于反走样，一个像素中有多个采样点，然后根据采样点的分布率来评判该像素颜色深浅</p>
<p>如果绘制有重叠部分的两个三角形，对于抗锯齿的部分，如果只是对像素进行z-buffer，然后边缘锯齿用MSAA,</p>
<p>结果也还行。</p>
<p>想要更好的结果，我们也许可以对采样点进行zbuffer,毕竟像素是呆板的块状，如果能够进一步细化，或许分布率不会变，却也能让先后关系更精确，进而结果更精确。</p>
<h2 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination&amp;Shading"></a>Illumination&amp;Shading</h2><p><strong>BlinnPhong Model</strong></p>
<p>布林冯光照模型</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711133718085.png" class title="image-20230711133718085">

<p>三个相加等于着色结果</p>
<p>着色是局部的</p>
<p><strong>着色不等于阴影（shading != shadow)</strong></p>
<p>n是法线向量，h是半程向量（入射光向量l与眼睛视线向量v的和的单位向量）</p>
<p>以下为布林冯的高光</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711140322707.png" class title="image-20230711140322707">

<p>最终结果</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711141207203.png" class title="image-20230711141207203">



<p><strong>Shading Frequency</strong> 着色频率问题</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230711142158445.png" class title="image-20230711142158445">

<h2 id="Graphics-Pipeline-Real-time-rendering"><a href="#Graphics-Pipeline-Real-time-rendering" class="headerlink" title="Graphics Pipeline(Real-time rendering)"></a>Graphics Pipeline(Real-time rendering)</h2><p>图形渲染管线，实时渲染管线</p>
<p>Application 应用阶段，输入顶点数据</p>
<p>Geometry 几何阶段</p>
<p>Rasterization 光栅化阶段</p>
<ul>
<li><p>Shading 着色（shaded fragment)</p>
</li>
<li><p>framebuffer （严格来说属于光栅化）</p>
</li>
</ul>
<p>输出屏幕</p>
<p>除了常规的fragment shader,vertex shader</p>
<p>现在还有compute shader(通用)，geometry shader(几何shader)等可编程部分</p>
<h2 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h2><p>每个三角形顶点都有一个uv坐标（0，1），可以反复平铺</p>
<h3 id="Barycentric-coordinates-重心坐标"><a href="#Barycentric-coordinates-重心坐标" class="headerlink" title="Barycentric coordinates(重心坐标)"></a>Barycentric coordinates(重心坐标)</h3><p><strong>【注意】</strong> 我们首先要区别点的重心坐标和三角形的重心坐标</p>
<p>interporate across triangle在三角形内进行插值，希望三角形内部得到平滑过渡</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712105733661.png" class title="image-20230712105733661">

<p>α，β，γ均大于等于0，重心在三角形内</p>
<p>A点在重心坐标系的重心坐标（α，β，γ）为（1，0，0），B为（0，1，0）</p>
<p>三角形的重心坐标计算公式就是相加除以3，重心坐标为（A.x+B.x+C.x/3，A.y+B.y+C.y/3，A.z+B.z+C.z/3）</p>
<p>三角形内任意一点的重心坐标计算结论如下</p>
<p><strong>结论</strong></p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712110740529.png" class title="image-20230712110740529">

<p>【补充】</p>
<ul>
<li>α+β+γ = 1，是重心坐标的性质，同时是重心坐标在ABC平面上的要求</li>
<li>三维中的属性在三维中做插值，否则投影到屏幕再做可能会因为重心不一致而错误；</li>
</ul>
<h3 id="Texture-queries"><a href="#Texture-queries" class="headerlink" title="Texture queries"></a>Texture queries</h3><p>a pixel on a texture is a texel(纹素)</p>
<p>texture mapping简单应用：通过查uv来将纹理的值作为Diffuse Color</p>
<p>纹理太小，采样后会被拉大texture magnification</p>
<p>最后结果不精确，得到的会是明显的像素块的非连续结果</p>
<p><strong>解决方法：</strong>纹素，屏幕分辨率差别大，texture queries的时候，用屏幕像素坐标查询texture的uv,</p>
<p>使用双线性插值（Bilinear Interpolation) 来解决非连续的问题。</p>
<p>水平、竖直都进行下述插值操作，对texel的4个像素进行插值</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712134134465.png" class title="image-20230712134134465">



<p>另有Bicubic的方法，取周围16个像素</p>
<p><strong>1. Point Sample problem</strong></p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712175243366.png" class title="image-20230712175243366">

<p>采样纹理的时候为什么会出现这样的走样（artifact)？</p>
<p>当纹理特别大，哪怕一个纹素也包括了很多高频信息，人眼跟不上变化频率，于是产生了走样。</p>
<p>或者，texture queries 的时候，采样一个像素的时候只使用一个采样点，采样频率不够，导致最后结果表现不够精确连续。</p>
<p>增加采样点虽然理论可行，但是计算量太大。</p>
<p><strong>2. Range Query Problem</strong></p>
<p>范围查询不像点查询一样进行采样，而是直接查询一个范围的结果，这样就避免了上述的计算量。</p>
<p>范围查询根据功能可以分为平均，最大，最小….很多种不同类的方式。</p>
<p>引入<strong>Mipmap</strong>的概念，(fast,approximate,square)，分为多级，分辨率逐级减半，D = log(L)</p>
<p>使用mipmap比原来多用了1/3的空间存储</p>
<p>如何使用mipmap?</p>
<p>离人眼近的地方，使用低级别的，分辨率更高的，离人眼远的地方，对精度要求低，可以用分辨率更低的mipmap。</p>
<p>【注】实际操作中，由于mipmap本身是方块，查询方式离散，层与层之间还需再进行插值。本身xy两轴上分别做了插值让纹理适配原像素，然后又在层与层直接插值，称之为三线性插值（trilinear interpolation)</p>
<p><strong>3. mipmap limitation &amp; Anisotropic Filter</strong></p>
<p>mipmap远处会出现<strong>过度模糊</strong>的问题，</p>
<p>问题在哪？其实还是出在三线性插值上，之前提到mipmap的approximate的特性，本身插值方法就是人为近似的，而且又只能处理方形区域的查询。</p>
<p>引入效果更好的方法。</p>
<p>Anisotropic Filter各向异性过滤（ripmap)</p>
<p>游戏中2x指的是左上角两层的范围，存储量收敛到原来的3倍，游戏中一般都可以开到最高，对性能不会有任何影响。</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193451568.png" class title="image-20230712193451568">

<p>这种方法由于x,y方向都有拉伸，查询不局限于方形，扩展到矩形</p>
<p><strong>但是</strong>如下图，screen上的一块像素表达的内容在texture上也许是斜着的，使用各向异性查询，就要求将整块斜块用矩形包围，最后结果overblur。irregular footprint（覆盖区） in texture的问题</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712193630633.png" class title="image-20230712193630633">

<p>竖着的长条可以解决，但是斜着的就不好解决。</p>
<p><strong>EWA filtering</strong></p>
<p>将查询范围用多个圆包围，多次查询</p>
<p>可以处理不规则图形，但是计算量很大</p>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230712195236130.png" class title="image-20230712195236130">

<h3 id="Application-of-textures"><a href="#Application-of-textures" class="headerlink" title="Application of textures"></a>Application of textures</h3><p>现代GPU中，texture = memory + range query(filtering)</p>
<ol>
<li><p>Environment Map 环境贴图，物体反射周围的光;描述不同方向的光照信息。</p>
<p>Shperical Map,发生扭曲；Cube Map</p>
</li>
<li><p>Bump/Normal Map</p>
<p>凹凸贴图如何绘制法线制造凹凸感？</p>
<ul>
<li>设原来法线为（0，0，1）</li>
<li>求偏导（derivatives),假设u,v变化单位1</li>
</ul>
<img src="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Shading/image-20230713090701583.png" class title="image-20230713090701583">

<p>切线逆时针旋转90度得到法线</p>
<p>得到法线（-dp/du,-dp/dv,1)</p>
<p>这样，通过凹凸贴图的纹理映射，制造假的法线，实现结果的凹凸。</p>
</li>
<li><p>Displacement Map,位移贴图，真正的移动了原模型，不同于凹凸贴图。</p>
<p>要求三角形很细，三角形的频率要比纹理高；采样率高，模型足够细致</p>
<p>DX上有一个方法叫动态细分，即便是模型不是很精细，但是可以根据需要进行选择性移动</p>
</li>
</ol>
<p>其它</p>
<p><strong>Provide Precompute shading</strong></p>
<p><strong>3d textures and volume rendering</strong></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>Transformation(变换)</title>
    <url>/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/</url>
    <content><![CDATA[<h1 id="Transformation-变换"><a href="#Transformation-变换" class="headerlink" title="Transformation(变换)"></a>Transformation(变换)</h1><h2 id="变换的数学意义-介绍"><a href="#变换的数学意义-介绍" class="headerlink" title="变换的数学意义(介绍)"></a>变换的数学意义(介绍)</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation"></a>Why Transformation</h3><p><strong>Q1： 为什么要学习变换呢？</strong></p>
<p>A1： 动画的实现，光栅化图像变换投射进“人眼”。由于计算机最终的变换服务于数学世界，于是同一用矩阵来表示变换，线性代数中学过对应知识。</p>
<p><strong>Q2: 举例有哪些变换？</strong></p>
<p>A2： Scale Matrix，缩放；Reflection Matrix,对称(镜像)；</p>
<p>Shear Matrix,切变(有称”错切“，”斜切“)；</p>
<p>Rotate Matrix…</p>
<p>旋转矩阵推导</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/推导旋转矩阵.jpg" alt="image-20230518004250114" style="zoom: 67%;">

<p>到目前为止的变换，我们都可以对(x,y…)进行线性变换(Liner transformation)得到变换结果(x’,y’)</p>
<p><strong>但是平移变换不行？</strong></p>
<p>试想一下，如果对x平移一个单位，那么变换矩阵</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/平移变换.jpg" alt="image-20230518005707401" style="zoom:80%;">

<p>无法用一个矩阵就解决变换，（上面的变换形式引出仿射变换(Affine Transformation)的概念），同时进行线性和平移变换</p>
<p>接下来</p>
<h3 id="Homogeneous-coordinates-齐次坐标"><a href="#Homogeneous-coordinates-齐次坐标" class="headerlink" title="Homogeneous coordinates(齐次坐标)"></a>Homogeneous coordinates(齐次坐标)</h3><p>要想用一个矩阵表示所有变换</p>
<p>这里引入了齐次坐标的概念，以二维举例，引入第三维度</p>
<p>设点的第三维度为1，向量为0.</p>
<ul>
<li>之所以向量为0，是因为向量具有方向不变性，假设进行平移变换，我们希望这个向量前后不变的；但是如果但三维度不是0，那么结果就有可能出现向量方向的变化。</li>
<li>之所以点为1，是因为这样就解决了<strong>平移问题</strong>，通过增加维度，使得一个矩阵同时表示平移和线性变换。</li>
</ul>
<p>另外</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/%E7%82%B9%E4%B8%8E%E5%90%91%E9%87%8F%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="image-20230518012256246">

<p>在齐次坐标系下，不难推导出，点+点等于中点，只需同时除以w=2,使得w回归为1</p>
<p>最后放一张仿射变换的图片和常见变换公式的图片</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/affineTransformation.png" class title="image-20230518012637415">



<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518013201379.png" class title="image-20230518013201379">

<h3 id="Composing-Transform-变换组合"><a href="#Composing-Transform-变换组合" class="headerlink" title="Composing Transform(变换组合)"></a>Composing Transform(变换组合)</h3><ul>
<li><p>我们需要知道，复杂的一连串的变换是可以组合的，因为虽然变换越多，矩阵越多，但是由于都是乘法，根据矩阵结合律可以最终合成一个</p>
</li>
<li><p>平移和旋转具有严格先后顺序，毕竟先加后乘，与先乘后加结果不一样；具体来说是先乘后加，先变换后平移</p>
</li>
</ul>
<p><strong>Decomposing complex transform(解构复杂变换)</strong></p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518014414740.png" class title="image-20230518014414740">

<p>由图知，直接从图一到图四其实并不方便。</p>
<p>我们先把物体的旋转中心移平移回原点，然后旋转，最后平移回去。（因为我们只能做原点为旋转中心的旋转，不然就无法用之前的固定结论）。</p>
<p><strong>如果不以原点为旋转中心，以某个轴为旋转中心轴</strong></p>
<p>绕z轴旋转(本来二维的扩展成三维后等价绕z轴旋转)</p>
<ul>
<li>绕哪个轴，哪个轴的坐标为位置不变</li>
</ul>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518205820940.png" class title="image-20230518205820940">

<p><strong>拓展到3d transformation也是一样</strong></p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518210227508.png" class title="image-20230518210227508">

<p><strong>ps:</strong> 按照直觉可能会觉得绕y轴的旋转矩阵有问题，其实是因为该图表示的是右手坐标系的变换；已知<code>x.crossproduct(z) = -z.crossproduct(x)</code>(右手法则)，这里XxZ = -Y,所以需要对α取反。</p>
<p><strong>Rodrigues’s Rotation Formula</strong></p>
<p>描述了绕任意轴旋转任意角度的变换矩阵</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230518213219770.png" class title="image-20230518213219770">

<p>下面来推导一下这个公式同时引入四元数的学习</p>
<p>参考：<a href="https://www.zhihu.com/tardis/zm/art/78987582?source_id=1005">四元数和旋转(Quaternion &amp; rotation) (zhihu.com)</a></p>
<p>前提：axis n是一个单位向量，并且n过原点(如果不过原点，参考前面的方法先平移回原点)</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230520235749777.png" class title="image-20230520235749777">

<p><strong>有关四元数</strong></p>
<p>定义：</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230521000033200.png" class title="image-20230521000033200">

<h2 id="MVP-Transformation（实际操作）"><a href="#MVP-Transformation（实际操作）" class="headerlink" title="MVP Transformation（实际操作）"></a>MVP Transformation（实际操作）</h2><p>拍照过程</p>
<ol>
<li>摆放好待拍摄的物品，或者人物。（model transformation)</li>
<li>调整好拍摄(相机)角度。(view transformation)</li>
<li>调整焦距,拍摄。(projection transformation)</li>
</ol>
<p>也就是常说的MVP变换</p>
<p><strong>这里Viewing Transformation包括了View Transformation(视图变换)和Projection Transformation(投影变换)</strong></p>
<h3 id="View-Camera-Transformation-视图变换"><a href="#View-Camera-Transformation-视图变换" class="headerlink" title="View/Camera Transformation(视图变换)"></a>View/Camera Transformation(视图变换)</h3><p>视图变换就是把相机放好。把相机移回原点，相机的三个向量分别和世界坐标的三个轴对齐。先平移后旋转</p>
<ul>
<li>平移回原点</li>
<li>旋转对齐轴</li>
</ul>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523214954945.png" class title="image-20230523214954945">

<p>平移矩阵很好得到</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215056433.png" class title="image-20230523215056433">

<p>然后是旋转矩阵</p>
<p>但是要想将相机三向量t,g,x转换到世界坐标轴XYZ(单位向量)上，其实不好算，所以这里反过来算</p>
<p>所以首先明确目标矩阵(1 0 0 0；0 1 0 0； 0 0 1 0； 0 0 0 1)，由于反过来算，所以变成了起始矩阵</p>
<p><strong>细节:</strong> g to -Z,相机对准Z的负方向，t to Y, gxt to X，x由g、t叉乘得到</p>
<p>R(view)的逆矩阵很好得到，毕竟（0，0，1）旋转到一个位置很好做</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523215450184.png" class title="image-20230523215450184">

<p>至此实现了从世界坐标轴到相机坐标轴的旋转，只要额外再取个逆，就能得到R(view)</p>
<h3 id="Projection-Transformation"><a href="#Projection-Transformation" class="headerlink" title="Projection Transformation"></a>Projection Transformation</h3><h4 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h4><p>正交投影假设物体和相机无限远，这样物体通过视锥体投影到相机没有近大远小</p>
<p>以下这张图解释了这个过程(<strong>先平移后缩放</strong>)</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523221856008.png" class title="image-20230523221856008">

<p><strong>注意：这里是右手系，相机往-z方向看</strong>，OpenGL就是右手坐标系。</p>
<p>但是unity 和 dx都是左手坐标系</p>
<p>再这样的前提下|f|要比|n|要小</p>
<p>由此得到正交变换的变换矩阵</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523222223893.png" class title="image-20230523222223893">

<p>如何理解r,l,b,n,f,t这些东西，可以理解成物体左右上下前后的“坐标”，</p>
<p>平移矩阵好理解，缩放矩阵本质上是用【2/左右距离】作为缩放倍数，最后结果为2，使得物体缩放到【-1，1】的cube中。</p>
<p>至此正交投影结束</p>
<h4 id="Perspective-projection"><a href="#Perspective-projection" class="headerlink" title="Perspective projection"></a>Perspective projection</h4><p>视锥体原平面投影到近平面就能产生透视效果</p>
<p><strong>这里做透视投影的过程是，先将视锥体squish(挤)成cuboid(长方体）再做正交投影</strong></p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224143182.png" class title="image-20230523224143182">

<p>由远近平面的关系，我们可以根据相似三角形得到比例关系</p>
<p><code>y&#39; = (n/z)y</code></p>
<p>首先明确我们的目标是将(x,y,z)变换到(x’,y’,z’)</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523224929643.png" class title="image-20230523224929643">

<p>进而在齐次坐标上是</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225031775.png" class title="image-20230523225031775">

<p>从透视投影到正交投影的矩阵可以写成</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225322150.png" class title="image-20230523225322150">

<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523225545132.png" class title="image-20230523225545132">

<p>这里我们要具体推导一下第三行的值</p>
<p>本质上就是用远近平面上的点带入，完成二元方程组，进而推导出第三行</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233910281.png" class title="image-20230523233910281">

<p>最后合成透视矩阵</p>
<img src="/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/image-20230523233933492.png" class title="image-20230523233933492">

<p>推导结束</p>
<p>至此，坐标被变换到了Clip Space(裁剪空间)，也称作Projection Space(投影空间)</p>
<p>这块空间用于裁剪掉不需要的内容，使用视锥体（view frustum)</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio下Cpp的配置</title>
    <url>/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/</url>
    <content><![CDATA[<h1 id="VS-CPP-配置"><a href="#VS-CPP-配置" class="headerlink" title="VS CPP 配置"></a>VS CPP 配置</h1><p>在VS上编写cpp程序时，经常出现少了xx库或者xx undefined</p>
<p>分为静态和动态配置方法</p>
<ol>
<li><p>下载对应资源包</p>
</li>
<li><p>认识配置方法</p>
</li>
</ol>
<p>属性面板有三个选项，</p>
<img src="/2023/05/24/%E9%9A%8F%E8%AE%B0/VSCppConfig/1.png" class title="image-20230524142140450">

<p><strong>动态载入：</strong> ①对于下载的include 在”C/C++”下配置；②lib在linker下配置，具体lib文件在linker-&gt;input下配置；③dll一般放在根目录（或者32dll放在sysWOW64,64dll放在system32下）</p>
<p><strong>静态载入：</strong> 前两步和之前一样，但是第三步变成在linker-&gt;proprocessor中加入对应宏</p>
<p>注意对应版本文件夹</p>
<h2 id="常用文件解释"><a href="#常用文件解释" class="headerlink" title="常用文件解释"></a>常用文件解释</h2><p><strong>bin文件夹</strong></p>
<p>放置二进制文件，也即可执行二进制文件</p>
<p><strong>.lib文件和.dll文件</strong></p>
<p>在了解”.lib”文件之前，我们得清楚几个点</p>
<p>①首先，程序编译和运行是两个过程</p>
<p>②其次，语言分两种，编译型语言和解释型语言：<br>a.编译型语言里程序执行一般是有编译-&gt;链接这两个过程的<br>b.解释型语言没有这两个过程，你可以说没有链接过程，也可以说随时都在链接</p>
<p>③大家看到的静态链接、动态链接实际都发生在编译阶段！</p>
<p>④链接简单来说就是把编译的代码里的对象符号与软件、库中的对象关联的过程</p>
<p>lib文件是静态链接库文件，其中存放的是函数调用的信息，在windows操作系统中起到链接程序和函数的作用。其意义在于代码重用，程序员将常用的功能写成函数，保存为lib文件，在以后编程要实现这些功能的时候，就不需要再重新编写代码，而是直接调用写好的lib文件，这很大程度上减轻程序员的负担。</p>
<p>dll文件是动态链接库文件，你可以简单的把DLL看成一种仓库，它提供给你一些可以直接拿来用的变量、函数或类。</p>
<p>对于动态链接，其在运行时，会由操作系统动态加载所需的库<br>动态链接和静态链接主要区别就是加载过程</p>
<p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib中的指令都被直接包含在最终生成的EXE文件中了。但是若使用DLL，该DLL不必被包含在最终EXE文件中，EXE文件执行时可以“动态”地引用和卸载这个与EXE独立的DLL文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始的图形学</title>
    <url>/2023/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于实在觉得有必要细致、全面、通透地学习一遍图形学相关基础理论知识，于是开了这个坑。</p>
<p>但是，就我个人而言，该系列不会局限单纯的理论。目前的想法是，除开基础理论推导</p>
<ul>
<li><p>会添加一些引擎中的原理和实现，games系列闫令琪老师101，202的作业，以及流行图形API规范如OpenGL的理论实践。</p>
</li>
<li><p>同时PBR,RTR等图形学进阶书籍阅读笔记也可能会不定期更新。</p>
</li>
</ul>
<p>总的来说，理论性会更强，实验性的记录和学习也会占相当一部分，包罗图形学及其相关应用。个人的意义算是这个方向的<strong>笔记或“个人百科全书”</strong>。后续也会不断完善。</p>
<h2 id="Overview-of-Computer-Graphics"><a href="#Overview-of-Computer-Graphics" class="headerlink" title="Overview of Computer Graphics"></a>Overview of Computer Graphics</h2><p>这里借games101开个头</p>
<h3 id="Why-Study-CG"><a href="#Why-Study-CG" class="headerlink" title="Why Study CG"></a>Why Study CG</h3><ul>
<li><p>Fundamental Intellectual Challenges: </p>
<ul>
<li>Creates and interacts with realistic virtual world(与虚拟交互)</li>
<li>Require understanding of all aspects of physical world(了解物理世界)</li>
<li>New computing methods,displays,technologies(新技术，方法)</li>
</ul>
</li>
<li><p>Technical Challenges:</p>
<ul>
<li>Math of(perspective) projections,curves,surfaces(数学)</li>
<li>Physics of lighting and shading(物理)</li>
<li>Representing / operating shapes in 3D(图形/3d)</li>
<li>Animation / simulation(动画/模拟)</li>
<li>3D graphics software programming and hardware(3d编程/硬件)</li>
</ul>
</li>
<li><p>Forget about the previous reason: <strong>Graphics is awesome!</strong></p>
</li>
</ul>
<p><strong>总而言之，图形学真的很有趣！！！</strong></p>
<h3 id="What-will-be-in-the-corner"><a href="#What-will-be-in-the-corner" class="headerlink" title="What will be in the corner"></a>What will be in the corner</h3><ul>
<li><p>Mathematics theories</p>
</li>
<li><p>Rasterization</p>
</li>
<li><p>Curves and Meshes</p>
</li>
<li><p>Ray Tracing</p>
<p>and so on…</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>搭建静态网页</title>
    <url>/2022/10/21/%E9%9A%8F%E8%AE%B0/buildWebsiteBasedonGithub/</url>
    <content><![CDATA[<h1 id="搭建静态网页"><a href="#搭建静态网页" class="headerlink" title="搭建静态网页"></a>搭建静态网页</h1><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><ul>
<li><p>创建仓库,命名为<code>aspect-ux.github.io</code>,找到Pages,发现site 是显示了。</p>
</li>
<li><p>安装node.js 参考<a href="https://blog.csdn.net/chanyeolchichi/article/details/121348541">(26条消息) Node.js详细安装教程（2021）_cheerileeyoki的博客-CSDN博客_node安装教程</a></p>
</li>
<li><p>安装hexo,报错有可能是权限，删去c盘下的.npmrc???</p>
<p>大抵是nodejs版本太高了</p>
<p>主要参考<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?from=search&seid=6808372371406518307&vd_source=2b3a7e4dffb44c07076538fe075cb1cf">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>
</li>
<li><p>配置<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> 		<span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">		<span class="attr">repo:</span> <span class="string">https://github.com/aspect-ux/aspect-ux.github.io.git</span></span><br><span class="line"> 		<span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后</p>
<ul>
<li><p>更改主题git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia </p>
<p>更改yml文件</p>
<p>主题配置参照：<a href="https://blog.csdn.net/wugenqiang/article/details/88373990">(26条消息) 使用 Github 空间搭建 Hexo 技术博客——使用NexT优化博客（五）_WuGenQiang的博客-CSDN博客</a></p>
</li>
</ul>
<p>hexo c<br>hexo g<br>hexo d</p>
<ul>
<li><p>值得注意的是，传统的markdown语法无法显示图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: false` 修改为 `post_asset_folder: true</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>最后需要新建与文章同名的文件夹存放图片</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title>Event System</title>
    <url>/2022/11/06/naive/Unity/EventSystem/</url>
    <content><![CDATA[<h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>两个文件</p>
<p><a href="EventSystem/01/EventManager.cs">EventManager</a></p>
<p><a href="EventSystem/01/IEventListener.cs">EventManager</a></p>
<p><strong>用法</strong></p>
<ul>
<li>使用<code>interface IEventListener</code>注册事件，卸载事件</li>
<li>注册具体方法使用<code>AddEventListener</code>,卸载使用<code>RemoveEventListener</code></li>
<li>如果需要传多个参数，需要适当更新文件具体代码</li>
</ul>
<p><strong>综述</strong></p>
<p>一件事情会有可能会有许多反馈，每当我们要检测一个事件，首先注册这个事件，不断+=添加方法（反馈）,这些都在start(awake)之类中进行，等到游戏结束再取消订阅。</p>
<ul>
<li>包含一个<code>static EventManager instance;</code>单一实例并用于外部访问成员数据和方法</li>
<li>包含一个<code>interface IEventInfo</code>用于外部多态地实现方法</li>
<li>包含一个字典<code>Dictionary&lt;string,IEventInfo&gt; actionDic</code> 用于存储事件，可以理解成”事件池”</li>
<li>包含类<code>EventInfo&lt;T&gt;</code>继承自上述接口，用于添加单参数方法</li>
<li>包含添加、移除、触发事件</li>
</ul>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>文件</p>
<p><a href="EventSystem/02/EventHandler.cs">EventHandler</a></p>
<p>原理与方法一是一样的，使用方法也大差不差。</p>
<p>方法一将事件加入字典，不用每次添加都往一个文件里跑，并且结构也清晰一些。</p>
<p>方法二代码量相对少？好像也没少…。</p>
]]></content>
      <categories>
        <category>Game system with uniy</category>
      </categories>
  </entry>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2022/10/21/%E9%9A%8F%E8%AE%B0/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/21/%E9%9A%8F%E8%AE%B0/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>软链接c盘</title>
    <url>/2022/11/12/%E9%9A%8F%E8%AE%B0/%E8%BD%AF%E9%93%BE%E6%8E%A5c%E7%9B%98/</url>
    <content><![CDATA[<h1 id="软链接c盘"><a href="#软链接c盘" class="headerlink" title="软链接c盘"></a>软链接c盘</h1><p>c盘文件链接到d盘，减小c盘占用<br>将指定文件夹Adobe剪切_到d盘，管理员身份打开cmd，输入以下软链接<br>mklink /D “C:\Program Files\Adobe” “D:\MySoftware\Adobe”</p>
<h1 id="Unity-Cache"><a href="#Unity-Cache" class="headerlink" title="Unity Cache"></a>Unity Cache</h1><p>参考<a href="https://blog.csdn.net/baidu_39447417/article/details/117829765">(36条消息) 修改Unity的Cache缓存位置_GA博客的博客-CSDN博客_unity缓存</a></p>
<h1 id="SP字体太小"><a href="#SP字体太小" class="headerlink" title="SP字体太小"></a>SP字体太小</h1><p>QT_SCALE_FACTOR 1.3  用户变量</p>
<p>但是有副作用</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 01</title>
    <url>/2022/10/27/naive/%E8%99%8E%E4%B9%A6/01/</url>
    <content><![CDATA[<h1 id="Computer-Graphics-01"><a href="#Computer-Graphics-01" class="headerlink" title="Computer Graphics 01"></a>Computer Graphics 01</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p><code>However, for the foreseeable future, a good heuristic is that programmers</code></p>
<p><code>should pay more attention to memory access patterns than to operation counts.</code></p>
<p>因为内存的速度跟不上处理器的速度</p>
<h2 id="Miscellaneous-Math"><a href="#Miscellaneous-Math" class="headerlink" title="Miscellaneous Math"></a>Miscellaneous Math</h2><p>2.1 集合和映射</p>
<p>2.2 解决二次等式</p>
<p>2.3 三角学（trigonometry) 勾股，三角函数，角</p>
<p>…</p>
<p>2.4.4 叉乘（cross product)</p>
<p><strong>a</strong> x <strong>b</strong> = |ab| sin (theta)</p>
<p>…</p>
<h4 id="Curve-and-Surface"><a href="#Curve-and-Surface" class="headerlink" title="Curve and Surface"></a>Curve and Surface</h4><p>从1d 到3d的积分，参数方程</p>
<h4 id="Linear-Interpolation"><a href="#Linear-Interpolation" class="headerlink" title="Linear Interpolation"></a>Linear Interpolation</h4><p><code>p = (1 - t)a + tb</code></p>
<p>barycentric 重心坐标</p>
<p>cardinality 集合基数</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 03</title>
    <url>/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/</url>
    <content><![CDATA[<h1 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h1><p><strong>Why Ray Tracing?</strong></p>
<ul>
<li>rasterization : real-time,ray tracing: offline</li>
<li>ray tracing is accurate,but is very slow</li>
</ul>
<p><strong>Whitted-Style Ray Tracing</strong></p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667388590899.png" class title="uTools_1667388590899">

<p>渲染3d物体时计算机图形的工作之一。</p>
<p>同一场景的物体渲染需要考虑每个物体贡献的像素。</p>
<p>有两种常规的方法来考虑</p>
<ul>
<li>object-order rendering ,通过找物体来计算对应像素</li>
<li>image-order rendering，通过找像素来判断物体，然后计算像素</li>
</ul>
<p>差别可以这么来看</p>
<p>前者双重循环外循环是物体，后者则是像素</p>
<p>宽泛来说，image-order rendering 是更加简单和灵活的，一般来说也会有更长的执行事件来制造同样的图片。</p>
<p><strong>Ray Tracing 就是image-order algorithm</strong>因为这样不需要像前者一样用数学器械就能实现光线追踪器。</p>
<h2 id="The-Basic-Ray-Tracing-Algorithm"><a href="#The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="The Basic Ray-Tracing Algorithm"></a>The Basic Ray-Tracing Algorithm</h2><p>基本的光线追踪器有三个部分</p>
<p>某种意义上，在引擎中，可以认为“眼睛发光”</p>
<ol>
<li><p>ray generation. 计算每个像素的view射线的来源和方向</p>
</li>
<li><p>ray intersection. 计算与view射线相交的最近物体</p>
</li>
<li><p>shading. 在原有的射线相交的基础上进行着色</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667218571247.png" class title="uTools_1667218571247"></li>
</ol>
<h2 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h2><p>标准的方法来为计算机图形，艺术和照片制作图片，是使用linear perspective(线性透视)</p>
<p>parallel projection(平行投影)是最简单的投影方式，平移。一般用于机械和建筑</p>
<p>如果image plane和视线方向垂直，成为orthograph(正交投影)  orthonormal(正交的)</p>
<h2 id="Compute-View-Ray"><a href="#Compute-View-Ray" class="headerlink" title="Compute View Ray"></a>Compute View Ray</h2><p>phase 1</p>
<p>为了生成ray,我们首先需要一个数学表达</p>
<p><code>p(t) = e + t(s- e)</code></p>
<p>e is eye,    s is image plane point</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667219704846.png" class title="uTools_1667219704846">

<p>在代码中</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667219881824.png" class title="uTools_1667219881824">

<p>详情见P84</p>
<h3 id="Orthographic-Views"><a href="#Orthographic-Views" class="headerlink" title="Orthographic Views"></a>Orthographic Views</h3><p>对于正交投影view ray,</p>
<p>ray generation 使用相机的框架，</p>
<ol>
<li><p>正交投影从image plane的一个像素的位置开始，并且全部共享相同的方向—-view direction.</p>
</li>
<li><p>而透视投影则是选择一个view point 开始，方向则是view point 到image plane的点的位置。</p>
</li>
</ol>
<p><strong>要将nx  ny 的像素投射到(r - l) x (t - b)的矩形上</strong></p>
<p>其中l,r分别是片元，pixel的左右边界坐标，b和t则是下、上边界坐标</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667220608282.png" class title="uTools_1667220608282">

<p>详情见P86</p>
<h3 id="Perspective-Views"><a href="#Perspective-Views" class="headerlink" title="Perspective Views"></a>Perspective Views</h3><h2 id="Ray-Object-Intersection"><a href="#Ray-Object-Intersection" class="headerlink" title="Ray-Object Intersection"></a>Ray-Object Intersection</h2><p>phase 2</p>
<h3 id="Ray-Sphere-Intersection"><a href="#Ray-Sphere-Intersection" class="headerlink" title="Ray-Sphere Intersection"></a>Ray-Sphere Intersection</h3><p>使用implicit surface</p>
<p>隐式表达式f(p(t)) = 0或者f(e + td) = 0</p>
<p>对于一个球来说，设中心点为c</p>
<p><code>(p - c)(p - c) - R^2 = 0</code></p>
<p><strong>注意，当满足上式，说明p对应的点已经在球上，也即intersection</strong></p>
<p><code>(e + t d - c)(e + td - c) - R^2 = 0</code></p>
<p>只有t未知</p>
<p>展开得到quadratic 二次方程，判别式b^2 - 4ac</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667222501427.png" class title="uTools_1667222501427">

<h2 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h2><p>Here we will discuss how a ray tracer computes the inputs to shading</p>
<p>1.从点光源和直线光计算着色需要具体的几何信息。当viewing ray 确定与表面相交，我们需要决定以下4个向量。</p>
<ul>
<li>着色点x可以通过估算viewing ray 以t的值相交</li>
<li>表面的法线向量n</li>
<li>光源方向l</li>
<li>视觉射线viewing direction 是viewing ray的反方向（v = -d/|d|)</li>
</ul>
<p>2.coding</p>
<p>3.一旦你已经在光线追踪器上有基本的着色后，光线和点阴影添加会很容易</p>
<img src="/2022/10/31/naive/%E8%99%8E%E4%B9%A6/03/uTools_1667389464606.png" class title="uTools_1667389464606">

<p>使用directional light 的阴影与点光源类似，但是t=无穷，也即距离无穷，环境光不进行阴影测试（shadow test)</p>
<p>4.Mirror Reflection(镜面反射)</p>
<p>为光线追踪程序添加镜面发射（or specular reflection) 很直接。</p>
<p>由视线计算反射光向量，<strong>易得</strong></p>
<p><code>r = d - 2(d*n)*n</code></p>
<p>其中r是反射向量，d是view(视线)入射的向量</p>
<p><strong>在现实世界中，当光线从表面反射出去，一定会有能量损失</strong></p>
<p>由于光线颜色不同，损失也会不一样，这里使用递归算法(recursive)</p>
<p>调用shader-ray函数。</p>
<p><code>color c = c + k * shader-ray(Ray(p,r),t,infinity)</code></p>
<p>k是specular rgb color, 并且t = infinity,和shadow一样。因为并不想让光线反射到光源上</p>
<h2 id="Frequently-Asked"><a href="#Frequently-Asked" class="headerlink" title="Frequently Asked"></a>Frequently Asked</h2><ul>
<li><p>为什么ray tracing 中没有透视矩阵</p>
</li>
<li><p>可以实现交互式光线追踪吗</p>
<p>对于充分小的模型和图片，任何现代pc都足以支持可交互式光线追踪。现实中，对于全屏的实现，多cpu共享帧缓存区是需要的。</p>
<p>计算机算力进步比屏幕分辨率更快，让传统pc在屏幕分辨率下实现复杂场景光线追踪只不过是时间问题。</p>
</li>
<li><p>ray tracing在硬件图形程序中有用吗</p>
<p>光线追踪经常用于<strong>采集</strong>，当用户点击鼠标3d图形程序的像素，程序需要决定哪个物体的显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 02</title>
    <url>/2022/10/28/naive/%E8%99%8E%E4%B9%A6/02/</url>
    <content><![CDATA[<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="Raster-Images"><a href="#Raster-Images" class="headerlink" title="Raster Images"></a>Raster Images</h2><ul>
<li><p>光栅以矩形像素数组的形式展示图片</p>
</li>
<li><p>光栅在需要图片的输入设备中也很流行。电子相机包含一个图片传感器，这个传感器由一个光敏像素网格组成。每个像素记录颜色和照在上面的光强。</p>
</li>
<li><p>光栅图片常用于存储和处理图片。光栅图片是一个简单的二维数组，存储每个像素的像素值。</p>
</li>
<li><p>除了光栅图片，还有vector image 用于存储描述形状，颜色范围，存储直线和曲线。</p>
</li>
</ul>
<p><strong>以下讨论raster image的基础和展示，特别关注于标准显示的非线性。其中像素值如何关联光强将会是很重要的</strong></p>
<h2 id="Raster-Device"><a href="#Raster-Device" class="headerlink" title="Raster Device"></a>Raster Device</h2><p>当今的显示器，包括电视，数字电影投影仪和电脑的显示器和投影仪一样，几乎都是基于固定像素数组。</p>
<p>他们可以被分为<strong>放射显示器</strong>（利用像素直接放射可控量的光）</p>
<p>和<strong>透射显示器</strong>（自己不发光，但是其他光源能够透过），需要一个lamp照射到screen上</p>
<h2 id="Images-Pixels-and-Geometry"><a href="#Images-Pixels-and-Geometry" class="headerlink" title="Images,Pixels,and Geometry"></a>Images,Pixels,and Geometry</h2><p><strong>首先我们要知道gamma校正</strong>，见本文末“补充”</p>
<p>然后</p>
<p>设定一个处于黑和白中间的强度 <code>0.5 = a ^ gamma</code></p>
<p>1.一个黑像素与白像素像交替的图片</p>
<p>2.一张灰色像素的图片</p>
<p>如果你是近视的，从远处看，这两张图会差不多</p>
<p>=&gt;根据这个道理</p>
<p>我们可以得到<code>a‘ = a^(1/gamma)</code></p>
<p>其中a为输入值，a’是输出值，由于有8bits的存储量</p>
<p>=&gt;a可能的值为{0/255，1/255，…,255/255} ^ gamma</p>
<h2 id="RGB-Color"><a href="#RGB-Color" class="headerlink" title="RGB Color"></a>RGB Color</h2><img src="/2022/10/28/naive/%E8%99%8E%E4%B9%A6/02/image-20221028231837391.png" class title="image-20221028231837391">



<p>大部分计算机图像都是用rgb来定义颜色</p>
<p>颜色叠加公式</p>
<p>详情见P75</p>
<h2 id="Image-Storage"><a href="#Image-Storage" class="headerlink" title="Image Storage"></a>Image Storage</h2><p>大部分rgb格式的图片,为三个通道，每个分配8bit</p>
<p>并且大部分格式的图片支持压缩（compression)</p>
<p>压缩又分为有损压缩和无损压缩</p>
<p><strong>为什么不让monitor(显示器)变成线性的，来避免gamma校正呢？</strong></p>
<blockquote>
<p>Ideally, the 256 possible intensities of a monitor should <em>look</em> evenly spaced as</p>
<p>opposed to being linearly spaced in energy. Because human perception of in</p>
<p>tensity is itself nonlinear, a gamma between 1.5 and 3 (depending on viewing</p>
<p>conditions) will make the intensities approximately uniform in a subjective sense.</p>
<p>In this way, gamma is a feature. Otherwise, the manufacturers would make the</p>
<p>monitors linear.</p>
</blockquote>
<p>理想情况下，256种强度的显示器应该是看起来能量均匀分布而不是线性分布。</p>
<p>因为人类感知本来就不是线性的。一个1.5到3的gamma值可以几乎让人从主观的感觉区分每种强度。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><font jump="补充">补充</font></h3><p><strong>根据百度</strong>：</p>
<p><code>Gamma源于CRT（显示器/电视机）的响应曲线，即其亮度与输入电压的非线性关系。</code></p>
<ul>
<li><p><strong>为什么显示器要Gamma校正</strong> 因为人眼对亮度的感知与物理功率不成正比，而是幂函数的关系，这个指数通常是2.2，称为Gamma值。</p>
</li>
<li><p>例如，功率为50%的灰色，人眼实际感知亮度为<code>pow(0.5,1/2.2) * 100% = 72.97%</code></p>
<p>但是人眼认为的50%的灰色，实际功率为<code>pow(0.5,2.2) * 100% = 21.76%</code></p>
<img src="/2022/10/28/naive/%E8%99%8E%E4%B9%A6/02/uTools_1667052564080.png" class title="uTools_1667052564080">

<img src="/2022/10/28/naive/%E8%99%8E%E4%B9%A6/02/uTools_1667052057309.png" class title="uTools_1667052057309"></li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Gamma校正的应用之一，就是明度和灰度计算公式。</p>
<p><strong>RGB明度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/6e778b35764a65eed7a22fa000b7dcf4.svg" alt="img"></p>
<p>L取值范围为0~1</p>
<p><strong>RGB灰度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/61b798fe6cddb99adc44b1aae1c92c22.svg" alt="img"></p>
<p><strong>注意这里的2.2次方和2.2次方根，RGB颜色值不能简单直接相加，而是必须用2.2次方换算成物理光功率。</strong>因为RGB值与功率并非简单的线性关系，而是幂函数关系，这个函数的指数称为Gamma值，一般为2.2，而这个换算过程，称为Gamma校正。</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 04</title>
    <url>/2022/11/02/naive/%E8%99%8E%E4%B9%A6/04/</url>
    <content><![CDATA[<h1 id="Surface-Shading"><a href="#Surface-Shading" class="headerlink" title="Surface Shading"></a>Surface Shading</h1><p>渲染3d场景时，无论使用ray tracing还是rasterization，在实时还是在批处理中，<strong>着色</strong>是对视觉效果影响</p>
<p>最大的过程之一</p>
<p>本章描述基于点光源照射的不透明表面基本着色模型。</p>
<h2 id="Point-source-illumination"><a href="#Point-source-illumination" class="headerlink" title="Point source illumination"></a>Point source illumination</h2><p>点光源包括position,intensity</p>
<p>点光源有isotropic(各向同性)</p>
<p>the irradiance E is  <code>E = P/4PI * 1/pow(r,2)</code></p>
<p>the quantity I = P/4PI,是光强(amount of light)，后者是factor</p>
<p>更普遍地，<code>E = I * cos(theta) / pow(r,2)</code>,其中<code>cos(theta) = n * l</code></p>
<img src="/2022/11/02/naive/%E8%99%8E%E4%B9%A6/04/uTools_1667393710823.png" class title="uTools_1667393710823">



<h3 id="Directional-illumination"><a href="#Directional-illumination" class="headerlink" title="Directional illumination"></a>Directional illumination</h3><p>不同于点光源，由于方向光是由很远的点光源产生，这就导致I/(r^2)的占比很小，这里设为一个常数H</p>
<p><code>E = H * cos(theta)</code></p>
<p>其中常量H被称为法向辐射（normal irradiance)</p>
<h3 id="Basic-reflection-models"><a href="#Basic-reflection-models" class="headerlink" title="Basic reflection models"></a>Basic reflection models</h3><p>现在可以计算辐射度（irradiance)了，辐射量可以表示照在物体上的光的量。</p>
<p><strong>1.Lambertian reflection</strong> 这是一种非常简单的模型，用于计算漫反射，光无差别反射。</p>
<p><code>L = kE</code></p>
<p><code>L = R/PI * E</code> 其中R是反射的光的强度</p>
<p>兰伯特模型公式<code>c = _DiffuseColor.rgb * _MainLight.rgb * max(dot(n,l),0);</code></p>
<p>半兰伯特则是点乘结果tilling 0.5,offset 0.5</p>
<p><strong>2. Specular reflection</strong></p>
<p>许多材质具有不同程度的亮度（shininess),例如金属光泽（metal),塑料（plastic)</p>
<p>光泽（gloss),半光泽（semi-gloss)</p>
<p>2.1最简单的高光（镜面反射）发生在完美的平滑表面，例如镜子，或者水的表面。</p>
<p>这种效果来源于一个点光源，点光源有具体的方向，使得表面有一个大的高光点。</p>
<p>2.2但是一般表面并不平滑，一般显示的效果更接近于glossy reflection.</p>
<p>比较知名的简单模型是BlinnPhong模型。</p>
<p>简化公式为<code>specular = _SpecularColor.rgb * _BaseColor * pow(max(0,dot(n,h)),_Gloss);</code></p>
<p>其中<code>h = normalize(l + v)</code></p>
<p>注意phong模型与BlinnPhong的区别（v*r)</p>
<p>一般将高光和漫反射相加统筹</p>
<img src="/2022/11/02/naive/%E8%99%8E%E4%B9%A6/04/uTools_1667567665544.png" class title="uTools_1667567665544">

<p><strong>生成因子k的表达式叫做双向反射分布函数（BRDF)</strong></p>
<p>因为它反映了反射光随l,v两个向量的改变而改变</p>
<p>对于lambertian的brdf是常量（constant)</p>
<p>对于specular则不是。irradiance描述了光的“量”，而brdf则描述了表面如何反射光。</p>
<h3 id="Caculating-shading"><a href="#Caculating-shading" class="headerlink" title="Caculating shading"></a>Caculating shading</h3><ul>
<li>光的入射向量<code>l = lightPosition - modelVertex</code></li>
</ul>
<img src="/2022/11/02/naive/%E8%99%8E%E4%B9%A6/04/uTools_1667568753509.png" class title="uTools_1667568753509">

<h2 id="Ambient-illumination"><a href="#Ambient-illumination" class="headerlink" title="Ambient illumination"></a>Ambient illumination</h2><p>点光源是非常局部性的光源</p>
<p><code>ambient = UNITY_LIGHTMODE_AMBIENT.rgb * albedo</code></p>
<img src="/2022/11/02/naive/%E8%99%8E%E4%B9%A6/04/uTools_1667819295698.png" class title="uTools_1667819295698">

<p>环境光着色是一个有点hack的手段，因为大型扩展光源发出的光是不同的，在角落和凹陷区域都会更暗一些。</p>
<p>但是它却是很重要的，因为它防止阴影变成完全的黑色，并且容易调整场景对比度。</p>
<p>一些系统把环境光看作一种点光源或平行光。还有一些系统则是让环境光Intensity成为一个场景的参数，来模拟环境光。</p>
<h3 id="Frequently-Asked-Questions"><a href="#Frequently-Asked-Questions" class="headerlink" title="Frequently Asked Questions"></a>Frequently Asked Questions</h3><ul>
<li><p>Phong 模型看起来是个很大的hack操作</p>
<p>yes</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 05</title>
    <url>/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/</url>
    <content><![CDATA[<h1 id="Viewing"><a href="#Viewing" class="headerlink" title="Viewing"></a>Viewing</h1><h2 id="Viewing-Transformations"><a href="#Viewing-Transformations" class="headerlink" title="Viewing Transformations"></a>Viewing Transformations</h2><p>视角变换用于映射3d位置。</p>
<p>它是一头复杂的野兽，依赖于包括相机坐标、orientation(取向)，投影的类型，视角的区域，和图片的清晰度(resolution);</p>
<p>它是通过几个简单变换点乘获得</p>
<ul>
<li>相机变换(camera/eye  transformation)</li>
<li>投影变换(projection transformation)</li>
<li>视口(窗口)变换(viewport transformation)</li>
</ul>
<img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667821796670.png" class title="uTools_1667821796670">

<p>模型空间-&gt;世界空间-&gt;相机空间-&gt;规范化视线空间-&gt;屏幕空间</p>
<h3 id="The-Viewport-Transformation"><a href="#The-Viewport-Transformation" class="headerlink" title="The Viewport Transformation"></a>The Viewport Transformation</h3><p>假设我们想要看到的几何体在规范的视图体积空间(canonical view volume)</p>
<p>然后我们想要在z轴方向用**正交(orthographic)**相机观察</p>
<p>canonical view volume(规范视图空间)是一个包含了所有3d坐标的正方体，这些坐标</p>
<p>在笛卡尔坐标系(cartesian coordinates)中处于（-1，1）之间</p>
<p>我们将x = -1投射到屏幕的左边，y = -1投射到屏幕的底部，像素坐标的定义是围绕着</p>
<p>以整数坐标为中心的方形。这样图像的边缘就有半个unit的overshoot</p>
<p>如果我们想要在图片上画nx * ny个像素,我们需要将square[-1.1]映射到[-0.5，nx - 0.5]</p>
<p>x [-0.5,ny - 0.5]</p>
<p><strong>这里是假设线段完全在规范视角空间里，后面会放下这个假设,讨论clipping(裁剪)</strong></p>
<img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667823244143.png" class title="uTools_1667823244143">

<p><code>Xscreen = nx/2 * Xcanonical + (nx - 1) / 2</code></p>
<p>…</p>
<p>注意这个矩阵忽略了z分量，因为这不影响投影到图片，但是在正式称呼这个矩阵为视口矩阵</p>
<p>(transform to screen),我们需要增加一一行和一列来存储z分量，不改变z分量</p>
<img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667824528183.png" class title="uTools_1667824528183">



<p>最终这个投影到屏幕</p>
<h3 id="The-Orthographic-Projection-Transformation"><a href="#The-Orthographic-Projection-Transformation" class="headerlink" title="The Orthographic Projection Transformation"></a>The Orthographic Projection Transformation</h3><p>当然，我们通常想要在除了canonical view volume空间的一些区域渲染几何体。我们的第一步是生成视图，这个视图保持view dir,orrientation不变，looking alone -z with +y up. </p>
<p>我们将在右边乘以另一个矩阵来增广这个矩阵。</p>
<img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667909557536.png" class title="uTools_1667909557536">

<p>the six params are respectively left,right,bottom,top,near,far</p>
<p>正交视图空间是在-z轴上，所以f是更小的负数</p>
<p>在z轴上，这样近视图反而比远视图更大，这是非直觉性的(uninstuitive)</p>
<img src="/2022/11/07/naive/%E8%99%8E%E4%B9%A6/05/uTools_1667910750246.png" class title="uTools_1667910750246">

<p>omit …..</p>
<h3 id="相机变换"><a href="#相机变换" class="headerlink" title="相机变换"></a>相机变换</h3><h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2>]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 06</title>
    <url>/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/</url>
    <content><![CDATA[<h1 id="The-Graphics-Pipeline"><a href="#The-Graphics-Pipeline" class="headerlink" title="The Graphics Pipeline"></a>The Graphics Pipeline</h1><p>前面几章已经建立了所需的数学基础(scaffolding)</p>
<p>现在主要讨论第二种主要的rendering 方式。</p>
<p>—在屏幕上一个接着一个绘制物体，也即<strong>object order rendering</strong></p>
<p>不同于ray tracing 的方式，通过像素找物体，现在会反过来通过物体找像素</p>
<p>**在一张被几何图元(geometric primitive)占满的图像上的所有像素的过程，称之为rasterization(光栅化)**，所以object order rendering也称之为光栅化渲染</p>
<p>而实现这一操作的操作序列，称之为图形渲染管线，<strong>graphics pipeline</strong></p>
<p>这种方法的成功，来源于它的效率。</p>
<p>对于大型场景，对数据存储模式的管理 是至关重要的操作。而且制作一个整个场景的通道来访问几何的每一个bit一次,比重复地搜索场景来检索所需的场景更加有有时。</p>
<p>object-order rendering不只有一种方法。</p>
<p>hardware 硬件pipeline使用OpenGL,Direct3D等API</p>
<p>software pipeline使用鱼电影制作，提供了像RenderMan这样地API</p>
<ul>
<li><p>硬件渲染管线需要运行地很快，使得足以支撑起实时游戏，可视化和用户交互</p>
</li>
<li><p>Production pipeline(生产管线)则追求高质量动画、视觉效果,但是这会花费很多时间。</p>
</li>
</ul>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><h3 id="Line-Drawing"><a href="#Line-Drawing" class="headerlink" title="Line Drawing"></a>Line Drawing</h3><p><strong>使用隐式线条方程</strong></p>
<p>用隐式方程画线条最普遍的算法是<strong>midpoint algorithm</strong></p>
<p>这种算法能够画出和<strong>Bresenham algorithm</strong>一样的线条，但是稍微更加直接。</p>
<p>见P38</p>
<p>常见的斜截式(slope-intercept)    <code>y = mx + b</code></p>
<p>b称为y-intercept,</p>
<p>slope-intercept 有时有点尴尬(awkward)，因为它不能表示x = 0,不然m需要infinite</p>
<p>这时候使用隐式表达式(implicit equation)     <code>Ax + By + C = 0</code></p>
<p>还有两点式<code>(y0 - y1) x + (x1 - x0)y + C = 0</code></p>
<p>C的话代入任意一个点就可以得到</p>
<p><strong>最终</strong></p>
<p><code>(y0 - y1) x + (x1 - x0)y + x0 y1 - x1y0 = 0</code></p>
<p>我们假设x0&lt;=x1,如果不正确，就交换两个点，斜率</p>
<p>slope    <code>m  =(y1  - y 0)/(x1 - x0);</code></p>
<p><strong>以下假设m在（0，1）区间</strong></p>
<img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1667998615390.png" class title="uTools_1667998615390">



<p>一个很有效的方法是，通过比较两个预选像素的中点和line，如果line在中点上面，就画（x+1,y+1)</p>
<p>不然就画（x+1,y)</p>
<p>那么如何比较（x+1,y+0.5）和线条呢</p>
<p><code>f(x + 1,y + 0.5) &lt; 0 then y = y + 1</code></p>
<p>详情见P182</p>
<h3 id="Triangle-Rasterization"><a href="#Triangle-Rasterization" class="headerlink" title="Triangle Rasterization"></a>Triangle Rasterization</h3><p>三角形内重心（barycentric coordinates)的颜色</p>
<p>是 <code>c = a * c0 + b * c1 + r * c2</code></p>
<p>另一个rasterizing triangle的细节（subtlety)是共享顶点和边。</p>
<p>这意味着相邻（adjacent)三角形之间没有间隙，我们可以用midpoint algorithm来画每个</p>
<p>三角形的边，然后填充内部像素</p>
<p>光栅化三角形，需要避免顺序问题，消除间隙，而方法则是，按照惯例（convention)，当且仅当像素的中心在三角形内，才进行光栅化。</p>
<p><strong>暴力算法（brute force algorithm)</strong></p>
<p>使用中心判断是否光栅化</p>
<img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668001076663.png" class title="uTools_1668001076663">









<h3 id="Dealing-with-Pixels-on-Triangle-Edges"><a href="#Dealing-with-Pixels-on-Triangle-Edges" class="headerlink" title="Dealing with Pixels on Triangle Edges"></a>Dealing with Pixels on Triangle Edges</h3><p>我们还没有讨论如果像素中心在三角形的边缘该怎么办，</p>
<p>根据上面的思路，如果不光栅化，那么势必会小一圈，相邻三角形可能会有一个大的间隙；如果光栅化，相比较前者好一些，但仍有问题：<strong>如果三角形都是transparent的，这将会造成double-coloring</strong>,毕竟本意是半透明，但是却画了两次。</p>
<img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668001688563.png" class title="uTools_1668001688563">

<p>所以我们真的确实需要裁定（award)具体哪一个像素，然后我们希望这个过程能够很简单。</p>
<p>其中一个方法是，标记任意视线之外的点确定为公共边的一侧，并且指定这个边是要绘制的。</p>
<h3 id="Perspective-Correct-Interpolation"><a href="#Perspective-Correct-Interpolation" class="headerlink" title="Perspective Correct Interpolation"></a>Perspective Correct Interpolation</h3><p>当interpolating quantities 插值大量的，例如纹理坐标或者3d坐标等需要在3d三角上线性改变</p>
<p>的数据时</p>
<p>在实现“纠正视觉透视”有一些subtleties(小方法，精妙的细节)</p>
<p>当透视校正很重要时我们会使用纹理坐标作为一种数量的指标（example)</p>
<p>3d空间线性值很重要是，上述考虑也适用于任何参数</p>
<p>事情不会那么简单的原因是，单纯的屏幕空间纹理坐标插值，会导致不正确的图像。如下图</p>
<img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668078483770.png" class title="uTools_1668078483770">









<img src="/2022/11/08/naive/%E8%99%8E%E4%B9%A6/06/uTools_1668079789675.png" class title="uTools_1668079789675">

]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/</url>
    <content><![CDATA[<h1 id="Signal-Processing"><a href="#Signal-Processing" class="headerlink" title="Signal Processing"></a>Signal Processing</h1><p>在图形中，我们经常要处理具有连续变量的函数：一开始你只看到一张图像，但是随着你的探索，你将会看到更多。本质上，连续函数不能直接在电脑上表达，我们必须用优先的比特来表达他们。</p>
<p>最有用的方法之一是存储这个函数在不同点的值，然后在需要的时候进行重构。</p>
<p>你现在位置应该熟悉使用二维网格像素来表达图像，所以你已经见过一个采样的表现。</p>
<p>另一个关于sampled representation 的粒子是二维的数字化平板。</p>
<p>例如平板电脑，或者艺术家使用的数位屏。这种情况下，最原式的函数是数位笔的移动</p>
<p>（stylus数位笔触针手写笔)</p>
<p>…</p>
<h3 id="Digital-Audio-Sample-in-1d"><a href="#Digital-Audio-Sample-in-1d" class="headerlink" title="Digital Audio : Sample in 1d"></a>Digital Audio : Sample in 1d</h3><p>即使sampled representation 已经用于电子交流很久了，激光唱片（compact disc)在1982年的引入，紧随着音频数字记录器的使用增长，在过去的10年里，是第一个高度可视的消费者应用采样。</p>
<p>…</p>
<h3 id="Sampling-Artifacts-and-Aliasing"><a href="#Sampling-Artifacts-and-Aliasing" class="headerlink" title="Sampling Artifacts and Aliasing"></a>Sampling Artifacts and Aliasing</h3><p>数字音频记录可以为sampling 和reconstruction处理更加具体的模型。</p>
<p>Aliasing 展示了不管什么时候，采样重构失效导致人工结果是一个令人惊讶的频率</p>
<p>在音频中，走样以一种奇怪的声音和额外的声调–一个10Hz的bell ring,当采样到8Hz,就变成一个6Hzd的声调</p>
<p>在图像中，走样经常因为采样网格的interaction和图像中常规特点。以moire pattern的形式出现。</p>
<img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669910518267.png" class width="1669910518267">



<h3 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h3><p>在我们讨论sampling和reconstruction算法之前，我们首先要检验它们基于的数学该奶奶</p>
<p>convolution卷积。</p>
<p>卷积是一个简单的数学概念，为算法作基础用来采样，过滤，重构。</p>
<p>同时它也是我们如何分析这些算法的基础。</p>
<p>卷积是一个function:它使用两个functions，然后将它们结合成一个新的function</p>
<p>这本书中，卷积运算符用一个*标记。f * g,f is convolved with g</p>
<p>卷积可以被用于连续方法或者离散的序列。</p>
<p>同时也可以被用于定义在1d,2d,3d或者更高维度.</p>
<p>为了定义方便，我们通常假设函数定义域区域无限。</p>
<p><img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/Website\Blog\source_posts\虎书\07\1669911797075.png" alt="1669911797075"></p>
<h3 id="Moving-Average"><a href="#Moving-Average" class="headerlink" title="Moving Average"></a>Moving Average</h3><p>为了得到一个基础的卷积图像。</p>
<p>思考：使用moving average来平滑一个函数。</p>
<p>为了在任意一个点得到平滑的值，我们需要计算函数超出范围拓展到每个方向，距离长度为r 的平均值。</p>
<p>距离r是平滑的radius，控制平滑度</p>
<p>我们用数学方法表示，如果平滑一个连续的函数g(x)，平均化（averaging)意味着在区间内对g进行求积分</p>
<p>（integrating)</p>
<img src="/2022/12/01/naive/%E8%99%8E%E4%B9%A6/07/1669912247511.png" class width="1669912247511">

<h3 id="Discrete-Convolution"><a href="#Discrete-Convolution" class="headerlink" title="Discrete Convolution"></a>Discrete Convolution</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Lecture01%20Overview%20of%20Computer%20Graphics/</url>
    <content><![CDATA[<h1 id="Lecture01-Overview-of-Computer-Graphics"><a href="#Lecture01-Overview-of-Computer-Graphics" class="headerlink" title="Lecture01 Overview of Computer Graphics"></a>Lecture01 Overview of Computer Graphics</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/12/01/naive/Games%E7%B3%BB%E5%88%97/101/Lecture03%20Transformation/</url>
    <content><![CDATA[<h1 id="Lecture03-Transformation"><a href="#Lecture03-Transformation" class="headerlink" title="Lecture03 Transformation"></a>Lecture03 Transformation</h1><h2 id="Last-Lecture"><a href="#Last-Lecture" class="headerlink" title="Last Lecture"></a>Last Lecture</h2><ul>
<li><p>Basic operations : addition, multiplication</p>
</li>
<li><p>Dot Product - Forward/backward  (dot product positive/negative)</p>
<p>如果点乘结果为正，则向前；否则向后</p>
</li>
<li><p>Cross Product - Left/right (cross product outward/inward)</p>
<p>如果叉乘结果指向外面，则为左；否则为右</p>
</li>
<li><p>Matrice</p>
</li>
</ul>
<h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><h3 id="Why-Transformation"><a href="#Why-Transformation" class="headerlink" title="Why Transformation?"></a>Why Transformation?</h3>]]></content>
  </entry>
  <entry>
    <title>Games101 Material_01</title>
    <url>/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/</url>
    <content><![CDATA[<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><h2 id="Diffuse-Lambertian-Material"><a href="#Diffuse-Lambertian-Material" class="headerlink" title="Diffuse/Lambertian Material"></a>Diffuse/Lambertian Material</h2><p>对半球costheta积分结果是PI</p>
<p>关于这个证明</p>
<img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668081297856.png" class title="uTools_1668081297856">

<p>半球上的立体角定义为覆盖半球表面区域的面积初一半径的平方</p>
<img src="/2022/11/10/naive/Games%E7%B3%BB%E5%88%97/101/Material/uTools_1668080586079.png" class title="uTools_1668080586079">]]></content>
      <categories>
        <category>Games101</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/13/naive/Games%E7%B3%BB%E5%88%97/101/Homework/homework1/</url>
    <content><![CDATA[<h1 id="01"><a href="#01" class="headerlink" title="01"></a>01</h1><p>需要eigen和opencv</p>
<p>注意include( ),下载地址<a href="https://www.raoyunsoft.com/opencv/opencv-4.5.2/">Index of /opencv/opencv-4.5.2/ (raoyunsoft.com)</a></p>
]]></content>
  </entry>
  <entry>
    <title>Geometry(几何)</title>
    <url>/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/</url>
    <content><![CDATA[<h1 id="Introduce-to-Geometry"><a href="#Introduce-to-Geometry" class="headerlink" title="Introduce to Geometry"></a>Introduce to Geometry</h1><h2 id="Examples-of-Geometry"><a href="#Examples-of-Geometry" class="headerlink" title="Examples of Geometry"></a>Examples of Geometry</h2><p>机械</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094334796.png" class title="image-20230713094334796">

<p>水</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094400111.png" class title="image-20230713094400111">

<p>毛发</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094451880.png" class title="image-20230713094451880">

<h1 id="Representation-of-Geometry"><a href="#Representation-of-Geometry" class="headerlink" title="Representation of Geometry"></a>Representation of Geometry</h1><p><strong>Implicit(隐式表达)</strong></p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094634138.png" class title="image-20230713094634138">

<p>隐式表达，一般看表达式，但是光看表达式并不直观。algebraic方式。</p>
<p>另一种方法是constructive solid geometry（csg,构造立体几何法)</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713095753987.png" class title="image-20230713095753987">



<p>距离函数Distance Function</p>
<p>希望blend得到AB的中间状态，SDF是有向距离场</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713100223756.png" class title="image-20230713100223756">

<p>如果是第一行的图，结果不能得到左黑右白的中间态</p>
<p>第二行使用SDF，通过blend，可以得到0的位置，颜色围绕0开始渐变。</p>
<p>插值得到的SDF再转回原图像</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/166.png" class>





<p><strong>Explicit(显式表达)</strong></p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713094802801.png" class title="image-20230713094802801">

<p>直接通过uv映射方式定义</p>
<p>隐式不知道函数的结果是哪个变量，显示知道；显示通过已知的自变量就能得出图形的结果样子。</p>
<p><code>Geometry is hard!</code></p>
<ol>
<li><p>Point Cloud（最简单）,lists of point,点足够多就成了面</p>
</li>
<li><p>Polygon Mesh(多边形网格)，如三角网格</p>
</li>
<li><p>The Wavefront Object File(.obj) Format，这种.obj文件不是目标文件，而是一种文本格式，记录了顶点（vertices)，法线（normal),纹理（texture),坐标（coordinates)</p>
<p>还有它们的connectivities；本质上就是一个3d白模文件。</p>
</li>
</ol>
<h3 id="Curve（曲线）"><a href="#Curve（曲线）" class="headerlink" title="Curve（曲线）"></a><strong>Curve</strong>（曲线）</h3><p>以上讲了两种几何的两种表达方式。接下来主要学习曲线这种几何的实现与应用。</p>
<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a><strong>贝塞尔曲线</strong></h4><p>类似于ps钢笔工具，选择控制点，帮助绘制曲线（<strong>显示表达</strong>）</p>
<p>如何绘制贝塞尔曲线？</p>
<p>de Casteljau Algorithm</p>
<p>举例：要求从b0开始，b2结束，t是时间记为【0，1】，共计三个控制点，如下图</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713152733714.png" class title="image-20230713152733714">

<p>以时间t为单位进行划分，得到b01,b11,连线后再划分，recursively直到无法划分</p>
<p>最后我们得到曲线过三个点。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713160355108.png" class title="image-20230713160355108">

<p><strong>更普遍地</strong></p>
<p>两个控制点画直线</p>
<p>三个控制点，绘制二次贝塞尔曲线。</p>
<p>…</p>
<p>若干个无限递归下去，n个点逐渐递归成一个点，不难发现<code>（1-t + t) ^n</code>的展开项正是控制点bj的权重</p>
<p>称之为伯因斯坦多项式，以下是n阶贝塞尔曲线的解析式</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713160850476.png" class title="image-20230713160850476">

<p>有关贝塞尔曲线的性质，1. 起点终点都固定 2.初始方向，最后方向确定 3. affine property仿射性质，想要移动变换曲线可以通过变换控制点。 </p>
<p>4.凸包性质（Convex Hull)：</p>
<p>想象蓝色线条为橡皮筋，橡皮筋包围的区域就是凸包</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715160538189.png" class title="image-20230715160538189">

<p>贝塞尔曲线一定在凸包里面</p>
<p>【补充】</p>
<ol>
<li>二项展开：</li>
</ol>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161623637.png" class title="image-20230713161623637">

<p>​    简记为：</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161650108.png" class title="image-20230713161650108">

<ol start="2">
<li><p>莱布尼兹多项式展开</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161755950.png" class title="image-20230713161755950"></li>
</ol>
<p>​    展开通项为（又叫做多项式定理）</p>
   <img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230713161934995.png" class title="image-20230713161934995">

<ol start="3">
<li><p>伯因斯坦多项式</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715154925547.png" class title="image-20230715154925547"></li>
</ol>
<h4 id="Piecewise-Bezier-逐段贝塞尔"><a href="#Piecewise-Bezier-逐段贝塞尔" class="headerlink" title="Piecewise Bezier(逐段贝塞尔)"></a>Piecewise Bezier(逐段贝塞尔)</h4><p>多段3阶贝塞尔的连接。</p>
<p>示意图，曲线要连续，最后两个点决定终点导数，如果终点导数和下一个起点导数相等（蓝色标记共线等长），则认为曲线光滑连续。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/60.png" alt="60">

<p>【补充】</p>
<p><strong>Spline 样条</strong></p>
<p>有多个控制点，保持连续。一个可控的曲线。</p>
<p>用的多的有B-Spline(复杂度高)</p>
<h3 id="Surface-曲面"><a href="#Surface-曲面" class="headerlink" title="Surface(曲面)"></a>Surface(曲面)</h3><p>如何用贝塞尔曲线拓展到曲面，下图中，有一个4x4=16控制点的几何。</p>
<p>一共有四行，每行一条3阶贝塞尔曲线，只要控制贝塞尔曲线的高度，进而就能控制面的形状。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715182508405.png" class title="image-20230715182508405">

<p>具体操作如下图，其实上述有一个问题，竖轴（假设贝塞尔曲线所在轴）可以随意控制，但是横轴的变形却未提及</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230715183005306.png" class title="image-20230715183005306">

<p>根据上图我们可以发现，四条贝塞尔分别插值，最后得到4个点再做二维的插值。由此可以实现贝塞尔曲面。</p>
<p>设参数为（u，v)，横轴和竖轴的时间参数。显然这里也验证了贝塞尔曲线是显示的表达方式。</p>
<h1 id="Mesh-Operations-Geometry-Processing"><a href="#Mesh-Operations-Geometry-Processing" class="headerlink" title="Mesh Operations(Geometry Processing)"></a>Mesh Operations(Geometry Processing)</h1><h2 id="Mesh-subdivision-网格细分"><a href="#Mesh-subdivision-网格细分" class="headerlink" title="Mesh subdivision(网格细分)"></a>Mesh subdivision(网格细分)</h2><p>什么是细分？</p>
<p>可以理解为提高模型网格的精度（分辨率）</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716120504980.png" class title="image-20230716120504980">

<p>如何细分？</p>
<ol>
<li>创建更多三角形</li>
<li>调整三角形的位置</li>
</ol>
<h3 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h3><p>循环细分，拿一个三角形来举例，首先分成4个小三角形，然后调整位置。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/61.png" class width="61">

<p>具体如何tune position(调整位置)呢？</p>
<ol>
<li>得到的<strong>新顶点</strong>会根据与老顶点相对位置进行加权平均，如下图</li>
</ol>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/62.png" class width="62">

<ol start="2">
<li><p>原来的**老顶点（old vertices)**也会进行一定程度的调整，其中n是degree,下图对于中间的白点，</p>
<p>由于度为6，连接了多个三角形，重要性相对就会比较低（n越大，白点的权重越小）；同时邻点权重会变大。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/63.png" class width="63"></li>
</ol>
<h3 id="Catmull-Clark-Subdivision"><a href="#Catmull-Clark-Subdivision" class="headerlink" title="Catmull-Clark Subdivision"></a>Catmull-Clark Subdivision</h3><p>使用Loop subdivision的条件是网格为三角形。但是如果网格为下图这样的情况。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716131744281.png" class title="image-20230716131744281">

<p>Catmull-Clark可以用作不同形状的面。</p>
<p>【条件】extraordinary vertices(定义度为不等于4的点为奇异点)</p>
<p>下图中，将边的中点连接交会到一个新的点（注意这个新的点同时也是面的中心）；最后得到的两个新点再连接。发现已经没有三角形了。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/64.png" class width="64">

<p>再细分多次</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716132324232.png" class title="image-20230716132324232">

<p>Catmull-Clark细分方法总结，1. 增加图元的方法是通过连接中点和图元中心 2.调整顶点位置（tune position)的方法依然是通过加权平均得到。图元中心为f，边的中点为e，图元顶点为v。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/65.png" alt="65">

<h2 id="Mesh-simplification"><a href="#Mesh-simplification" class="headerlink" title="Mesh simplification"></a>Mesh simplification</h2><p>减少mesh图元的同时不改变形状</p>
<p>下图为不同数量三角面的结果。类似于mipmap不同层级用不同图片。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716140137989.png" class title="image-20230716140137989">

<p>如何做网格简化</p>
<p><strong>边坍缩</strong></p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716140449449.png" class title="image-20230716140449449">

<p>Quadric Error Metric(二次误差度量)实现边坍缩，下图中，我们需要将上面三个顶点坍缩成一个蓝色点。</p>
<p>需要找到一个最小的蓝点，使得该点（边）到其他三个点（面）的距离平方和最小。这个平方和就是二次度量误差，新建优先队列，将最小的误差放在前面，每次坍缩最小的那个。</p>
<img src="/2023/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Geometry/image-20230716142333331.png" class title="image-20230716142333331">

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要6</title>
    <url>/2022/10/28/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter6/</url>
    <content><![CDATA[<h2 id="Chapter6-Diffuse"><a href="#Chapter6-Diffuse" class="headerlink" title="Chapter6_Diffuse"></a>Chapter6_Diffuse</h2><h3 id="逐顶点计算漫反射"><a href="#逐顶点计算漫反射" class="headerlink" title="逐顶点计算漫反射"></a>逐顶点计算漫反射</h3><p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间</p>
<p>角的余弦值 。因此， 漫反射部分的计算如下</p>
<p>c_diffuse=( light * m_diffuse) max( n . I ) </p>
<p>中， n是表面法线,I 是指向光源的单位矢量 ,m_diffuse 是材质的漫反射颜色 ,light 是光源颜色。</p>
<p>需要注意的是 我们需要防止法线和光源方向点乘的结果为负值，为此 我们使用取最大值的函数来将其截取到 o, 这可以防止物体被从后面来的光源照亮。</p>
<p><em>以下为具体代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顶点着色器代码</span><br><span class="line">          v2f vert(a2v v)&#123;</span><br><span class="line">              v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">              //将顶点信息从模型空间传递到投影空间</span><br><span class="line">              o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line"></span><br><span class="line">              //获取环境光</span><br><span class="line">              fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">              //将法线从模型空间传递到世界空间,</span><br><span class="line">              fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line"></span><br><span class="line">              //获取世界空间的光照方向</span><br><span class="line">              fixed3 worldLight = normalizze(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line"></span><br><span class="line">              //计算漫反射  saturate：饱和,用于将数据截取到【0，1】之间</span><br><span class="line">              fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line">              o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">              return o;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>详情见P128.</p>
<p>矩阵变换见P86</p>
<p>要注意，非统一缩放，<strong>经计算得知</strong>会导致，法线不再垂直，所以不能用M(A-B)矩阵</p>
<p>需要用变换矩阵的<em>逆转置矩阵</em></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>1.进行漫反射计算，需要法线，光照，但是需要两者在同一空间下，这里是世界空间，并且法线变换不同于顶点变换</p>
<p><em>法线变换mv方法</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//右乘mv逆矩阵</span><br><span class="line">fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line">//因为左乘逆转置矩阵，</span><br><span class="line">//it为逆转置，其实对于正交来说，等于原来变换矩阵，但不是正交矩阵，会出现上述法线问题</span><br></pre></td></tr></table></figure>

<p>2.一个矩阵可以左乘达成mv变换，那么它的逆矩阵就可以达成vm变换；逆=换方向，转=换位置</p>
<img src="/2022/10/28/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660737217984.png" class title="uTools_1660737217984">

<h3 id="逐像素计算漫反射"><a href="#逐像素计算漫反射" class="headerlink" title="逐像素计算漫反射"></a>逐像素计算漫反射</h3><p>类似于顶点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Books/Chapter6/Pixel_Level&quot;&#123;</span><br><span class="line">     Properties&#123;</span><br><span class="line">        //初始化Color属性,得到并控制漫反射颜色,设置为白色</span><br><span class="line">        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        // Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        //顶点片元着色器代码要写在pass通道中</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //正确定义lightmode才可以得到unity内置光照变量，该Tag用于定义pass的角色</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">            //获取properties中的变量</span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            //定义顶点着色器的输入输出结构体,同时输出也是片元的输入</span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal :NORMAL;  //将模型顶点法线信息保存</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0;  //将光照颜色传递给片元着色器，也可以用 XCOORDO 语义。</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //顶点着色器代码,由于顶点着色器不参加计算，只要获取到坐标和世界法线</span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">                //将顶点信息从模型空间传递到投影空间</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                // //获取环境光</span><br><span class="line">                // fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                //将法线从模型空间传递到世界空间</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line">                // //获取世界空间的光照方向</span><br><span class="line">                // fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line">                // //计算漫反射  saturate：饱和</span><br><span class="line">                // fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line">                // o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //逐像素计算</span><br><span class="line">            fixed4 frag(v2f i) :SV_TARGET&#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                //法线</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //获取光照方向</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                return fixed4(color,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果全黑</p>
<img src="/2022/10/28/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660751437397.png" class title="uTools_1660751437397">

<p>在片元着色器计算结果更加平滑，但是光照不到的地方全黑；</p>
<p>全黑可以通过添加环境光</p>
<p>但是背光区却和向光区明暗一致，这时可以用<strong>半兰伯特模型</strong></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要8</title>
    <url>/2022/11/02/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter8/</url>
    <content><![CDATA[<h2 id="Chapter8-透明效果"><a href="#Chapter8-透明效果" class="headerlink" title="Chapter8 透明效果"></a>Chapter8 透明效果</h2><h3 id="实现透明的方法"><a href="#实现透明的方法" class="headerlink" title="实现透明的方法"></a>实现透明的方法</h3><p>unity中通常使用两种方式实现透明效果</p>
<p>1.透明度测试(alpha test),（无法实现真正的半透明）</p>
<p>2.透明度混合(alpha blending)</p>
<p><strong>使用深度测试，可以不考虑渲染顺序</strong>，但是使用透明度混合时，需要关闭*<code>ZWrite</code>*，关闭了深度写入</p>
<p>虽然<em>透明度测试</em>不需要关闭，但是它的机制是如果透明度不满足某个阈值（通常小于），直接舍弃该片元。</p>
<ul>
<li>为什么关闭<code>ZWrite</code>?</li>
</ul>
<p><em>由于深度测试丢弃远处被遮挡部分，但是透明物体的机制是”可以透过并看见远处的物体”。</em></p>
<p>关闭了ZWrite，渲染顺序则成了问题。</p>
<p><strong>流程</strong></p>
<p>1.渲染时，会进行深度测试，如果先渲染后面的不透明b，将b写入颜色缓冲和深度缓冲；然后渲染前面的透明a,a写入颜色缓冲，会发生透明混合，显示正确。</p>
<p>2.如果先渲染a,进行深度测试，写入颜色缓冲，但是关闭了ZWrite，无法写入深度值，然后渲染b，写入深度值，写入颜色缓冲，b的颜色<strong>覆盖</strong>a,只能看见b。</p>
<p>3.半透明物体之间亦然。</p>
<h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>Unity Shader解决方案为SubShader 中的Tags</p>
<p>以下为透明度测试alpha test示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       Tags&#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;TransparentCutout&quot;</span>&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">//alpha test</span></span><br><span class="line">               clip(texColor.a - _Cutoff);</span><br><span class="line">               <span class="comment">// Equal to </span></span><br><span class="line">               <span class="comment">// if (( exColor - _Cutoff) &lt; 0 . 0) &#123; </span></span><br><span class="line">               <span class="comment">// discard; &#125;</span></span><br><span class="line">           	...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">         &#125;  </span><br></pre></td></tr></table></figure>

<p>每块的透明度都不同，根据面板调整_Cutoff可以看出哪个更低，低的那个会直接被剔除</p>
<p>结果图</p>
<img src="/2022/11/02/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter8/uTools_1660983793621.png" class title="uTools_1660983793621">



<h3 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       //alpha blend</span><br><span class="line">       Tags&#123;&quot;Queue&quot;=/*&quot;AlphaTest&quot;*/&quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">           ZWrite Off</span><br><span class="line">           Blend SrcAlpha OneMinusSrcAlpha  //P170</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br><span class="line">           //去掉clip</span><br></pre></td></tr></table></figure>

<h3 id="解决排序问题"><a href="#解决排序问题" class="headerlink" title="解决排序问题"></a>解决排序问题</h3><p><strong>一般先开启深度测试、写入，先渲染不透明物体，然后关闭写入，对不透明物体排序，先渲染后面的物体</strong></p>
<ul>
<li><strong>但是仍然存在很大问题。</strong></li>
</ul>
<p>比如一个物体，各个部分互相遮挡，又或者多个物体，相互遮挡，而深度排序是像素级别的。</p>
<p><strong>问题在于</strong></p>
<p>现在开启ZWrite</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Pass&#123;</span><br><span class="line"> ZWrite On </span><br><span class="line"> ColorMask 0//ColorMask RGB 、 A 、 0 、其他任何rgba的组合</span><br><span class="line"> //0表示不写入任何颜色通道，即只写入深度缓存，不输出颜色</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新添加一个Pass通道。该Pass专门用来写入深度缓冲，并且先执行。</p>
<p>Pass通道中加上<code>//Cull Front/Back/Off 需要双面渲染时关闭剔除</code></p>
<p>注意如果关闭了深度写入，此时再双面渲染就会出现半透明错误渲染</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7-1</title>
    <url>/2022/10/31/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/</url>
    <content><![CDATA[<h2 id="Chapter7"><a href="#Chapter7" class="headerlink" title="Chapter7"></a>Chapter7</h2><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><p>冷色调转暖色调，编写卡通风格Unity Shader（<em>记录：区别BlinnPhong和Phong高光计算</em>，另外如果计算新的漫反射albedo,就不用声明_Diffuse来计算diffuse）</p>
<p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">               fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">               fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">               fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;  //</span><br><span class="line"></span><br><span class="line">               //使用纹理来采样漫反射,使用半兰伯特模型</span><br><span class="line">               fixed halfLambert = 0.5 * dot(worldNormal,worldLightDir) + 0.5;</span><br><span class="line">               fixed3 diffuseColor = tex2D(_RampTex,fixed2(halfLambert,halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">               fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">               //计算高光BlinnPhong模型</span><br><span class="line">               fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">               fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">               fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss);</span><br><span class="line">               </span><br><span class="line">               return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<p>注意使用<code>fixed2(halfLambert,halfLambert)</code>会发生大于1的情况（1.0001）,这样映射到模型上会出现黑点</p>
<p>此时需要将纹理的WrapMode从Repeat(重复，但是最左边是黑色的）换成Clamp(大于1取1)</p>
<p><img src="/2022/10/31/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5Cimage-20220820110835470.png" alt="image-20220820110835470"></p>
<h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><p>使用高光遮罩纹理，遮罩纹理用于更加细致地控制高光反射光强度</p>
<p>变量声明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">fixed4 _Color;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line"><span class="comment">//float4 _BumpMap_ST;</span></span><br><span class="line"><span class="built_in">float</span> _BumpScale;</span><br><span class="line">sampler2D _SpecularMask;</span><br><span class="line"><span class="comment">//float4 _SpecularMask_ST;</span></span><br><span class="line"><span class="built_in">float</span> _SpecularScale;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="built_in">float</span> _Gloss;</span><br></pre></td></tr></table></figure>

<p><em>这里 _ BumpMap、_ Specular和_MainTex共用一个ST</em></p>
<p>如果每个纹理都需要不同的平铺系数和偏移系数，那么纹理数目增加顶点着色器中的插值寄存器会迅速被占满。</p>
<p><strong>流程</strong></p>
<p>1.该实验使用了三个纹理，分别是基本纹理，切线空间的法线纹理（凹凸贴图），高光遮罩纹理</p>
<p>2.计算是逐像素计算，计算是在切线空间下进行（一定要明确在哪个空间下进行），diffuse用lambert模型</p>
<p>specular用BlinnPhong模型</p>
<p>3.<code>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex;</code>三张纹理共用同一套uv</p>
<p><strong>结果</strong></p>
<p>加上遮罩贴图后高光更加暗淡和谐</p>
<p><img src="/2022/10/31/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5CuTools_1660974045813.png" alt="uTools_1660974045813"></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7</title>
    <url>/2022/10/29/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7/</url>
    <content><![CDATA[<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们通常用一张纹理代替物体漫反射</p>
<h3 id="单纹理贴图"><a href="#单纹理贴图" class="headerlink" title="单纹理贴图"></a>单纹理贴图</h3><p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line"></span><br><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter7/SingleTexture&quot;&#123;</span><br><span class="line"></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Specular(&quot;Specular&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;,Range(8.0,256)) = 20</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed3 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST; //TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算， 确保材质球里的缩//放和偏移设置是正确的。 （v.texcoord就是顶点的uv）</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex :POSITION;</span><br><span class="line">                float3 normal :NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                o.uv = v.texcoord.xy + _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                //get normal</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //get lightdir</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); //输入世界坐标，返回该点到光源方向</span><br><span class="line">                //拿采样结果和color的乘积作为反射率</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //计算环境光</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse =  _LightColor0.rgb * albedo.rgb * max(0,dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                //朝向光源</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));//_WorldCameraPos - o.wroldPos(not normalized)</span><br><span class="line">                //halfDir代替出射光,worldLightDir指向交点</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                //计算高光,发现reflect*viewDir 变成了normal*halfDir</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal , halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7/uTools_1660877749523.png" class>

<p>中间由于将halfDir 、diffuse声明为fixed，导致高光方向错误</p>
<p><code>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code></p>
<p>tilling 和 offset==&gt; 平铺和偏移系数</p>
<h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><p><em>分为高度贴图和法线贴图；前者记录深度值，后者记录法线</em>，一般法线映射认为是凹凸贴图的等价（实际不然）</p>
<p>而法线纹理中，又分为模型空间下的和切线空间下的，一般用切线空间下的法线贴图更方便</p>
<p><strong>切线空间指的是以某点切线、副切线、法线为三个坐标轴的空间（副切线有时也称为Binormal)</strong></p>
<h4 id="切线空间下的光照模型的计算"><a href="#切线空间下的光照模型的计算" class="headerlink" title="切线空间下的光照模型的计算"></a>切线空间下的光照模型的计算</h4><p><em>计算副法线Binormal</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Compute the binormal </span><br><span class="line">//float3 binormal = cross (normalize (v . normal), normalize (v. tangent. xyz )) * </span><br><span class="line">v . tangent.w; </span><br><span class="line">//Cons rue matrix which transform vectors from object space to tangent spac e </span><br><span class="line">//float3x3 rotation= float3x3(v . tangent . xyz , binormal, no mal)</span><br><span class="line">//Or just use the built-in macro </span><br><span class="line">TANGENT SPACE ROTATION;</span><br></pre></td></tr></table></figure>

<p>如果再法线纹理中没有设置为Normal Map,需要再代码中手动设置；这是为了方便Unity优化法线纹理的存储压缩</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Or mark the texture as &quot;Noramal Map&quot;</span></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale; <span class="comment">//控制凹凸程度</span></span><br><span class="line">tangentNormal.z = sqrt(<span class="number">1.0</span>-saturate(dot(tangentNormal.xy,tangentNormal.xy)));<span class="comment">//由于是单位矢量，直接计算出z</span></span><br></pre></td></tr></table></figure>

<p>使用tex2D返回_BumpMap的采样</p>
<p><code> fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw);</code></p>
<p><strong>结果</strong></p>




<h4 id="世界空间下计算光照"><a href="#世界空间下计算光照" class="headerlink" title="世界空间下计算光照"></a>世界空间下计算光照</h4><p>插值寄存器只能存放最大float4,无法存放矩阵，所以声明三个float4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                // float3 lightDir : TEXCOORD1;</span><br><span class="line">                // float3 viewDir : TEXCOORD2;</span><br><span class="line"></span><br><span class="line">                //WorldSpace</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                Float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //一个uv存两张图</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; </span><br><span class="line"></span><br><span class="line">                //WorldSpace-----------</span><br><span class="line">                fixed3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal,worldTangent) * v.tangent.w;//叉乘</span><br><span class="line">                </span><br><span class="line">                //Compute transform matrix</span><br><span class="line">                o.TtoW0 = float4(worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);</span><br><span class="line"></span><br><span class="line">                //---------------------</span><br><span class="line">                // //计算副法线</span><br><span class="line">                // TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line">                // //将模型空间的光线变换到切线空间中</span><br><span class="line">                // o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex).xyz);</span><br><span class="line">                // //同时将视角方向传递到切线空间</span><br><span class="line">                // o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex).xyz);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                </span><br><span class="line">                //get worldpos</span><br><span class="line">                fixed3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">                //compute light and view dir</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                fixed3 bump= UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump.xy *= _BumpScale ; </span><br><span class="line">                bump.z = sqrt(1.0- saturate(dot(bump.xy, bump.xy))); </span><br><span class="line">                // Transform the normal from tangent space to wo ld space </span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz,bump), </span><br><span class="line">                dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //-------------</span><br><span class="line">                 //tex2d 返回float4,普通纹理返回颜色值 bump则是法向量</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(bump,lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(bump,halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<img src="/2022/10/29/UnityShader/UnityShader%E7%B2%BE%E8%A6%81Chapter7/image-20220820083553612.png" class title="image-20220820083553612">



<p><strong>CreateFromGrayscale</strong> 用高度图生成切线空间法线纹理</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Unity Shader之渲染流水线</title>
    <url>/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>为什么要增加这个栏目？</li>
</ul>
<p>由于个人目前主要学习Unity引擎，在引擎Shader的学习中，学了很多，但是不解的和不会的反而越来越多，借此机会自我总结一下，也为后续学习理清思路，该栏目将会随时间迭代更新。</p>
<ul>
<li>该栏目有哪些内容？</li>
</ul>
<p>我个人目前的想法是从我的学习路线入手。Unity Shader入门精要 -&gt; Catlike Coding -&gt; 案例综合</p>
<ul>
<li>环境<ul>
<li>软件： Unity</li>
<li>着色器语言： CG,HLSL</li>
</ul>
</li>
</ul>
<h2 id="Unity-Shader之渲染流水线"><a href="#Unity-Shader之渲染流水线" class="headerlink" title="Unity Shader之渲染流水线"></a>Unity Shader之渲染流水线</h2><h3 id="什么是渲染流水线？"><a href="#什么是渲染流水线？" class="headerlink" title="什么是渲染流水线？"></a>什么是渲染流水线？</h3><p><strong>由CPU、GPU共同完成，使用三维数据（顶点，法线等）将三维物体渲染成屏幕上的二维图像</strong></p>
<p>流水线的概念早已学过，那么渲染流水线又是什么。首先要区别于GPU（硬件)流水线。</p>
<p>分为三个概念上的阶段，每个阶段又有子流水线。</p>
<ol>
<li><p>应用阶段(application)：开发者支配的阶段，输入场景、贴图、摄像机、光源等等；输出点、线、三角面等渲染图元。CPU上。</p>
</li>
<li><p>几何阶段（geometry): 这个阶段主要决定渲染哪些图元，以及将这些图元映射到二维平面上，最后输出包括屏幕上的着色，深度值，坐标等等到光栅器。</p>
</li>
<li><p>光栅化阶段（rasterization): 这个阶段同上一个阶段都是在GPU上进行，利用上一阶段的数据绘制出像素。先是逐顶点处理（对坐标，颜色逐顶点插值），然后是像素处理。</p>
</li>
</ol>
<h3 id="CPU和GPU之间的交互流程是怎样的？（Application"><a href="#CPU和GPU之间的交互流程是怎样的？（Application" class="headerlink" title="CPU和GPU之间的交互流程是怎样的？（Application)"></a>CPU和GPU之间的交互流程是怎样的？（Application)</h3><p>之前提到渲染流水线是在CPU和GPU上进行。我们知道应用阶段在CPU上进行，下面是应用阶段CPU与GPU的交互流程。</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20230714120504270.png" class title="image-20230714120504270">

<ol>
<li><p>CPU控制数据从HDD(硬盘)中加载到显卡的显存（VRAM)中，数据包括位置、顶点着色、法线方向等。</p>
</li>
<li><p>通过CPU指定渲染状态，指导GPU使用哪个顶点/片元着色器，使用哪个光源属性、材质等。</p>
</li>
<li><p>准备好后CPU发起Draw Call命令，GPU根据渲染状态开始渲染。</p>
</li>
</ol>
<p>上面三个阶段为<strong>应用阶段</strong>整个CPU和GPU交互流程。</p>
<p><strong>什么是Draw Call</strong></p>
<p>有一个命令缓冲区，用于CPU和GPU的并行处理。</p>
<p>Draw Call是其中的一道命令，用于发送渲染命令。下图中黄色框就是渲染命令Draw Call,红色是改变状态的命令。</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20230714154621080.png" class title="image-20230714154621080">

<p><strong>尽量减少Draw Call</strong></p>
<p>提交一次Draw Call需要提交数据，状态，命令等，如果一次能够绘制完，就不要分多次Draw Call.</p>
<p>类似于复制10MB的文件很快，但是复制10000个1KB的文件却很慢。</p>
<p>如何减少Draw Call是游戏优化中的一个重要命题。后续会以“优化”为主题详细讨论。</p>
<h3 id="GPU流水线-Geometry-amp-Rasterization"><a href="#GPU流水线-Geometry-amp-Rasterization" class="headerlink" title="GPU流水线(Geometry&amp;Rasterization)"></a>GPU流水线(Geometry&amp;Rasterization)</h3><p>已知几何与光栅化阶段在GPU上进行。以下为总览图。</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20220712135412678.png" class title="image-20220712135412678">

<h4 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h4><ol>
<li><strong>顶点着色器（Vertex Shader)</strong> 负责顶点<code>几何变换</code>和<code>顶点着色</code></li>
</ol>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20220712141429317.png" class title="image-20220712141429317">

<ol start="2">
<li><p><strong>曲面细分、几何着色器</strong>均为可选着色器，前者用来细分图元，后者用来执行图元着色操作和产生图元（增加）。</p>
</li>
<li><p><strong>裁剪</strong></p>
</li>
</ol>
<p>位置分为完全在相机内，部分在相机内，完全不在相机内</p>
<p>裁剪用来处理部分在相机内的部分，将与相机交点替代相机外的部分。</p>
<p>需要注意的是顶点着色器是可编程的，但裁剪却是<strong>不可编程的</strong>，是硬件上的固定操作。</p>
<ol start="4">
<li><strong>屏幕映射</strong></li>
</ol>
<p>输入三维坐标，映射到二维屏幕空间，z不做处理</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20220712142739290.png" class title="image-20220712142739290">

<h4 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h4><ol>
<li>三角形设置</li>
</ol>
<p>已知顶点着色器不会记录点与点之间的关系</p>
<p>该过程用来得到三角形边界表达方式，计算像素覆盖情况。</p>
<ol start="2">
<li><strong>三角形遍历（Triangle Traversal)</strong></li>
</ol>
<p>找到覆盖的像素，生成片元。</p>
<p>一个片元并不是真正意义上的像素，而是包含了很多状态的集合 这些状态用于计算每个像素的最终颜色</p>
<p>对三个顶点进行插值，然后三角形内部颜色由三点渐变(gradient)混合而成。</p>
<ol start="3">
<li><strong>片元着色器（Fragment Shader)</strong></li>
</ol>
<p>DX中又称为像素着色器（Pixel Shader),不过片元不是真正意义上的像素，可编程</p>
<p>纹理采样，对三个顶点插值后，就可以得到片元的纹理坐标，仅可以影响单个片元，无法传递给邻居</p>
<ol start="4">
<li><strong>逐片元操作(Per Fragment Operation)</strong></li>
</ol>
<p>主要进行修改颜色，深度缓冲，混合操作</p>
<p>为OpenGL的说法，DX具体较复杂</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20220712145900074.png" class title="image-20220712145900074">

<p>片元着色器执行后，进行模板测试（Stencil Test)，再开始深度测试(Depth Test)</p>
<p>模板测试是根据比对模板值和reference value来判断（可设置）<strong>是否舍弃片元</strong>。</p>
<p>深度测试则是比对深度，保留深度小的片元。</p>
<p><strong>混合（Blend）</strong>操作，新渲染得到的颜色与颜色缓冲中的已有值做取舍。没有开启混合，计算得到什么，片元得到的就会是什么，也即不透明物体。如果开启了混合模式，会和原有颜色进行插值混合，表现为半透明。</p>
<p><strong>现代GPU硬件特性，深度测试可以在片元着色器之前，但是不能同时。</strong></p>
<p>参照<a href="https://zhuanlan.zhihu.com/p/371245442">深度测试 - 知乎 (zhihu.com)</a></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>【显卡中除了图形处理单元GPU,还有显存(VRAM)】。</p>
<p>光栅化是一个过程，需要时间，为了得到连续图像，采样双缓冲机制（Double Buffering),Back Buffer计算新场景，Front Buffer显示当前场景，交换循环。</p>
<p>OpenGL、DX是CPU和GPU之间的桥梁，图形接口（api) （严格来说OpenGL不是图形api？,但是可以这么理解)</p>
<p><strong>更详细地说</strong></p>
<p>OpenGL没有提供着色器编译器，显卡驱动自己完成编译工作，GLSL的跨平台性在于编译结果依赖于硬件本身，而非局限于操作系统。不同显卡供应商的实现有所不同。</p>
<p>HLSL是针对微软产品的。不依赖于显卡驱动。</p>
<p>CG是跨平台的，根据不同平台翻译成中间语言，由于合作关系，和HLSL很像。但是可能无法发挥OpenGL新特性。</p>
<img src="/2022/10/21/UnityShader/chapter1%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/image-20230714152730652.png" class title="image-20230714152730652">vv

<p>提到了OpenGL和DX，就不得不提到Unity本身的跨平台性，两者坐标系不同，但是Unity自身提供翻转（开了抗锯齿+渲染到纹理就失效）</p>
<p>最后提一嘴，固定渲染管线由于对开发者极弱的开放性，渐渐退出历史舞台。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
  </entry>
  <entry>
    <title>chapter2 Unity Shader概述</title>
    <url>/2022/10/22/UnityShader/chapter2ShaderLab/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>【注】因为是概述，很多细节和需要查询的内容请参考《Unity Shader入门精要》</p>
<p>上一章描述了什么是渲染流水线，这一章主要讨论什么是Unity Shader。</p>
<p>Shader 翻译为着色器，GPU流水线中对于高度可编程的阶段来说，Shader是可以在GPU上运行的渲染代码；而对于固定流水线来说，则起着渲染设置的作用。前者有顶点着色器，片元着色器等。</p>
<p>正常情况下，开发者需要与下图中各种操作、文件打交道。</p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20230714160639163.png" class title="image-20230714160639163">

<p>因为我们是在引擎上使用shader,Unity 提供了名为Unity Shader的抽象。于是我们只需要使用unity shader就可以控制所有操作。并且必要的内部功能已经写好。</p>
<p><strong>与其它着色语言的关系</strong></p>
<p>我们知道着色器语言主要有CG,HLSL,GLSL。</p>
<p>不同于它们，Unity中开发者使用的着色器语言叫做<code>ShaderLab</code>，语法上<code>shaderlab</code>和CG,HLSL没有太大区别，部分函数Unity没有提供；本质上<code>shaderlab</code>是基于它们的封装。</p>
<p>虽然Unity只支持封装后的CG,HLSL,但是如果要写GLSL也是可行的（不推荐）。</p>
<h2 id="Unity-Shader-基本介绍"><a href="#Unity-Shader-基本介绍" class="headerlink" title="Unity Shader 基本介绍"></a>Unity Shader 基本介绍</h2><h3 id="Unity-Shader-结构"><a href="#Unity-Shader-结构" class="headerlink" title="Unity Shader 结构"></a>Unity Shader 结构</h3><p>Unity主要有<code>Standard Surface Shader, Unlit Shader, Image Effect Shader</code> 以及 <code>Compute Shader</code>。</p>
<p><strong>Unity Shader基本结构</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;ShaderName&quot;</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡A</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡B</span></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Properties 声明</strong></p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20220713074058424.png" class title="image-20220713074058424">

<p>Properties 语义块的作用仅仅是为了让这些属性可以出现在材质面板中。</p>
<p><strong>Sub Shader</strong></p>
<p>真正意义上的Shader语义块都在这里面。</p>
<p>Tags可以进行设置</p>
<p><code>Tags&#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;</code>  设置渲染顺序</p>
<p><strong>Pass</strong></p>
<p>设置渲染状态</p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20220713090702796.png" class title="image-20220713090702796">

<p>首先Pass的命名<code>Name&quot;MyPassName&quot;</code></p>
<p>调用其他Unity Shader中的Pass <code>UsePass &quot;MyShader/MyPassName&quot;</code></p>
<p><code>Pass</code>中的Tags与<code>SubShader中</code>的一样,都是用于设置渲染状态,具体的<strong>控制内容不同</strong>。</p>
<p>详情见《Unity Shader入门精要》P3。下图为Pass中的标签类型。</p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20220713091457211.png" class title="image-20220713091457211">

<p>【补充】<code>GrabPass</code>关键字可以将渲染结果存储到纹理中，详情参照原书。</p>
<p><strong>Fall Back</strong></p>
<p><code>FallBack &quot;name&quot;</code>，如果其它Sub Shader都没用，就用这个指定的</p>
<p><code>FallBack off </code>关闭，不管了</p>
<p><code>FallBack &quot;VertexLit&quot; </code>调用内置的Shader中的Pass</p>
<p><strong>结构</strong></p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20220713092133474.png" class title="image-20220713092133474">

<h3 id="Unity上的着色器"><a href="#Unity上的着色器" class="headerlink" title="Unity上的着色器"></a>Unity上的着色器</h3><p><strong>表面着色器</strong></p>
<p>(Surface Shader) 已经写好，开发者可编程内容少。不需要Pass包裹，引擎自行处理</p>
<p>本质上可以理解为顶点、片元着色器的进一步抽象，Unity中的Shader代码一般如上图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;&quot;RenderType&quot; = &quot;Opaque&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #pragma surface surf Lambert</span><br><span class="line">        struct Input&#123;</span><br><span class="line">            float4 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顶点/片元着色器</strong></p>
<p>（Vertex/Fragment Shader)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot;&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM //用来包裹ShaderLab语言</span><br><span class="line">        #pragma vertex vert</span><br><span class="line">        #pragma fragment frag</span><br><span class="line">        </span><br><span class="line">        float4 vert(float4 v : POSITION) :SV_POSITION&#123;</span><br><span class="line">            return mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        float4 frag() : SV_Target&#123;</span><br><span class="line">            return fixed4(1.0,1.0,0.0,1.0);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>固定函数着色器落后不讨论</p>
<p><strong>从结果上来讲，Unity Shader只包含顶点片元两种可编写部分</strong></p>
<p>表面着色器中<code>SubShader</code>的CG代码会被Unity细分到Pass。</p>
<h3 id="Unity-Shader语法与语义"><a href="#Unity-Shader语法与语义" class="headerlink" title="Unity Shader语法与语义"></a>Unity Shader语法与语义</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chaper5/Simple Shader&quot;</span> &#123; </span><br><span class="line">    SubShader &#123; </span><br><span class="line">    Pass &#123; <span class="comment">//自定义渲染设置</span></span><br><span class="line">        CGPROGR</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert </span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line">        <span class="function">float4 <span class="title">vert</span>(<span class="params">float4 v: POSITION</span>) : SV POSITION</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> mul (UNITY MATRIX MVP, v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function">fixed4 <span class="title">frag</span>() : SV_Target</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(<span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器中</li>
</ul>
<p>POSITION和SV_POSITION是CG/HLSL中的语义（semantic)不可省略。</p>
<p>POSITION告诉Unity将模型的坐标作为输入参数输入到v中。</p>
<p>而SV_POSITION则告诉Unity返回裁剪坐标。</p>
<ul>
<li>片元着色器中</li>
</ul>
<p>SV_TARGET也是一个语义，告诉系统将渲染输出存储到渲染目标，默认输出到帧缓存。（1，1，1）表示白色，这里返回了白色。</p>
<p>结构体用来定义着色器的输入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> a2v&#123;   <span class="comment">//a2v意思是将应用阶段数据传到顶点着色器</span></span><br><span class="line">    <span class="comment">//用模型坐标填充</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    <span class="comment">//用法线方向填充</span></span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    <span class="comment">//TEXCOORD0告诉系统用第一条纹理坐标填充</span></span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unity <strong>支持的语义有：</strong> POSITION, TANGENT, NORMAL, TEXCOORDO, TEXCOORDJ, TEXCOORD2, TEXCOORD3, COLOR 等。</p>
<p><code>struct StructName&#123;TypeName name : Semantic;&#125;;</code></p>
<h4 id="顶点与片元着色器通信"><a href="#顶点与片元着色器通信" class="headerlink" title="顶点与片元着色器通信"></a>顶点与片元着色器通信</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f&#123; <span class="comment">//从顶点着色器到片元</span></span><br><span class="line">    <span class="comment">//pos中包含了裁剪空间的位置信息</span></span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    <span class="comment">//COLOR0用来存储颜色信息</span></span><br><span class="line">    float3 color : COLOR0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为完整代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Simple Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			<span class="comment">//将模型坐标输入到顶点着色器</span></span><br><span class="line">            <span class="keyword">struct</span> a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">			<span class="comment">//将顶点数据输出到片元</span></span><br><span class="line">            <span class="keyword">struct</span> v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//顶点着色器，逐顶点调用</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span>+fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//逐片元调用</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">    <span class="comment">// shaderlab的变量</span></span><br><span class="line">	_Color(<span class="string">&quot;Color Tint&quot;</span>,Color) = (<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意的是，在CG代码中需要定义出名称类型都一致的变量</span></span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">    Pass&#123;</span><br><span class="line">        <span class="comment">// CG片段</span></span><br><span class="line">        CGPROGRAM</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别ShaderLab和CG的变量</p>
<img src="/2022/10/22/UnityShader/chapter2ShaderLab/image-20220714112206997.png" class title="image-20220714112206997">



<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>已知真正的Shader不是简单的一个<code>.shader</code>文件。</p>
<p>UnityShader 的方便性使得不用开发者自己转换法线方向，处理光照阴影等。</p>
<p>类似于C++的头文件,写在CG中，根据情况下载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ENGCG</span><br></pre></td></tr></table></figure>

<h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>ColorPicker.cs绑定摄像机，获取屏幕RGB值</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>有关CG/HLSL的语义，可参照微软DX文档</p>
<p>语义主要是用来限定输入输出的字符串，决定输入输出来源去向，方式等。</p>
<p>SV（system value semantics)</p>
<p>定义复杂变量类型时，需要注意，一个语义，寄存器只能存储4个浮点数，所以可以采取分成4个变量表示一个矩阵</p>
<p>【注意】shader中不要除以0，会造成意想不到的错误。</p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
  </entry>
  <entry>
    <title>chapter3 Unity Shader常用变量及函数</title>
    <url>/2022/10/24/UnityShader/chapter3UnityShaderAPI/</url>
    <content><![CDATA[<h2 id="Unity-Shader常用变量及函数"><a href="#Unity-Shader常用变量及函数" class="headerlink" title="Unity Shader常用变量及函数"></a>Unity Shader常用变量及函数</h2><h3 id="顶点的坐标空间变换流程及推导"><a href="#顶点的坐标空间变换流程及推导" class="headerlink" title="顶点的坐标空间变换流程及推导"></a>顶点的坐标空间变换流程及推导</h3><ul>
<li><p>MVP的推导详情见我的图形学分类下的<a href="https://aspect-ux.github.io/2023/05/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation/">Transformation</a>)</p>
</li>
<li><p>至此到了裁剪空间（投影空间），要想变换到屏幕空间</p>
<ul>
<li>经过齐次除法/透视除法（除以w),得到NDC坐标（归一化设备坐标）</li>
<li>视口变换（viewport transformation),详情见<a href="https://aspect-ux.github.io/2023/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rasterization/">Rasterization</a>)</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>从模型空间到世界空间，再到观察空间，然后裁剪空间，最后屏幕映射到屏幕空间。需要许多变换矩阵。</p>
<img src="/2022/10/24/UnityShader/chapter3UnityShaderAPI/image-20220714095415512.png" class title="image-20220714095415512">

<h3 id="法线变换（特例）"><a href="#法线变换（特例）" class="headerlink" title="法线变换（特例）"></a>法线变换（特例）</h3><p>这里需要额外提及unity的法线变换</p>
<img src="/2022/10/24/UnityShader/chapter3UnityShaderAPI/image-20230714182242926.png" class title="image-20230714182242926">

<p>发现法线变换失败</p>
<p>设切线为T，法线为N</p>
<img src="/2022/10/24/UnityShader/chapter3UnityShaderAPI/image-20230714182607030.png" class title="image-20230714182607030">



<h3 id="屏幕相机参数（API"><a href="#屏幕相机参数（API" class="headerlink" title="屏幕相机参数（API)"></a>屏幕相机参数（API)</h3><img src="/2022/10/24/UnityShader/chapter3UnityShaderAPI/image-20230714182950853.png" class title="image-20230714182950853">

<img src="/2022/10/24/UnityShader/chapter3UnityShaderAPI/image-20230714183009964.png" class title="image-20230714183009964">



<p>【此章待补充，用于记录unity shader CG/HLSL的语法区别和API应用】</p>
<h3 id="DX和OpenGL-CG和HLSL-Built-in和URP之间的差异"><a href="#DX和OpenGL-CG和HLSL-Built-in和URP之间的差异" class="headerlink" title="DX和OpenGL / CG和HLSL / Built-in和URP之间的差异"></a>DX和OpenGL / CG和HLSL / Built-in和URP之间的差异</h3>]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要9</title>
    <url>/2022/11/07/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/</url>
    <content><![CDATA[<h2 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h2><h3 id="立方体纹理（CubeMap"><a href="#立方体纹理（CubeMap" class="headerlink" title="立方体纹理（CubeMap)"></a>立方体纹理（CubeMap)</h3><p>立方体纹理映射技术是实现环境映射的一种方法，还应用于Skybox</p>
<p>1.新建skybox类型的材质，填充6张中级篇Chapter10，设置为Wrap Mode设置为Clamp使得衔接顺畅;</p>
<p>2.创建用于环境映射的<code>CubeMap</code></p>
<p>环境映射技术最常见的应用是<strong>反射</strong>和<strong>折射</strong></p>
<ul>
<li>反射</li>
</ul>
<p><code>lerp(y1,y2,weight) = y1 + (y2-y1)*weight;</code></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">fixed3 reflection = texCUBE(_CubeMap,i.worldRefl).rgb * _Reflection.rgb;<span class="comment">//在立体纹理中采样</span></span><br><span class="line"></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</span><br><span class="line">float3 color = ambient + lerp(diffuse,reflection,_ReflectionAmount) *atten;<span class="comment">//有反射，无高光</span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/07/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213048053.png" class title="uTools_1661213048053">

<ul>
<li>折射(Refraction)</li>
</ul>
<p>​    计算折射</p>
<img src="/2022/11/07/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661213306951.png" class title="uTools_1661213306951">

<p>**斯涅尔定律(Snell’s law)**，m1 *sin(a) = m2 * sin(a2)，m1,m2 分别为折射率。真空折射率是1，玻璃的折射率是1.5</p>
<p>玻璃一般分为两次折射，但第二次折射较复杂，一般只模拟第一次折射。</p>
<img src="/2022/11/07/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter10/uTools_1661218211269.png" class title="uTools_1661218211269">

<p><strong>菲涅耳反射</strong></p>
<p>（Fresnel Reflection)</p>
<p>比如看远处的水会反光，这就是菲涅耳反射；不仅透明物体，很多不透明物体或多或少都存在菲涅耳反射。</p>
<p>F(V ,D)=F0+(l-F0)(1-v·n)^5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed fresnel = _FresnelScale + (1-_FresnelScale) * pow(1-dot(worldViewDir,worldNormal),5);</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">return fixed4(color, 1.0);</span><br></pre></td></tr></table></figure>



<h3 id="渲染目标纹理"><a href="#渲染目标纹理" class="headerlink" title="渲染目标纹理"></a>渲染目标纹理</h3><p>现代GPU允许将三维场景渲染到中间缓冲，即渲染目标纹理（Render Target Texture)</p>
<p><strong>使用渲染纹理模拟镜子效果</strong></p>
<p>见P219</p>
<p><strong>玻璃效果</strong></p>
<p>to be studyed</p>
<h3 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h3><p>SetProperty，该插件用于在Unity面板上修改材质属性，并通过_UpdateMaterial()函数来使用新的属性生成程序<a href="https://so.csdn.net/so/search?q=%E7%BA%B9%E7%90%86&spm=1001.2101.3001.7020">纹理</a>。</p>
<p><em>示例</em> :<code>ProceduralTextureGeneration.cs</code></p>
<p>代码首先初始化 维纹理，并且提前计算了 些生成纹理时需要的变队。然后，使用了</p>
<p>个两层的嵌套循环遍历纹理中的每个像素，并在纹理七依次绘制 个圆形 。最后，调用</p>
<p>Texture2D.Apply 函数来强制把像素值写入纹理中，并返回该程序纹理。</p>
<p><strong>unity中有一种程序材质专门使用程序纹理。而程序纹理是通过算法实现的效果。</strong></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要9</title>
    <url>/2022/11/03/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter9/</url>
    <content><![CDATA[<h2 id="Complex-Light-Chapter9"><a href="#Complex-Light-Chapter9" class="headerlink" title="Complex Light - Chapter9"></a>Complex Light - Chapter9</h2><h3 id="渲染路径（Rendering-Path"><a href="#渲染路径（Rendering-Path" class="headerlink" title="渲染路径（Rendering Path)"></a>渲染路径（Rendering Path)</h3><p><strong>分为前向渲染路径，延迟渲染路径(更新），顶点渲染路径（弃用）</strong></p>
<p>1.前向渲染路径，如果深度测试不过关，该片元不可见，反之可见，就进行光照计算</p>
<p>2.如果物体受到多个光源照射，就要写多个Pass,然后在帧缓冲中将这些光照结果混合。</p>
<p>3.前向渲染中，光照类型（平行光parallel light或其他）+光照渲染模式（important)决定了处理光照（照亮物体）的方式。</p>
<p>而处理方式分为逐像素，逐顶点、sh计算。</p>
<p>参见P182</p>
<h3 id="Unity光源类型"><a href="#Unity光源类型" class="headerlink" title="Unity光源类型"></a>Unity光源类型</h3><p>1.平行光、点光源、<em>面光源</em>和<em>聚光灯</em>，面光源只在烘焙时才会产生作用</p>
<p>2.当RenderMode是Auto,Unity自动判断哪些光源逐像素，哪些顶点、sh计算。</p>
<p>3.最亮的平行光是按照逐像素计算，而Auto状态下最多除平行光源外4个逐像素计算，这些在addtional pass中计算</p>
<p><strong>最常用的光源属性有：位置、方向、颜色、强度、衰减</strong></p>
<ul>
<li>光照衰弱</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用纹理来计算衰弱值</span></span><br><span class="line"><span class="keyword">fixed</span> atten = tex2D(_ ghtTextureO, dot(lightCoord, lightCoord) .rr) .UNITY_ATTEN_CHANNEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数学公式进行线性衰弱值计算</span></span><br><span class="line"><span class="built_in">float</span> distance = length (_WorldSpaceLightPosO . xyz - i. worldPosi <span class="keyword">on</span>.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> <span class="comment">// distance; // linear attenuation</span></span><br></pre></td></tr></table></figure>



<h3 id="Unity阴影"><a href="#Unity阴影" class="headerlink" title="Unity阴影"></a>Unity阴影</h3><p>1.如果最重要的平行光开启了阴影，那么Unity会为这个光源生成<em>阴影纹理图</em>，一种由光源出发的深度图。</p>
<p>2.另取一个LightMode为ShadowCaster的Pass,Unity会将摄像头放到光源的地方</p>
<p>3.一个物体想要接收阴影，那么在shader中要对纹理采样；相同地，一个物体想要投射阴影，就要参与纹理计算</p>
<p>见P200</p>
<ul>
<li>如何让正方体接收阴影</li>
</ul>
<p>SHADOWCOORD,TRANSFER_SHADOW,SHADOW_ATTENUATION分别在v2f,vert,frag中调用</p>
<p>实现接收阴影</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHADOW_COORDS(2)</span><br><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure>



<p><strong>光照衰减和阴影的效果是一样的，于是就有了统一光照衰弱和阴影</strong></p>
<p>unity提供一个方法同时管理这两者</p>
<p><code>UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</code></p>
<ul>
<li><p>透明物体的阴影</p>
<p>在AlphaTest的基础上使用上述方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要11</title>
    <url>/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/</url>
    <content><![CDATA[<h2 id="Chapter11-让画面动起来"><a href="#Chapter11-让画面动起来" class="headerlink" title="Chapter11-让画面动起来"></a>Chapter11-让画面动起来</h2><h3 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h3><p>1.序列帧动画</p>
<p>….</p>
<p>2.滚动背景</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//frac函数返回标量或每个矢量中各分量的小数部分。return v - floor(v);</span><br><span class="line">o.uv.xy = TRANSFORM_TEX(v.texcoord,_MainTex) + frac(float2(_ScrollX,0.0)*_Time.y);</span><br><span class="line">o.uv.zw = TRANSFORM_TEX(v.texcoord,_DetailTex) + frac(float2(_Scroll2X,0.0)*_Time.y);</span><br><span class="line">//可以发现当x乘上一个小于1的值时，系数越小，呈现的图像结果会越稀疏</span><br></pre></td></tr></table></figure>

<p>函数如下图</p>
<img src="/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661861601610.png" class title="uTools_1661861601610">

<p>frac(float)等价上图</p>
<p>frac(float2())则等价于以圆心为原点，以这个点为起点的线为半径，每过v的长度，为一个周期。最后构成多重圆环。而横坐标</p>
<p>的倍率则影响密度。倍率大于1，噪声越大，间隔小，密度大。</p>
<p><font color="red">如果渲染2d物体，可以将相机模式转换成正交模式</font></p>
<p>3.水波动画</p>
<p>由于本例中需要移动模型空间坐标，而批处理会使得相关模型合并，使得相关模型丢失原来模型空间；所以一般有顶点移动anime的shader要考虑关闭batch;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tags&#123;</span><br><span class="line">    &quot;RenderType&quot;=&quot;Transparent&quot;,</span><br><span class="line">    &quot;IgnoreProjector&quot; = &quot;True&quot;,</span><br><span class="line">    &quot;RenderType&quot; = &quot;Transparent&quot;,</span><br><span class="line">    &quot;DisableBatching&quot; = &quot;True&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如何形成水波？顶点着色器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float4 offset;</span><br><span class="line">offset.yzw = float3(0.0,0.0,0.0);</span><br><span class="line">offset.x = sin(_Frequency * _Time.y +v.vertex.x * _InWaveLength + v.vertex.y *</span><br><span class="line">_InWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line"></span><br><span class="line">o.pos = mul(UNITY_MATRIX_MVP,v.vertex + offset);</span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord,_MainTex); //将纹理进行uv映射</span><br><span class="line">o.uv += float2(0.0,_Time.y * Speed);      //将uv的v根据时间变化进行增长</span><br></pre></td></tr></table></figure>

<p>等价于<br>$$<br>x = Magnitude * sin(_Frequency * t+w * vertex)<br>$$<br>由此使得水波水平变化。</p>
<p>同时还用了纹理动画，产生水平的纹理动画。</p>
<p>4.广告牌技术</p>
<p>效果：星星始终面朝摄像机，向上的位置并未改变，当y轴转动，也会跟着转动</p>
<p><em>代码</em></p>
<p>1.获取模型空间的中心和相机点</p>
<p>2.将法线设为从中心点指向相机的方向</p>
<p>3.将法线y方向乘以_VerticalBillboarding，并归一化</p>
<p>4.一般来说，法线并不等于up向量，up向量为（0，1，0）,但是随着视点的转变，法线也会变，如果法线等于up，</p>
<p>​    那么后续叉乘的结果会出错。此时up会变成向前的向量。</p>
<p>5.然后是right向量，由前两个向量叉乘得到，需要归一化，至此三个正基向量得到。</p>
<p>6.<code>float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</code></p>
<p>​    最后实现顶点坐标在模型空间，三个分量不同程度的形变，</p>
<p>​    <strong>结果是：</strong><font color="red">错误</font>_VerticalBillboarding=1，星星就像是跟踪屏幕；</p>
<p>​    _VerticalBillboarding= 0星星固定，有透视效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顶点动画都是在模型空间变换</span><br><span class="line">v2f vert (a2v v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			</span><br><span class="line">			//1.</span><br><span class="line">			float3 center = float3(0, 0, 0);</span><br><span class="line">			float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, 1));</span><br><span class="line">			</span><br><span class="line">			//2.</span><br><span class="line">			float3 normalDir = viewer - center;</span><br><span class="line">			</span><br><span class="line">			//3.</span><br><span class="line">			// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span><br><span class="line">			// Which means the normal dir is fixed</span><br><span class="line">			// Or if _VerticalBillboarding equals 0, the y of normal is 0</span><br><span class="line">			// Which means the up dir is fixed</span><br><span class="line">			normalDir.y =normalDir.y * _VerticalBillboarding;</span><br><span class="line">			normalDir = normalize(normalDir);</span><br><span class="line">			</span><br><span class="line">			//4.</span><br><span class="line">			// Get the approximate up dir</span><br><span class="line">			// If normal dir is already towards up, then the up dir is towards front</span><br><span class="line">			float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">			float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">			upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line">			</span><br><span class="line">			// Use the three vectors to rotate the quad</span><br><span class="line">			float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">			float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">             </span><br><span class="line">			o.pos = UnityObjectToClipPos(float4(localPos, 1));</span><br><span class="line">			o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">			return o;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/11/09/UnityShader/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter11/uTools_1661943292280.png" class title="uTools_1661943292280">

]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
      <tags>
        <tag>shader动画</tag>
      </tags>
  </entry>
  <entry>
    <title>unityshader精要12</title>
    <url>/2022/11/10/UnityShader/%E9%AB%98%E7%BA%A7%E7%AF%87Chapter12/</url>
    <content><![CDATA[<h1 id="屏幕后处理"><a href="#屏幕后处理" class="headerlink" title="屏幕后处理"></a>屏幕后处理</h1><p>顾名思义，在屏幕渲染完成后，制作特效等使得整体画面进一步提升艺术感。</p>
<p><code>onRenderImage</code>属于抓取屏幕的函数，应用在所有透明和不透明渲染完成后</p>
<h3 id="Unity中实现屏幕后处理"><a href="#Unity中实现屏幕后处理" class="headerlink" title="Unity中实现屏幕后处理"></a>Unity中实现屏幕后处理</h3><p><code>PostEffectsBase.cs </code>用于检验shader和material，并且通过脚本面板更改数据；如果不符合要求，则脚本失效.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先注意</span></span><br><span class="line"><span class="comment">//unity 有三种模式，player mode,edit mode(正常模式)，prefab mode(进入预制体更改)</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResource</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;This platform does not support image effects or render texture....&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 如果shader，material同时有效；如果shader有效。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;shader&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;material&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shader == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有shader就直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> material;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">            material.hideFlags = HideFlags.DontSave;</span><br><span class="line">            <span class="keyword">if</span> (material) <span class="keyword">return</span> material;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="调整屏幕亮度、饱和度、对比度"><a href="#调整屏幕亮度、饱和度、对比度" class="headerlink" title="调整屏幕亮度、饱和度、对比度"></a>调整屏幕亮度、饱和度、对比度</h4><p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 renderTex = tex2D(_MainTex, i.uv);</span><br><span class="line">                </span><br><span class="line">                //Apply Brightness</span><br><span class="line">                fixed3 finalColor = renderTex.rgb * _Brightness;</span><br><span class="line">                </span><br><span class="line">                //Apply Saturation</span><br><span class="line">                fixed luminance= 0.2125 * renderTex.r + 0 . 7154 * renderTex . g + 0.0721 * renderTex.b;</span><br><span class="line">                fixed3 luminanceColor = fixed3(luminance,luminance,luminance);</span><br><span class="line">                finalColor = lerp(luminanceColor,finalColor,_Saturation); //饱和度是色彩的鲜艳程度或纯度</span><br><span class="line">                </span><br><span class="line">                //Apply Contrast</span><br><span class="line">                fixed3 avgColor = fixed3(0.5,0.5,0.5);</span><br><span class="line">                finalColor = lerp(avgColor,finalColor,_Contrast);</span><br><span class="line">                </span><br><span class="line">                return fixed4(finalColor,renderTex.a);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>1.直接相乘得到亮度</p>
<p>2.计算亮度值luminance;</p>
<p>3.使用饱和度在上一步颜色和亮度值之间插值</p>
<p>4.对比度类似。</p>
<h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p>利用边缘检测算子对图像进行<strong>卷积</strong></p>
<p>如果我们想要对图像进行均值模糊，可以使用一个 3x3 的卷积核，核内每个元素的值均为 1/9。</p>
<p>见P249</p>
<p>在进行边缘检测时，我们需要对每个像素进行卷积计算，有两个方向的梯度。</p>
<p>整体梯度公式为<br>$$<br>G = sqrt(Gx^2 + Gy^2)<br>$$<br>出于性能考虑，一般也用绝对值取代开根号。</p>
<p><strong>使用Sobel算子实现描边</strong></p>
<p><strong>顶点着色器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2f vert (appdata_img v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                half2 uv = v.uv;</span><br><span class="line">                </span><br><span class="line">                o.uv[0] = uv + _MainTex_TexelSize.xy * half2(-1, -1);</span><br><span class="line">				o.uv[1] = uv + _MainTex_TexelSize.xy * half2(0, -1);</span><br><span class="line">				o.uv[2] = uv + _MainTex_TexelSize.xy * half2(1, -1);</span><br><span class="line">				o.uv[3] = uv + _MainTex_TexelSize.xy * half2(-1, 0);</span><br><span class="line">				o.uv[4] = uv + _MainTex_TexelSize.xy * half2(0, 0);</span><br><span class="line">				o.uv[5] = uv + _MainTex_TexelSize.xy * half2(1, 0);</span><br><span class="line">				o.uv[6] = uv + _MainTex_TexelSize.xy * half2(-1, 1);</span><br><span class="line">				o.uv[7] = uv + _MainTex_TexelSize.xy * half2(0, 1);</span><br><span class="line">				o.uv[8] = uv + _MainTex_TexelSize.xy * half2(1, 1);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>使用Sobel算子采样，并且将采样代码转到顶点着色器，减少运算。并且由于顶点到片元的插值是线性的，所以并不会影响结果。</p>
<p><strong>edge计算</strong></p>
<p>计算9块像素的亮度，并且将水平和竖直方向的对应梯度和计算出来。最后1减去两者绝对值。</p>
<p><em>得到的edge越小，越有可能是边缘</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line">        const half Gx[9] = &#123;-1,  0,  1,</span><br><span class="line">        -2,  0,  2,</span><br><span class="line">        -1,  0,  1&#125;;</span><br><span class="line">        const half Gy[9] = &#123;-1, -2, -1,</span><br><span class="line">        0,  0,  0,</span><br><span class="line">        1,  2,  1&#125;;		</span><br><span class="line">        half texColor;</span><br><span class="line">        half edgeX = 0;</span><br><span class="line">        half edgeY = 0;</span><br><span class="line">        for (int it = 0; it &lt; 9; it++) &#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"></span><br><span class="line">        return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>片元着色器</strong></p>
<p>利用Sobel得到梯度值edge后，分别计算贴图和纯色背景下的颜色值。</p>
<p>最后利用<code>_EdgeOnly</code>在两者之间取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">        half edge = Sobel(i);</span><br><span class="line"></span><br><span class="line">        fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line">        fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">        return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h4><p>卷积的另一个应用是高斯模糊</p>
<p>见P253</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">			<span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">			RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">			buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">				material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">				RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the vertical pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">				buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the horizontal pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(buffer0, dest);</span><br><span class="line">			RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>详情见P257</p>
<p>使用五个高斯核</p>
<p><strong>注：</strong>使用<code>CGINCLUDE</code>可以将顶点片元着色器包住，达到多个pass使用同一份着色器代码及其声明。</p>
<p>没看懂…….</p>
<h4 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a>Bloom效果</h4><p>根据某个阈值提取出画面中较亮的区域，然后通过高斯模糊，模拟光线扩散的结果。</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>chapter3 Unity 基础光照</title>
    <url>/2022/10/27/UnityShader/chapter4Unity%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    <content><![CDATA[<h1 id="Unity中的基本光照"><a href="#Unity中的基本光照" class="headerlink" title="Unity中的基本光照"></a>Unity中的基本光照</h1><p>光线是如何产生的，光源发射光，一些物体与光交互，吸收一些光，散射一些光，而摄像机吸收一些光，形成了图像。在光学中，使用<strong>辐照度</strong>（irradiance)来量化光。</p>
<p>那么如何计算辐照度呢？</p>
<p>辐照度与照射到物体表面光线之间的距离<code>d/cosx</code>成反比。</p>
<p>当光垂直下落<code>cosx=1</code>,那么距离为d</p>
<p>当光与竖直方向呈x度角，距离为<code>d/cosx</code></p>
<p>其中x可以由表面法线n和光源方向l的点积得到。</p>
<h2 id="光与物体相交一般两种结果：散射与吸收"><a href="#光与物体相交一般两种结果：散射与吸收" class="headerlink" title="光与物体相交一般两种结果：散射与吸收"></a>光与物体相交一般两种结果：散射与吸收</h2><ul>
<li>**散射（scatering)**只改变光线方向，不改变光线的密度和颜色。</li>
</ul>
<p>散射的光线一般有两种方向，一种是向物体内部散射，叫做<strong>折射（refraction)或透射（transmission)</strong>;</p>
<p>另一种是**反射（reflection)**到外部。</p>
<ul>
<li><strong>吸收（absorption)</strong> 则相反，只改变光线密度和颜色。对于不透明物体向物体内部折射时，一部分被吸收，一部分与内部粒子相交并反射出去</li>
</ul>
<p>为了区分两种散射，用<strong>高光反射</strong>（specular)和<strong>漫反射</strong>（diffuse)分别表示物体如何反射以及计算多少光线折射、吸收(absorption)、反射出表面。</p>
<p><strong>根据光线的入射方向和入射量可以得到出射方向和出射量，称之为出射度（exitance)</strong></p>
<p>辐照与出射成线性关系，比值为漫反射和高光。</p>
<h5 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h5><p>根据一系列的信息得到计算出射度的等式，也即光照模型。（lighting model )</p>
<h5 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h5><ul>
<li><p>自发光（emissive) 光线直接由光源进入摄像机，直接用材质的自发光颜色。</p>
</li>
<li><p>高光反射（specular)</p>
</li>
<li><p>漫反射（diffuse)</p>
<p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间角的余弦值 成正比。因此， 漫反射部分的计算如下</p>
<img src="/2022/10/27/UnityShader/chapter4Unity%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20220715170258041.png" class title="image-20220715170258041">

<p>c light 和 m diffuse 分别表示光源颜色和漫反射颜色</p>
</li>
<li><p>环境光（ambient) 一般是全局变量</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
  </entry>
  <entry>
    <title>Ray Tracing(光线追踪)(上)</title>
    <url>/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/</url>
    <content><![CDATA[<h1 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h1><p>光线追踪和光栅化是两种不同的成像方式，为什么要选择光线追踪呢？</p>
<p>光栅化的局限性在于全局效果的控制： 1. 不能实现软阴影 2. 光照不能反射超过1次（目前技术可行效果不好）</p>
<p>光栅化很快，效果却不好。</p>
<p>相反，光线追踪很慢，但是很精确</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716162845299.png" class title="image-20230716162845299">

<h1 id="Light-Rays"><a href="#Light-Rays" class="headerlink" title="Light Rays"></a>Light Rays</h1><p>Three ideas about light rays(满足三个假设的前提)</p>
<ul>
<li>Light travels in straight lines(though this is wrong) 光线沿直线传播</li>
<li>Light rays do not “collide” with each other if they cross(also wrong) 光线之间无碰撞</li>
<li>Light rays travel from the light source to the eye(but the physics is in variant under path reversal - reciprocity) (光线可逆性，可以理解为光的方向互逆)</li>
</ul>
<p>正常情况下，我们的理解是光源打光到物体上，物体反射光照到人眼，根据反射的颜色我们看到物体。</p>
<p>而在光线追踪的过程中，我们在做这样一件事：</p>
<p>从眼睛（相机）出发，投射光线，光线看到的就是人看到的。终点变成了起点，也即上述第三点中的可逆性。</p>
<ol>
<li>记录最近的点 2. 判断这个点是否看得见</li>
</ol>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/76.png" class width="76">

<p>上图中，眼睛就是入射光，指向光源就是出射光，法线确定后，着色就确定了。</p>
<p>光线如何反射多次呢？</p>
<h1 id="Basic-Ray-Tracing-Algorithm-基本光线追踪算法"><a href="#Basic-Ray-Tracing-Algorithm-基本光线追踪算法" class="headerlink" title="Basic Ray Tracing Algorithm(基本光线追踪算法)"></a>Basic Ray Tracing Algorithm(基本光线追踪算法)</h1><p><strong>Whitted-Style</strong></p>
<p>射线经过递归弹射（recursively bounce),得到了若干弹射点，如果光源能够照射到该点，着色则会add到结果中</p>
<p>eye : primary ray</p>
<p>light: shadow ray</p>
<p>ref: secondary rays</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716170734885.png" class title="image-20230716170734885">

<h2 id="Ray-Surface-Intersection-求交点"><a href="#Ray-Surface-Intersection-求交点" class="headerlink" title="Ray Surface Intersection(求交点)"></a>Ray Surface Intersection(求交点)</h2><p>如何定义光线？一个起点，一个方向，随时间变化</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/78.png" class width="78">

<p>如何求交？</p>
<p><strong>拿光线与球（隐式表面）</strong>进行求交来说。满足下图两个式子，联立后得二次方程。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/79.png" class width="79">

<p>求解后得</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716180041106.png" class title="image-20230716180041106">

<p>光线求交需要最近的点，在确保t是有意义的后，选取最小的t就是光线与求的交点</p>
<p>总结，光线与隐式表面求交方程</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716180332940.png" class title="image-20230716180332940">

<p><strong>Ray intersection with triangle mesh(explicit显示表面)</strong></p>
<p>封闭几何中，光线与几何交点数为奇数，则光线在三角内；否则在三角形外。</p>
<p>查看所有三角形是否与光线有交点。</p>
<p>将求交问题分解成两个</p>
<ol>
<li>如何让光线与平面求交</li>
<li>交点是否在三角形内（已知）</li>
</ol>
<p>问题聚焦到如何求光线与平面交点。</p>
<p>用一条法线+一个点定义一个平面。接下来只用判断交点连线已知点得到的向量与法线的关系。</p>
<p>设平面上已知一点p’,p为交点，N是法线向量。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716181507181.png" class title="image-20230716181507181">

<p><strong>Moller Trumbore Algorithm</strong></p>
<p>光线与三角形求交的另一个更快的方法。</p>
<p><strong>【注意】</strong>这里有一个理解上的问题，也即是o+td到底是什么的问题。在一定时间范围内，它是一条射线；但是在某一个时刻，它是一个点。在计算中，我们考虑交点，其实也就是某一个时刻的角度来看。所以在涉及计算的时候，我们都是把它当作一个点来看。</p>
<p>与球求交时，把o+td当作交点来联立；上一个与三角形求交则是转换成了和平面求交，也是同理。</p>
<p>然后到了MT算法对三角形求交，通过观察下图，发现联立的表达式原本的点都变成了向量。所以可能存在理解上的障碍。</p>
<p>本来应该为<code>o+t * D(vec) = (1-b1 - b2)P0 + b1 P1 + b2P2</code> </p>
<p>其实观察发现这两个式子是等价的。</p>
<p>之前提到过，点的重心坐标中α，β，γ均大于0且相加等于1，那么点在三角形内。</p>
<p>通过克莱姆法则求解</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230716181923313.png" class title="image-20230716181923313">

<h2 id="Accelerating-Ray-Surface-Intersection-加速求交"><a href="#Accelerating-Ray-Surface-Intersection-加速求交" class="headerlink" title="Accelerating Ray-Surface Intersection(加速求交)"></a>Accelerating Ray-Surface Intersection(加速求交)</h2><p>求交的简单方式： 光线遍历所有物体，找到最近的点</p>
<p><code>naive algorithm</code> : pixel x object x bounce,计算量太大，很慢</p>
<p>如果使用<strong>Bounding Volume</strong>(包围盒，包围体)，好处是能够筛掉连包围盒都不相交的物体，极大地剪枝。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717130952068.png" class title="image-20230717130952068">



<p>我们经常使用的包围盒是Axis-Aligned Bounding Box(AABB，轴对齐包围盒)，好处是与轴平行，便于计算光线与平面求交。三维情况下理解成三个对面（slabs)包围而成。</p>
<p>如何判断与盒子相不相交（二维与三维类似，下图为二维）</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717132837004.png" class title="image-20230717132837004">

<p>包围盒中对面（pairs of slabs) 全部进入才能算进入，只要有一个对面出去了，就算出去了。</p>
<p>核心ideas:(选取进入时间的最大时间，出去时间的最小时间)</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717132744508.png" class title="image-20230717132744508">

<p>结论</p>
<ol>
<li><p>t(exit) &gt; t(enter) &gt;=0 在包围盒中呆过一段时间, 有交点（入和出）</p>
</li>
<li><p>t(exit) &lt; 0,包围盒在光线反向延长的背后，由于是射线，所以不可能有交点。</p>
</li>
<li><p>t(enter) &lt; 0,t(exit) &gt;= 0,说明光线光源就在盒子里，有交点（只有出）</p>
</li>
</ol>
<p>综上，当t(exit) &gt; 0 &amp;&amp; t(exit) &gt; t(enter) 有交点。</p>
<p>我们已经知道包围盒的用处和用法了</p>
<p>那么如何具体地用AABB包围盒进行求交加速呢？</p>
<h3 id="Uniform-Grids（相同的格子）"><a href="#Uniform-Grids（相同的格子）" class="headerlink" title="Uniform Grids（相同的格子）"></a>Uniform Grids（相同的格子）</h3><p><strong>Preprocess - Build Acceleration Grid</strong>（预处理-创建加速网格）</p>
<p>预处理指的是在光线追踪之前。</p>
<ol>
<li>Find bounding box(找到整个场景的包围盒，将所有物体包围)</li>
<li>Create grid(设计合适的分辨率来创建网格，划分包围盒)</li>
<li>Store each object in overlapping cells（标记相交的小盒子，储存起来）</li>
</ol>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/87.png" class title="image-20230212125454507">

<p>光线与盒子求交视为简单操作，当盒子中有物体，再与物体求交，没有则进入下一个盒子。</p>
<p>【问题】那么如何知道光线下一个进入的盒子是哪个呢？</p>
<p>这与光栅化一条直线类似（有确定的算法实现）。一个思路是光线从左下角射出，就只用判断右上的临近网格是否有交点。这样就能判断下一个盒子。</p>
<p>这种算法在<code>Teapot in a stadium</code> 的问题中，效果并不好，场景很大很不均匀，想要找到一个茶壶会很麻烦。求交就会变得很困难。</p>
<h3 id="Spatial-partitions（空间划分）"><a href="#Spatial-partitions（空间划分）" class="headerlink" title="Spatial partitions（空间划分）"></a>Spatial partitions（空间划分）</h3><p>Examples</p>
<p>从左到右（represented with 2d, but both in 2d and 3d)</p>
<ul>
<li>八叉树（每个维度切成2份，下图为二维状态，是四叉树），与维度呈2的<em>指数幂</em>，不是很理想。</li>
<li>KD-Tree 类似于二叉树（x，y交替切分），一个格子切一刀，递归</li>
<li>BSP-Tree 每个空间（非横平竖直地）划分一次</li>
</ul>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/89.png" class title="image-20230212130527576">

<p>KD-Tree预处理Pre-Processing</p>
<p>【注意】</p>
<ol>
<li>划分要沿着x,y,z轴(split axis)</li>
<li>划分位置不限，一般是在中点。</li>
<li>数据结构是二叉树，只有叶子节点才有数据</li>
</ol>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/90.png" class title="image-20230212131538921">

<p>具体判断是否有交点的流程：</p>
<ol>
<li>和left有交点，发现left是叶子节点，对left中所有物体进行求交，return；如果left不是叶子节点，进一步往下走，直到叶子节点位置。</li>
<li>然后查看right,同样的道理。</li>
</ol>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717160634433.png" class title="image-20230717160634433">

<p><strong>局限性</strong></p>
<ol>
<li><p>KD-Tree会出现一个几何结构，被拆分到多个叶子节点里,划分本身是单纯的直线切割，难免会拆分原来的几何。</p>
</li>
<li><p>因为需要对指定包围盒中的所有物体进行求交，但是KD-Tree判断三角形是否与AABB的包围盒有交点很困难，因为顶点不在包围盒里，也有可能有交点。近年间不太使用这个方法。</p>
</li>
</ol>
<h3 id="Object-partition-amp-Bounding-Volume-Hierarchy-物体划分和BVH"><a href="#Object-partition-amp-Bounding-Volume-Hierarchy-物体划分和BVH" class="headerlink" title="Object partition &amp; Bounding Volume Hierarchy(物体划分和BVH)"></a>Object partition &amp; Bounding Volume Hierarchy(物体划分和BVH)</h3><p>上述两种划分方法都有一定局限性。</p>
<p>而BVH很好的解决了一些问题。BVH是一种得到非常广泛运用的方法。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717162403173.png" class title="image-20230717162403173">

<p>BVH划分包围盒是以物体为单位进行划分，不需要考虑三角形与物体求交，结构依旧是二叉树。</p>
<p>BVH的划分很有讲究，需要保证重叠部分尽可能少。 </p>
<p>总结：先找包围盒，然后递归地分成两个子集，计算子集地包围盒。当叶子节点的三角形足够少就可以停止了。</p>
<p>最后储存叶子节点的数据。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717164847097.png" class title="image-20230717164847097">



<p><strong>划分的方法 Heuristic</strong></p>
<p>优先选长轴开始划分，优先划分中间物体，保证左右平衡。</p>
<p>划分顺序是一个选择的过程。</p>
<img src="/2023/07/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/RayTracing/image-20230717165500868.png" class title="image-20230717165500868">





<p><strong>Whitted</strong>风格的光线追踪到此为止</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>RayTracing(下)---Radiometry(辐射度量学)</title>
    <url>/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/</url>
    <content><![CDATA[<h2 id="What-is-Radiometry"><a href="#What-is-Radiometry" class="headerlink" title="What is Radiometry"></a>What is Radiometry</h2><p>辐射度量学主要是对光的描述测量,是在物理意义上对光的确切定义。</p>
<p>Measurement system and units for illumination</p>
<p>之所以需要这样一个确切的描述性的东西，是因为无论是之前着色的布林冯，还是whitted风格光线追踪，其实都是不准确，效果不好的。这些方法做了太多简化和trick，以至于实际效果不能满足要求。</p>
<h2 id="Basic-concepts-of-Radiometry"><a href="#Basic-concepts-of-Radiometry" class="headerlink" title="Basic concepts of Radiometry"></a>Basic concepts of Radiometry</h2><h3 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux (Power)"></a>Radiant Energy and Flux (Power)</h3><p>Radiant Energy 是电磁辐射的能量，用Q表示，单位是joules(焦耳)</p>
<p>Radiant Flux(power) 是单位时间的能量，其实就是功率，单位瓦特W；</p>
<p>另一个别称叫做流明，类似于水的功率叫流量</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717181920698.png" class title="image-20230717181920698">

<h3 id="Light-Measurements-光照测量"><a href="#Light-Measurements-光照测量" class="headerlink" title="Light Measurements(光照测量)"></a>Light Measurements(光照测量)</h3><p>【基本英文名词】differential(微分) derivative(导数)</p>
<p>下图为三个表示光照能量的三个量</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/95.png" class title="image-20230213145057013">

<ol>
<li><p><strong>Radiant Intensity</strong> 光源发出的光照</p>
<p>Definition: The radiant (luminous) intensity is the <strong>power per unit solid angle</strong> emitted by a point light source；单位立体角所表示的功率；或者单位立体角且单位时间的光照能量</p>
</li>
</ol>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/96.png" class title="image-20230213145610092">



<p><strong>angle and solid angle</strong></p>
<p>什么是立体角？</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717183805902.png" class title="image-20230717183805902">

<p>在任意球上，极小面积为</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/102.svg" class>

<p>因此，极小立体角（单位球面上的极小面积）为：</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/103.svg" class>

<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/97.png" class title="image-20230213150222154">



<ul>
<li><p><strong>Irradiance</strong> 照射到物体表面的光照</p>
<p>Power per unit area</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/98.png" class title="image-20230215142634425">

<p>注意，光垂直于表面接受的光越大（上式没写cos)</p>
</li>
<li><p>注意，光垂直于表面接受的光越大（上式没写cos)</p>
<p>![image-20230215143222574](../../../../../trial/github/Books/Obsidian Vault/Books/计算机图形学/99.png)</p>
<p>接受光照强度可以根据光源计算</p>
<p>![image-20230215144008523](../../../../../trial/github/Books/Obsidian Vault/Books/计算机图形学/100.png)</p>
</li>
<li><p><strong>Radiance</strong> 传播中的光照</p>
<p>Definition: The radiance(luminace) is the power emitted,</p>
<p>reflected,transmitted or received by a surface,</p>
<p><strong>per unit solid angle,per projected unit area</strong>.两次微分</p>
<p><strong>incident radiance</strong>入射辐射</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/101.png" class title="image-20230215144416607"></li>
</ul>
<p>radiance 和irradiance的差别在于是否有方向性</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/104.png" class title="image-20230215145514770">

<p><strong>Irradiance versus Radiance</strong></p>
<p>可以理解成，irradiance是surface上某一点附近的光照</p>
<p>而radiance是从某个方向照射到surface的某一点附近的光照</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/105.png" class title="image-20230215150213248">

<h2 id="BRDF-Bidirectional-Reflectance-Distribution-Function"><a href="#BRDF-Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="BRDF(Bidirectional Reflectance Distribution Function)"></a>BRDF(Bidirectional Reflectance Distribution Function)</h2><p>双向反射分布函数: 从某个方向来的光，反射到不同方向的能量有多少</p>
<p>irradiance-&gt;power(surface)-&gt;radiance</p>
<p><strong><code>radiance / irradiance</code></strong> 任意一个出射除以入射</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/106.png" class title="image-20230215153709373">

<p>由此，输入入射角，入射irradiance就可以得到</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/107.png" class title="image-20230215154529157">

<p>Challenge: Recursive Equation</p>
<h3 id="渲染方程-The-Rendering-Equation"><a href="#渲染方程-The-Rendering-Equation" class="headerlink" title="渲染方程(The Rendering Equation)"></a><strong>渲染方程(The Rendering Equation)</strong></h3><p><code>result = 自己辐射+brdf反射</code>,注意下半球贡献的光是0</p>
<p>n*w是cosθ</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/108.png" class title="image-20230215155813155">

<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/109.png" class title="image-20230215160925868">

<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/110.png" class title="image-20230215161350535">

<p>移项、合并、泰勒展开</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/111.png" class title="image-20230215161810833">

<p>自发光emission + 直接光 + 一次间接光 + … = L</p>
<p>其中直接光与间接光的和为<strong>全局光照（global illumination)</strong></p>
<h2 id="Probability-概率论基础待补充"><a href="#Probability-概率论基础待补充" class="headerlink" title="Probability(概率论基础待补充)"></a>Probability(概率论基础待补充)</h2><p>概率分布函数</p>
<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/image-20230717205956558.png" class title="image-20230717205956558">

<h2 id="Monte-Carlo-Path-Tracing（蒙特卡洛路径追踪）"><a href="#Monte-Carlo-Path-Tracing（蒙特卡洛路径追踪）" class="headerlink" title="Monte Carlo Path Tracing（蒙特卡洛路径追踪）"></a>Monte Carlo Path Tracing（蒙特卡洛路径追踪）</h2><p><strong>正确地解出渲染方程</strong></p>
<h3 id="Monte-Carlo-Integration（蒙特卡洛积分）"><a href="#Monte-Carlo-Integration（蒙特卡洛积分）" class="headerlink" title="Monte Carlo Integration（蒙特卡洛积分）"></a>Monte Carlo Integration（蒙特卡洛积分）</h3><img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/112.png" class title="image-20230216202106177">



<img src="/2023/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Radiometry/113.png" class title="image-20230216202345788">
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
  </entry>
  <entry>
    <title>如何手写光追</title>
    <url>/2023/07/18/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%AE%9E%E8%B7%B5%E5%8F%8A%E4%BD%9C%E4%B8%9A/RayTracing/</url>
    <content><![CDATA[<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>本文参考了《Ray Tracing in one weekend》</p>
<p>闫令琪老师的Games系列课程</p>
]]></content>
      <categories>
        <category>计算机图形学</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之查找与排序算法</title>
    <url>/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="查找与排序"><a href="#查找与排序" class="headerlink" title="查找与排序"></a>查找与排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>本文主要包括查找算法和经典排序算法两个部分</li>
<li>使用语言：c/c++</li>
<li>仅用于个人学习记录，如有细节错误望理解（欢迎指正）</li>
<li>持续更新中,完整可运行代码见文末</li>
<li>参考<a href="https://www.runoob.com/w3cnote/merge-sort.html">https://www.runoob.com/w3cnote/merge-sort.html</a> (归并排序开始)</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>首先要理解什么是查找。</strong><br>查找是在相同数据类型的集合中，使用唯一标识（关键字K）来查找数据元素（V）。</p>
<p><strong>平均查找长度</strong> ASL = $P_1C_1 + P_1C_2 + ……$<br>其中$P_i$是概率，$C_i$是查找第i个元素比较过的次数。<br>用于分析算法性能。</p>
<p><strong>查找有哪些方法：</strong></p>
<ul>
<li>比较式查找法 (1).线性表的查找 (2).树的查找</li>
<li>计算式查找法 (1).hash查找</li>
</ul>
<p>理解以上三点后开始进一步学习具体的查找方法。</p>
<h3 id="比较式查找-基于线性表的查找"><a href="#比较式查找-基于线性表的查找" class="headerlink" title="比较式查找-基于线性表的查找"></a>比较式查找-基于线性表的查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>存储方式可以是顺序结构，也可以是链式结构<br>按顺序与关键字比对查找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;KeyValueType;</span><br></pre></td></tr></table></figure>
<p>具体查找代码省略。只需在顺序表中逐个查找对比。</p>
<p><strong>平均查找长度：</strong><br>设列表中每个数概率相同 P = 1/n。<br>ASL = $1/n * (1 + 2 + 3 + … + n)$ = $(1+n)*n/2 * (1/n)$ = $(1+2)/n$</p>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p><strong>使用折半查找的先前条件：必须是有序排列的顺序表</strong><br>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方便起见不用结构体，直接在int数组里查找，key就是要查找的值x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BinSearch</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = n,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] = x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong><br>设每个数的概率一致为P = $1/n$。</p>
<ul>
<li><p>简单计算方法，可以将长度为n的数组看成n个结点的满二叉树（不妨设刚好满足），这样一来，我们发现，每一次选择一半，就相当于从二叉树底层开始向上攀爬。假设最多选择比较了h次，刚好就是二叉树的高度。</p>
</li>
<li><p><em>根据满二叉树的性质 $h = log_2(n+1)$</em>*<br>换而言之只需要查找h次就一定能找到答案。</p>
</li>
<li><p>公式计算：<br>ASL = $1/n * Σ_{i=1-&gt;n}i*2^{i-1} = (n+1)/n * log_2(n+1) - 1$<br>当n足够大时，趋近于$log_2(n+1)$</p>
</li>
</ul>
<p>折半查找效率很高，但是要求必须为有序表,导致插入删除很麻烦。</p>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>通俗来讲，将数组分为多个块，块内数据无序，但是块与块之间有序（如 块0所有元素小于块1的任意元素）。<br>这是一种结合了折半查找和顺序查找的方法。性能介于两者之间。</p>
<p><strong>模拟一下过程：</strong></p>
<ul>
<li>建立索引表，用于指出块的起始位置和最大值。</li>
<li>使用折半查找，找到x所在的块，比较方法是比对每个块的最大值maxv。假设块是递增的，那么找到第一个大于等于x的maxv就行。</li>
<li>使用顺序查找，在块内逐个比对。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里的key有两个</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> maxKey;     <span class="comment">// 索引区间的最大键值</span></span><br><span class="line">    <span class="type">int</span> address;    <span class="comment">// 索引区间的起始地址（下标）</span></span><br><span class="line">&#125;Index;</span><br></pre></td></tr></table></figure>
<p>具体查找代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BlockSearch</span><span class="params">(Index *index, <span class="type">int</span> indexLen, <span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 先折半查找索引表，找到关键值的索引区间</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = n,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// index.maxKey存储了最大的值 </span></span><br><span class="line">        <span class="keyword">if</span> (x == index[mid].maxKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; index[mid].maxKey)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span>这里尤其注意，我们是用最大值进行比较</span></span><br><span class="line">            <span class="comment">// 但是同时，如果我们发现该最大值大于x，我们没有把握说这个x是在找到的这个块，还是前一个。</span></span><br><span class="line">            <span class="comment">// 所以如果high = mid - 1,有可能会错过正确答案。 </span></span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跳出循环，mid就是要找的索引,就能确定块的start和end </span></span><br><span class="line">    <span class="type">int</span> start = index[mid].address, end;</span><br><span class="line">    <span class="keyword">if</span> (mid == indexLen - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        end = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        end = index[mid + <span class="number">1</span>].address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后顺序查找返回索引下标 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == arr[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>平均查找长度：</strong><br>TODO:待计算</p>
<img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/blockSearchCaculate.png" class>

<h3 id="基于树的查找"><a href="#基于树的查找" class="headerlink" title="基于树的查找"></a>基于树的查找</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h4><p>二叉排序树就是二叉搜索树或者二叉查找树<br>根结点上的左子树结点均小于根结点，右子树结点则大于根结点<br>中序遍历后得到递增有序序列</p>
<p>简单二叉排序树的存储结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于二叉搜索树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key; <span class="comment">// 存储key </span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode() : key(<span class="number">-1</span>), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) : key(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : key(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> TreeNode *root;</span><br></pre></td></tr></table></figure>
<h5 id="创建和插入二叉树排序树"><a href="#创建和插入二叉树排序树" class="headerlink" title="创建和插入二叉树排序树"></a>创建和插入二叉树排序树</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建二叉搜索树（排序树）,使用int作key </span></span><br><span class="line"><span class="comment">// key是唯一标识不重复 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode *bst = nullptr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    <span class="keyword">while</span> (key != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(bst,key);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归插入，用于向二叉树中插入某一结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(TreeNode *bst,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bst == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = new TreeNode(key);</span><br><span class="line">        bst = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bst-&gt;key &gt; key)</span><br><span class="line">        Insert(bst-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        Insert(bst-&gt;right,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####排序树的查找</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TreeNode* <span class="title function_">Search</span><span class="params">(TreeNode *bst,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!bst) <span class="keyword">return</span> nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key == bst-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> bst;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bst-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> Search(bst-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> Search(bst-&gt;right,key);		</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>平均查找长度与分支均衡程度有关。<br>树深度越小，ASL越小。</p>
<h4 id="平衡二叉树（排序树）"><a href="#平衡二叉树（排序树）" class="headerlink" title="平衡二叉树（排序树）"></a>平衡二叉树（排序树）</h4><p>又叫做AV树，属于二叉排序树。</p>
<ul>
<li>左子树和右子树高度相差小于等于1</li>
<li>平衡因子 = 左 - 右 = {0，1，-1}<br>//TODO:代码<h4 id="B树（排序树）-TODO-b树补充"><a href="#B树（排序树）-TODO-b树补充" class="headerlink" title="B树（排序树）//TODO:b树补充"></a>B树（排序树）//TODO:b树补充</h4>B树属于m插排序树</li>
<li><em>要求</em>*</li>
<li>每个结点最多m棵子树</li>
<li>根结点至少两棵子树</li>
<li>除根结点外非叶子结点至少有一棵子树</li>
<li>叶子节点在同一层，称为失败结点，不存储信息，用于分析性能。<br>存储结构如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RANK 10 </span></span><br><span class="line"><span class="comment">// 用于m叉搜索树 也就是B树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> keyNum;  <span class="comment">// 存储key的数量 </span></span><br><span class="line">    <span class="type">int</span> key[RANK]; <span class="comment">// 因为叶子结点不放信息了，所以只能让父结点存储子结点的信息 </span></span><br><span class="line">    BTreeNode *p; <span class="comment">// 父结点 </span></span><br><span class="line">    BTreeNode *ptr[RANK]; <span class="comment">//子树数组 </span></span><br><span class="line">    BTreeNode() : keyNum(RANK),p(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; RANK; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            key[i] = i;</span><br><span class="line">            ptr[i] = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计算式查找-哈希查找"><a href="#计算式查找-哈希查找" class="headerlink" title="计算式查找-哈希查找"></a>计算式查找-哈希查找</h3><h4 id="哈希函数的构造"><a href="#哈希函数的构造" class="headerlink" title="哈希函数的构造"></a>哈希函数的构造</h4><h5 id="构造原则"><a href="#构造原则" class="headerlink" title="构造原则"></a>构造原则</h5><ul>
<li>函数便于计算</li>
<li>设关键字为k,f(k)的地址概率一致，减少冲突。<h5 id="具体构造方法"><a href="#具体构造方法" class="headerlink" title="具体构造方法"></a>具体构造方法</h5></li>
<li>数字分析法：事先知道关键字集合，并且关键词比地址码位数多，可以使用,选取均匀的若干位。<br>//TODO:待补充</li>
</ul>
<p>构造哈希函数要考虑的东西：</p>
<ul>
<li>计算函数的时间</li>
<li>关键字长度</li>
<li>哈希表大小</li>
<li>关键字分布</li>
<li>查找频率<h4 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h4></li>
<li>开放定址法：关键字冲突则以冲突的地址为基础产生新的地址，如此递归，直到不冲突。<ul>
<li>线性探测再散列：顺序表查看下一个单元</li>
<li>二次探测再散列：左右探测</li>
<li>伪随机探测再散列：建立伪随机发生器重新给到新地址</li>
</ul>
</li>
<li>再哈希算法：不断构造不同哈希函数，直到不冲突</li>
<li>链地址法：构造同义词单链表，相同key放到同一个单链表。<br>整个哈希表存储单链表头指针。<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4>除了哈希函数本身，处理冲突的方法以外，填装因子也影响着性能，<br>$α = n / length$ n表示哈希表元素个数，length则是哈希表长度。</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="插排"><a href="#插排" class="headerlink" title="插排"></a>插排</h3><ol>
<li><p>数组存储，边插入，边排序，双重循环</p>
</li>
<li><p>内循环用将要插入的数从后往前比较，随着已插入的数增加，比较的次数也会增加</p>
</li>
</ol>
<p>时间复杂度为O(n^2)</p>
<h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><ol>
<li>将待插入数组看成有序表（初始为0个元素）</li>
<li>每插入一个元素，都对有序表循环二分，直到找到合适位置插入</li>
<li>虽然二分的复杂度只有$O(log_2n)$,但是移动后续的元素仍然有O(n)，最终复杂度仍然为O（n^2)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BinInsertSort</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> insert;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> low = <span class="number">0</span>, high = i,mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">		<span class="comment">// 假设边输入边插入，也可以用事先存储的数据 </span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; insert;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第一个数直接放在第一位 </span></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">			arr[<span class="number">0</span>] = insert;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &gt; insert)</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">			mid = (high - low)/<span class="number">2</span> + low;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为要想插入还需要移动后面的数据</span></span><br><span class="line">		<span class="comment">// 数组中已有i个数,正在插入第i+1个数 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= low; j --)</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; </span><br><span class="line">		arr[low] = insert;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出排序结果</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;arr[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h4><p>使用链表存储进行插入排序</p>
<p>原理与普通插排一样，时间复杂度为O(n^2)</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>选择出第i小（大）的数。注意区别冒泡排序</p>
<p>复杂度O（n^2)s</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡,冒泡虽然也是将第i小（大）的数找出来，但是经历了一定次数交换</span></span><br><span class="line"><span class="comment">// n + n-1 + n-2 + ... </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t[ARRSIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRSIZE - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; ARRSIZE; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) </span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[i],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反观选择排序，则是将第i小（大）的数的下标保存下来，虽然比较次数不变，但是省略了数据交换(swap)的环节</span></span><br><span class="line"><span class="comment">// 简单选择</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">SimpleSelect</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			k = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">					k = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (k != i) </span><br><span class="line">				swap(arr[i],arr[k]);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>

<h4 id="树选择排序"><a href="#树选择排序" class="headerlink" title="树选择排序"></a>树选择排序</h4><p>树形结构，因为二叉树的特殊结构，比较次数每次除以2，时间复杂度为O（nlog_2n）。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是基于树选择排序的改进</p>
<p>将数据放在完全二叉树中，根结点&gt;=子结点为大根堆，反之为小根堆。</p>
<p>下图为小根堆</p>
<img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/image-20230904220812088.png" class title="image-20230904220812088">

<p>实际使用中将数据放在数组中便于存储<br>下标从0开始<br>父结点：$（i-1）/2$,左子：$2*i+1$，右子：$2 * i+2$</p>
<p><strong>基本过程</strong></p>
<ol>
<li><p>首先将待排序的数组构造成一个大根堆，此时，整个数组的最大值就是堆结构的顶端</p>
</li>
<li><p>将顶端的数与末尾的数交换，此时，末尾的数为最大值，剩余待排序数组个数为n-1</p>
</li>
<li><p>将剩余的n-1个数再构造成大根堆，再将顶端数与当前大根堆末尾位置的数交换，如此反复执行。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="comment">// 让当前堆顶的数下沉，值最小的话就沉入最底 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createMaxHeap</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">//建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">//若子节点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">//先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点大于子节点代表调整完毕，直接跳出函数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则交换父子内容再继续子节点和孙节点比较</span></span><br><span class="line">            swap(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">// 从小到大排序，创建大根堆，从最后一个非叶子父结点开始往前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (len<span class="number">-1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        createMaxHeap(i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        createMaxHeap(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>时间复杂度为$O(nlog_2n)$</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>分解-解决-合并</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="comment">// 非递归 </span></span><br><span class="line">template&lt;typename T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = new T[len]; <span class="comment">// 存储归并排序后的结果 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2) <span class="comment">// 比较 </span></span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    delete[] b;</span><br><span class="line">&#125; 	</span><br><span class="line">	</span><br><span class="line"><span class="comment">// -------递归---------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> reg[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="type">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="type">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">    reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">    reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">    reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">    arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序时间复杂度O(nlog_2n)</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快排，递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Paritition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">        --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">        ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pivot = Paritition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">        QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h3><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p><strong>可以采用链式和顺序表两种结构存储。</strong><br>一般使用链式，整体思路是：</p>
<ul>
<li>先按照个位进行分类，建立0到9号链表，个位数数值一致则归类到一个链表</li>
<li>然后是十位数，百位数进行分类，以此类推，直到排序完成。<br>时间复杂度为O(d(n+rd))<br>显然基数排列适合位数小的序列。<br>其中d是数的位数，<br>代码略</li>
</ul>
<p>github仓库地址：<a href="https://github.com/aspect-ux/kanodesu.github.io/tree/main">https://github.com/aspect-ux/kanodesu.github.io/tree/main</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Re0:数据结构与算法之 树与二叉树</title>
    <url>/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>TODO:2023/08/18 19:00: 1.递归非递归遍历 2.线索树<br>TODO:2023/08/21 20:00: 1.取消stl的使用 2.树，森林，二叉树 3. 哈夫曼编码 4. 并查集的应用</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>使用语言：c/c++</li>
<li>仅个人学习记录，如有细节错误望理解（欢迎指正）</li>
<li>完整可运行代码见文末</li>
<li>持续更新中</li>
</ul>
<h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><ul>
<li><p>定义：n（n&gt;=0）个结点的有限集合。n = 0为空树。</p>
<p>什么是结点？可以理解成一个包含数据区域和若干个指向其他结点的指针的结构体。</p>
<p>对于非空树，有且仅有一个根结点，其他结点皆有前驱结点。</p>
</li>
<li><p>表示方法：</p>
<ul>
<li><p>倒置树结构（如下图)</p>
<img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/image-20230815222453369.png" class title="image-20230815222453369"></li>
<li><p>文氏图</p>
</li>
<li><p>广义表</p>
</li>
<li><p>凹入表示法</p>
</li>
</ul>
</li>
<li><p>基本术语</p>
<ul>
<li>度：分为结点的度和树的度两种。前者是该节点的子树数量，也即后驱结点个数；后者则是所有结点度的最大值。</li>
<li>叶结点：也称为终端结点</li>
<li>层级：从根结点往下，1-n</li>
<li>树的高度：最大层级数</li>
<li>结点的名称：子结点，根结点，父结点（双亲结点），兄弟结点，堂兄弟结点等等。</li>
<li>m（m&gt;=0）棵互不相交的树。</li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树中一个结点的后驱结点最大只能为2。</p>
<p>除了叶子结点外，如果所有结点都有2个后驱结点，就叫做<strong>满二叉树</strong>。<br>另外还有一种二叉树叫做完全二叉树，除了最后一层相较于满二叉树可能有缺失外，其他一致。满二叉树一定是完全二叉树。<br><strong>注意</strong>，完全二叉树按照从左到右，从上到下的顺序，在遍历完所有结点之前不会遇到空结点。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li><p><strong>性质1：第 i 层的最多有 $2^{i-1}$结点</strong><br>证明：由于下一层 = 上一层 * 2<br>第一层有1个结点，第二层2个，第三层4个…<br>所以第i层$2^{i - 1}$个</p>
</li>
<li><p><strong>性质2：深度为k的二叉树，最多有$2^{k}$ - 1个结点</strong><br>证明：利用上一个性质的结论，第i层最多有$2^{k - 1}$个结点<br>深度为k，那么结点数最多共计<br>S = $2^{0}$ + $2^{1}$ + $2^{2}$ + … + $2^{k - 1}$<br>2S = $2^{1}$ + $2^{2}$ + $2^{1}$ + … + $2^{k - 1}$<br>S = 2S - S = $2^{k}$ - $2^{0}$ = $2^{k}$ - 1</p>
</li>
<li><p><strong>性质3：对于任意二叉树T，叶子结点数为$n_0$,度数为2的结点数位$n_2$,那么$n_0$ = $n_2$ + 1。</strong>*<br>证明： 先来分析一下，二叉树只有度为0-叶子结点，度为1，2的其他结点。<br>设度为1的结点有$n_1$个，总结点数为n。<br>n = $n_0$ + $n_1$ + $n_2$ ①</p>
<p>然后，除了叶子，所有结点都有至少一个结点，我们可以根据子结点来计算n<br>n = $n_0$ * 0 + $n_1$ * 1 + $n_2$ * 2 + 1（不要忘记根结点）②<br>② - ① = $n_2$ + 1 - $n_0$ = 0<br>即证 $n_0$ = $n_2$ + 1，度为0的结点比度为2的结点多一个。</p>
</li>
<li><p><strong>性质4：具有n个结点的完全二叉树深度为$[log_2n ] (向下) + 1$</strong><br>性质1，2是根据深度推导结点个数，3是0度和2度结点数关系。<br>性质4则是根据结点数推导二叉树深度。<br>证明：首先，完全二叉树保证了除了最后一层，其他层都与满二叉树完全相同。总结点数小于等于满二叉树的结点数。<br>根据性质2深度为k的二叉树最多有$2^{k}$ - 1个结点<br>我们设深度为k，那么可以得到以下不等式<br>$$<br>2^{k - 1} - 1 &lt; n &lt;= 2^{k} - 1<br>$$<br>简化后<br>$$<br>2^{k - 1} &lt;= n &lt; 2^{k}<br>$$<br>即得$k&lt;=log_2n + 1$</p>
</li>
<li><p><strong>性质5：在完全二叉树中，按照从左到右，从上到下，从1开始对结点进行编号，有以下性质：</strong></p>
<ol>
<li>若i = 1,为根结点。i &gt; 1则双亲结点序号为i/2</li>
<li>i &gt; n/2(叶子),则没有左孩子结点；i &lt; = n/2,则左孩子结点序号为2 * i。<br>证明：深度为k的满二叉树，最后一层最大有$2^{k-1}$个结点。除去最后一层一共有$2^{k - 1} - 1$,前k-1层总数少于最后一层，也就是小于n/2个结点。<br> 另一个方面来说，i&lt;=n/2时，i层某个结点到它的左子结点，刚好经过了i个结点。</li>
<li>i * 2 + 1 &gt; n,则无右孩子；否则有孩子结点序号为2 * i + 1。</li>
</ol>
</li>
</ul>
<h3 id="二叉树的遍历-Traverse"><a href="#二叉树的遍历-Traverse" class="headerlink" title="二叉树的遍历(Traverse)"></a>二叉树的遍历(Traverse)</h3><p>二叉树的存储结构分为顺序和链式两种，顺序结构采用结构体数组将数据存储在连续存储单元。</p>
<p>以下采用链式结构。<br>二叉树数据结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> TreeNode *root;</span><br></pre></td></tr></table></figure>
<p><strong>以下使用递归遍历(非递归在后面)</strong></p>
<h4 id="前序-先序-遍历"><a href="#前序-先序-遍历" class="headerlink" title="前序(先序)遍历"></a>前序(先序)遍历</h4><p>先左子树后右子树，无限递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先左后根最后右</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTravere</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">InOrderTravere</span>(root-&gt;left);</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">  <span class="built_in">InOrderTravere</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先左后右最后根</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;left);</span><br><span class="line">  <span class="built_in">PreOrderTraverse</span>(root-&gt;right);</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span>对当前结点操作 </span></span><br><span class="line">  <span class="built_in">PrintTBTreeNode</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  qu.<span class="built_in">push</span>(root);</span><br><span class="line">  level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> n = qu.<span class="built_in">size</span>();</span><br><span class="line">    LevelArr.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      TreeNode *tmp = qu.<span class="built_in">front</span>();</span><br><span class="line">      qu.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span>层序遍历操作</span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(tmp);</span><br><span class="line">      LevelArr[level].<span class="built_in">push_back</span>(tmp-&gt;val); <span class="comment">//二维数组记录 </span></span><br><span class="line">      <span class="keyword">if</span> (tmp-&gt;left)</span><br><span class="line">        qu.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">      <span class="keyword">if</span> (tmp-&gt;right)</span><br><span class="line">        qu.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    level ++; </span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="非递归算法实现遍历"><a href="#非递归算法实现遍历" class="headerlink" title="非递归算法实现遍历"></a>非递归算法实现遍历</h4><p>为什么使用非递归算法？、<br>递归需要系统提供隐式栈实现，效率低且无法适应无递归语言设施。</p>
<h5 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>()) <span class="comment">// node指向当前新指针，stack存储待开发的旧指针 </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 先序遍历：先输出当前结点(左),保证push进去的结点不为空</span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(node);</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      node = st.<span class="built_in">top</span>()-&gt;right;</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="中序"><a href="#中序" class="headerlink" title="中序"></a>中序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 中序遍历输出 最左的非空结点(输出左结点)</span></span><br><span class="line">      node = st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 输出位置 </span></span><br><span class="line">      <span class="built_in">PrintTBTreeNode</span>(node); </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 转移指针到右结点,因为右子树也需要递归判断 </span></span><br><span class="line">      node = node-&gt;right; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderTraverse1</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">  stack&lt;TreeNode*&gt; st;</span><br><span class="line">  TreeNode* node = root,*recent = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (node || !st.<span class="built_in">empty</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">      st.<span class="built_in">push</span>(node);</span><br><span class="line">      node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 后序遍历需要先输出右结点才能输出相对根结点				</span></span><br><span class="line">      node = st.<span class="built_in">top</span>();				</span><br><span class="line">      <span class="comment">// 直到右子结点是空结点才输出 </span></span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right &amp;&amp; node-&gt;right != recent)</span><br><span class="line">      &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        node = node-&gt;right-&gt;left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 输出位置 </span></span><br><span class="line">        <span class="built_in">PrintTBTreeNode</span>(node);</span><br><span class="line">        recent = st.<span class="built_in">top</span>(); <span class="comment">// 记录最近一次访问</span></span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        node = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>前言</strong>：我们在使用二叉树时，无法直接获得某个结点的前驱或后继的信息，只能从根结点开始遍历；另一方面，一个二叉树中，n个结点有2n个指针域，但是真正存储了信息的只有n-1个。</p>
<p>现在需要利用多余的指针域指向前驱和后继，这种指针称为线索。<br>而这种二叉结构又叫做线索链表。<br><strong>遍历并插入线索的操作叫做线索化</strong></p>
<p>数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线索树结点 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> lTag;</span><br><span class="line">    <span class="type">int</span> rTag;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">lTag</span>(<span class="number">0</span>), <span class="built_in">rTag</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">lTag</span>(<span class="number">0</span>), <span class="built_in">rTag</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ThreadTreeNode</span>(<span class="type">int</span> x,<span class="type">int</span> lTag,<span class="type">int</span> rTag, TreeNode *left, TreeNode *right)</span><br><span class="line">	: <span class="built_in">val</span>(x),<span class="built_in">lTag</span>(lTag), <span class="built_in">rTag</span>(rTag), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，多了lTag,rTag两个int类型。规则如下</p>
<ol>
<li>lTag = 0,left指针域指向左孩子</li>
<li>lTag = 1,left指针域指向前驱</li>
<li>rTag = 0,right指针域指向右孩子</li>
<li>rTag = 1,right指针域指向后驱</li>
</ol>
<h4 id="线索化"><a href="#线索化" class="headerlink" title="线索化"></a>线索化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序线索化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitThread</span><span class="params">(ThreadTreeNode* threadRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!threadRoot) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">InitThread</span>(threadRoot-&gt;left);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 左子树为空，那么存储前驱 </span></span><br><span class="line">  <span class="keyword">if</span> (!threadRoot-&gt;left)</span><br><span class="line">  &#123;</span><br><span class="line">    threadRoot-&gt;left = pre; </span><br><span class="line">    threadRoot-&gt;lTag = <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 右子树为空且前驱结点不为空，存储后驱 </span></span><br><span class="line">  <span class="keyword">if</span> (!threadRoot-&gt;right &amp;&amp; pre)</span><br><span class="line">  &#123;</span><br><span class="line">    pre-&gt;right = threadRoot;</span><br><span class="line">    pre-&gt;rTag = <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录前驱结点 </span></span><br><span class="line">  pre = threadRoot;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">InitThread</span>(threadRoot-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉搜索树（查找树）"><a href="#二叉搜索树（查找树）" class="headerlink" title="二叉搜索树（查找树）"></a>二叉搜索树（查找树）</h3><p>搜索树中，左子结点值小于父结点，右子结点大于父结点<br>中序遍历得到从小到大排序。</p>
<h3 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h3><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树又叫做最优二叉树</p>
<img src="/2023/09/06/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/uTools_1692620939563.png" class>
<ol>
<li>路径：根到叶子结点</li>
<li>路径长度：从根结点到叶子节点，每经过一个结点+1.（从一个结点到另一个结点经过的分支树）,设长度为l。</li>
<li>权：每个结点分配一个值，称为权,设为w。</li>
<li><strong>结点的带权路径长度：</strong> w * l</li>
<li><strong>树的带权路径长度：</strong> 结点带权路径长度之和 WPL = $w_1l_1$ + $w_2l_2$….</li>
</ol>
<h5 id="构造哈夫曼树"><a href="#构造哈夫曼树" class="headerlink" title="构造哈夫曼树"></a>构造哈夫曼树</h5><ol>
<li>n个权${w_1,w_2,…,w_n}$,分配到n个结点，可以看成n棵二叉树的森林F（权重不重复）</li>
<li>在森林F中选择权重最小的两棵树(二叉树),作为根结点的左右子树，根结点的权为两者之和。从F中删除已选中的树。</li>
<li>重复1，2操作。</li>
</ol>
<h5 id="哈夫曼树的特征"><a href="#哈夫曼树的特征" class="headerlink" title="哈夫曼树的特征"></a>哈夫曼树的特征</h5><p>根据上述的构造方法，不难发现</p>
<ul>
<li>有n个叶子结点，n - 1个非叶子结点。<h5 id="构造代码"><a href="#构造代码" class="headerlink" title="构造代码"></a>构造代码</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10 <span class="comment">//叶子结点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2*N - 1 <span class="comment">// 总结点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> w; <span class="comment">// 权重</span></span><br><span class="line">  <span class="type">int</span> p; <span class="comment">// 双亲的下标,为0时表示还没有父结点,可构造。 </span></span><br><span class="line">  <span class="type">int</span> left; <span class="comment">// 左孩的下标</span></span><br><span class="line">  <span class="type">int</span> right; <span class="comment">// 右孩的下标 </span></span><br><span class="line">&#125;HuffmanTree[M+<span class="number">1</span>]; </span><br><span class="line">HuffmanTree HT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Select</span><span class="params">(HuffmanTree HT,<span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> s1_value,s2_value = s1_value = INT_MAX;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1_value &gt; HT[i].w &amp;&amp; HT[i].p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s1_value = HT[i].w;</span><br><span class="line">      s1 = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 查找第二小的权重 且 待构造 </span></span><br><span class="line">    <span class="keyword">if</span> (HT[i].w != s1_value &amp;&amp; HT[i].w &lt; s2_value &amp;&amp; HT[i].p == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s2_value = HT[i].w;</span><br><span class="line">      s2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateHuffmanTree</span><span class="params">(<span class="type">int</span> w[],<span class="type">int</span> n,<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// HT[0]不使用 </span></span><br><span class="line">  <span class="comment">// 前n个结点存储叶子 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    HT[i] = &#123;w[i],<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后n-1存储非叶子</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i ++) HT[i] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = n+<span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> s1,s2;</span><br><span class="line">    <span class="comment">// 选择最小的两个, </span></span><br><span class="line">    Select(HT,i<span class="number">-1</span>,s1,s2);  <span class="comment">// 每次选中的两个叶子都无法再使用了 ，但是父结点还可以加入选择 </span></span><br><span class="line">    HT[i].w = HT[s1].w + HT[s2].w;</span><br><span class="line">    HT[s1].p = i; HT[s2].p = i; </span><br><span class="line">    HT[i].left = s1; HT[i].right = s2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4></li>
<li><em>利用哈夫曼编码，我们可以得到平均长度最短的编码</em>*<br>在理解哈夫曼编码之前，我们现需要知道<strong>前缀码</strong><br>前缀码：一组编码中，互不为前缀。</li>
</ul>
<p><strong>哈夫曼编码:</strong> 对于哈夫曼树，左子树编为0，右子树编为1，每个分支得到的二进制串就是哈夫曼编码</p>
<p><strong>哈夫曼树是最优前缀码。用n个叶子结点来编码n个字符,可以使由这n个字符构成的文本的二进制串的平均长度最短。</strong><br>注意，权重是字符使用频率。</p>
<p><strong>哈夫曼编码算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="树与森林与二叉树"><a href="#树与森林与二叉树" class="headerlink" title="树与森林与二叉树"></a>树与森林与二叉树</h2><p>下面是就树，森林具体展开。</p>
<h3 id="树的存储结构（区别对比二叉树的存储）"><a href="#树的存储结构（区别对比二叉树的存储）" class="headerlink" title="树的存储结构（区别对比二叉树的存储）"></a>树的存储结构（区别对比二叉树的存储）</h3><ol>
<li>双亲表示法：层序顺序对结点从1-n编号，结点分为数据域和双亲域（int类型）；一棵树则是结点数组。（结点数组）</li>
<li>孩子表示法：每个结点都有一条孩子单链表（叶子节点的孩子链表为空表）；使用数组存储n条单链表  （链表数组）</li>
<li>孩子兄弟表示法：每个结点两个指针域，指向第一个孩子和自己的右兄弟。</li>
</ol>
<h3 id="树与森林与二叉树的相互转换"><a href="#树与森林与二叉树的相互转换" class="headerlink" title="树与森林与二叉树的相互转换"></a>树与森林与二叉树的相互转换</h3><p>//TODO:待补充</p>
<h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历见二叉树<br>森林的遍历也分为先序中序和后序。（<strong>树去掉根结点就分成多棵树了，也就是森林</strong>）<br>拿先序来说，1.先第一棵树的根结点 2. 先序第一棵树的子树<br>3. 先序其它树</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
</search>
