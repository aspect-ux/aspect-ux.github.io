<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的第一篇文章</title>
    <url>/2022/10/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建静态网页</title>
    <url>/2022/10/21/buildWebsiteBasedonGithub/</url>
    <content><![CDATA[<h1 id="搭建静态网页"><a href="#搭建静态网页" class="headerlink" title="搭建静态网页"></a>搭建静态网页</h1><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><ul>
<li><p>创建仓库,命名为<code>aspect-ux.github.io</code>,找到Pages,发现site 是显示了。</p>
</li>
<li><p>安装node.js 参考<a href="https://blog.csdn.net/chanyeolchichi/article/details/121348541">(26条消息) Node.js详细安装教程（2021）_cheerileeyoki的博客-CSDN博客_node安装教程</a></p>
</li>
<li><p>安装hexo,报错有可能是权限，删去c盘下的.npmrc???</p>
<p>大抵是nodejs版本太高了</p>
<p>主要参考<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?from=search&seid=6808372371406518307&vd_source=2b3a7e4dffb44c07076538fe075cb1cf">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a></p>
</li>
<li><p>配置<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> 		<span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">		<span class="attr">repo:</span> <span class="string">https://github.com/aspect-ux/aspect-ux.github.io.git</span></span><br><span class="line"> 		<span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后</p>
<ul>
<li><p>更改主题git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia </p>
<p>更改yml文件</p>
<p>主题配置参照：<a href="https://blog.csdn.net/wugenqiang/article/details/88373990">(26条消息) 使用 Github 空间搭建 Hexo 技术博客——使用NexT优化博客（五）_WuGenQiang的博客-CSDN博客</a></p>
</li>
</ul>
<p>hexo c<br>hexo g<br>hexo d</p>
<ul>
<li><p>值得注意的是，传统的markdown语法无法显示图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: false` 修改为 `post_asset_folder: true</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p>
<p>最后需要新建与文章同名的文件夹存放图片</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要1</title>
    <url>/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/</url>
    <content><![CDATA[<h3 id="Unity-Shader01"><a href="#Unity-Shader01" class="headerlink" title="Unity Shader01"></a>Unity Shader01</h3><h4 id="什么是渲染流水线？"><a href="#什么是渲染流水线？" class="headerlink" title="什么是渲染流水线？"></a>什么是渲染流水线？</h4><p>流水线的概念早已学过，那么渲染流水线又是什么。首先要区别于GPU（硬件)流水线。</p>
<p>分为三个概念上的阶段，每个阶段又有子流水线。</p>
<p>应用阶段：开发者支配的阶段，输入场景、贴图、摄像机、光源等等；输出点、线、三角面等渲染图元。</p>
<p>几何阶段（geometry): 这个阶段主要决定渲染哪些图元，以及将这些图元映射到二维平面上，包括着色，深度值，坐标。</p>
<p>光栅化阶段（rasterization): 这个阶段同上一个阶段都是在GPU上进行，利用上一阶段的数据绘制出像素。先是逐顶点处理，然后是像素处理。</p>
<h4 id="CPU与GPU之间"><a href="#CPU与GPU之间" class="headerlink" title="CPU与GPU之间"></a>CPU与GPU之间</h4><p>CPU控制数据从HDD(硬盘)中加载到显卡的显存（VRAM)中，数据包括位置、顶点着色、法线方向等。</p>
<p>指定渲染状态，例如使用哪个顶点/片元着色器，使用哪个光源属性、材质。</p>
<p>准备好后CPU发起Draw Call命令，GPU开始渲染。</p>
<p>对应上面三个阶段。</p>
<h4 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h4><p>已知几何与光栅化阶段在GPU上进行。</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712135412678.png" alt="image-20220712135412678"></p>
<p>—-几何阶段</p>
<p><strong>顶点着色器（Vertex Shader)</strong> 负责顶点几何变换和顶点着色</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712141429317.png" alt="image-20220712141429317"></p>
<p>曲面细分、几何着色器均为可选着色器，分别用来细分图元和产生图元（增加）。</p>
<p><strong>裁剪</strong></p>
<p>位置分为完全在相机内，部分在相机内，完全不在相机内</p>
<p>裁剪用来处理部分在相机内的部分，将与相机交点替代相机外的部分。</p>
<p>需要注意的是顶点着色器是可编程的，但裁剪却是不可编程的，是硬件上的固定操作。</p>
<p><strong>屏幕映射</strong></p>
<p>输入三维坐标，映射二维，z不做处理</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712142739290.png" alt="image-20220712142739290"></p>
<p>——光栅化阶段</p>
<p>三角形设置</p>
<p>已知顶点着色器不会记录点与点之间的关系</p>
<p>该过程用来得到三角形边界表达方式，计算像素覆盖情况。</p>
<p><strong>三角形遍历</strong></p>
<p>（Triangle Traversal)</p>
<p>找到覆盖的像素，生成片元。</p>
<p>一个片元并不是真正意义上的像素，而是包含了很多状态的集合 这些状态用于计算每个像素的最终颜色</p>
<p>对三个顶点进行插值，然后三角形内部颜色由三点渐变(gradient)混合而成。</p>
<p><strong>片元着色器</strong></p>
<p>DX中又称为像素着色器（Pixel Shader),不过片元不是真正意义上的像素</p>
<p>可编程</p>
<p>纹理采样，对三个顶点插值后，就可以得到片元的纹理坐标，仅可以影响单个片元，无法传递给邻居</p>
<p><strong>逐片元操作</strong></p>
<p>为OpenGL的说法，DX</p>
<p>具体较复杂</p>
<p><img src="/2022/10/21/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8101/image-20220712145900074.png" alt="image-20220712145900074"></p>
<p>片元着色器执行后，进行模板测试，再开始深度测试</p>
<p>深度测试在坐标屏幕进行，屏幕空间坐标与glViewport所定义的视口大小相关</p>
<p>可用glFragCoord(x,y,z)访问屏幕坐标，z为深度值</p>
<p>现代GPU硬件特性，深度测试可以在片着之前，但是不能同时。</p>
<p>参照<a href="https://zhuanlan.zhihu.com/p/371245442">深度测试 - 知乎 (zhihu.com)</a></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>OpenGL、DX是CPU和GPU之间的桥梁，图形接口（api)</p>
<p>显卡中除了图形处理单元GPU,还有显存(VRAM)。</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要2</title>
    <url>/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/</url>
    <content><![CDATA[<h3 id="Unity-Shader-精要02"><a href="#Unity-Shader-精要02" class="headerlink" title="Unity Shader 精要02"></a>Unity Shader 精要02</h3><h4 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader?"></a>什么是Shader?</h4><p>Shader 翻译为着色器，GPU流水线中对于高度可编程的阶段来说，Shader是可以在GPU上运行的渲染代码；而对于固定流水线来说，</p>
<p>则起着渲染设置的作用。前者有顶点着色器，片元着色器等。</p>
<p>顶点着色器负责顶点变换和数据传递、顶点着色等，片元着色器负责渲染片元（几何处理后的像素）</p>
<p>首先搞清楚Shader的语言，分为GLSL,HLSL和Cg;</p>
<p>Unity Shader 则是在Unity上的实现手段，是一种与渲染打交道的抽象，而与之对应的则是ShaderLab语言</p>
<h4 id="Shader基础"><a href="#Shader基础" class="headerlink" title="Shader基础"></a>Shader基础</h4><p>Untiy 主要有Standard Surface Shader, Unlit Shader, Image Effect Shader 以及 Compute Shader。</p>
<p><strong>Unity Shader基本结构</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;ShaderName&quot;</span>&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡A</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//显卡B</span></span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Properties 声明</strong></p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713074058424.png" alt="image-20220713074058424"></p>
<p>Properties 语义块的作用仅仅是为了让这些属性可以出现在材质面板中。</p>
<p><strong>SubShader</strong></p>
<p>Tags可以进行设置</p>
<p><code>Tags&#123;&quot;Queue&quot; = &quot;Transparent&quot;&#125;</code>  设置渲染顺序</p>
<p><strong>Pass</strong></p>
<p>设置渲染状态</p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713090702796.png" alt="image-20220713090702796"></p>
<p>首先Pass的命名<code>Name&quot;MyPassName&quot;</code></p>
<p>调用其他Unity Shader中的Pass <code>UsePass &quot;MyShader/MyPassName&quot;</code></p>
<p>Pass中的Tags与SubShader中的不一样</p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713091457211.png" alt="image-20220713091457211"></p>
<p>有关FallBack</p>
<p>FallBack “name”如果都没用，就用这个sub shader</p>
<p>FallBack off 关闭，不管了</p>
<p>FallBack “VertexLit” 调用内置的Shader中的Pass</p>
<p><strong>结构</strong></p>
<p><img src="/2022/10/22/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8102/image-20220713092133474.png" alt="image-20220713092133474"></p>
<h4 id="各种着色器"><a href="#各种着色器" class="headerlink" title="各种着色器"></a>各种着色器</h4><p><strong>表面着色器</strong></p>
<p>(Surface Shader)</p>
<p>可以理解为顶点、片元着色器的进一步抽象，Unity中的Shader代码一般如上图所示。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Simple Surface Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Tags&#123;<span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;Opaque&quot;</span>&#125;</span><br><span class="line">        </span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> surface surf Lambert</span></span><br><span class="line">        <span class="keyword">struct</span> Input&#123;</span><br><span class="line">            float4 color : COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>顶点/片元着色器</strong></p>
<p>（Vertex/Fragment Shader)</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/Simple VertexFragment Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">    </span><br><span class="line">        CGPROGRAM <span class="comment">//用来包裹ShaderLab语言</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">float4 <span class="title">vert</span>(<span class="params">float4 v : POSITION</span>) :SV_POSITION</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mul(UNITY_MATRIX_MVP,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">float4 <span class="title">frag</span>() : SV_Target</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>固定函数着色器落后不讨论</p>
<p>从本质上来讲，Unity Shader只包含后两种</p>
<p>表面着色器中SubShader的CG代码会被Unity细分到Pass</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要3</title>
    <url>/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/</url>
    <content><![CDATA[<h3 id="Unity-Shader03"><a href="#Unity-Shader03" class="headerlink" title="Unity Shader03"></a>Unity Shader03</h3><h4 id="线性代数基础"><a href="#线性代数基础" class="headerlink" title="线性代数基础"></a>线性代数基础</h4><h4 id="顶点的坐标空间变换"><a href="#顶点的坐标空间变换" class="headerlink" title="顶点的坐标空间变换"></a>顶点的坐标空间变换</h4><p><strong>模型空间</strong></p>
<p>指的是模型物体前、上、右</p>
<p><strong>裁剪空间</strong></p>
<p>视锥体有六面，称为裁剪平面</p>
<p>其中又有两个平面特殊，分别为靠近摄像机的近裁剪平面和远离摄像机的远裁剪平面。</p>
<p>透视中视锥体呈金字塔状，正交中呈长方体</p>
<p>已知处于几何处理的阶段</p>
<p>现进行投影矩阵</p>
<p><img src="/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/image-20220713173712165.png" alt="image-20220713173712165"></p>
<p><strong>总结</strong></p>
<p>从模型空间到世界空间，再到观察空间，然后裁剪空间，最后屏幕映射到屏幕空间。需要许多变换矩阵。</p>
<p><img src="/2022/10/24/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8103/image-20220714095415512.png" alt="image-20220714095415512"></p>
<p><code>float4 a = float4(1.0,1.0,1.0,1.0);</code>该变量是矩阵还是矢量取决于运算种类和位置。</p>
<p>点积（dot)</p>
<p>矩阵乘法(mul)</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要4</title>
    <url>/2022/10/26/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8104/</url>
    <content><![CDATA[<h3 id="Unity-Shader04"><a href="#Unity-Shader04" class="headerlink" title="Unity Shader04"></a>Unity Shader04</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Chaper5/Simple Shader&quot;</span> &#123; </span><br><span class="line">    SubShader &#123; </span><br><span class="line">    Pass &#123; <span class="comment">//自定义渲染设置</span></span><br><span class="line">        CGPROGR</span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> vertex vert </span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> fragment frag </span></span><br><span class="line">        <span class="function">float4 <span class="title">vert</span>(<span class="params">float4 v: POSITION</span>) : SV POSITION</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> mul (UNITY MATRIX MVP, v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function">fixed4 <span class="title">frag</span>() : SV_Target</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fixed4(<span class="number">1.0</span>, <span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>顶点着色器中</li>
</ul>
<p>POSITION和SV_POSITION是CG/HLSL中的语义（semantic)不可省略。</p>
<p>POSITION告诉Unity将模型的坐标作为输入参数输入到v中。</p>
<p>而SV_POSITION则告诉Unity返回裁剪坐标。</p>
<p>片元着色器中</p>
<p>SV_TARGET也是一个语义，告诉系统将渲染输出存储到渲染目标，默认输出到帧缓存。（1，1，1）表示白色，这里返回了白色。</p>
<p>结构体</p>
<p>用来定义着色器的输入</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> a2v&#123;   <span class="comment">//a2v意思是将应用阶段数据传到顶点着色器</span></span><br><span class="line">    <span class="comment">//用模型坐标填充</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    <span class="comment">//用法线方向填充</span></span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    <span class="comment">//TEXCOORD0告诉系统用第一条纹理坐标填充</span></span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unity <strong>支持的语义有：</strong> POSITION, TANGENT, NORMAL, TEXCOORDO, TEXCOORDJ, TEXCOORD2, TEXCOORD3, COLOR 等。</p>
<p><code>struct StructName&#123;TypeName name : Semantic;&#125;;</code></p>
<h4 id="顶点与片元着色器通信"><a href="#顶点与片元着色器通信" class="headerlink" title="顶点与片元着色器通信"></a>顶点与片元着色器通信</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> v2f&#123; <span class="comment">//从顶点着色器到片元</span></span><br><span class="line">    <span class="comment">//pos中包含了裁剪空间的位置信息</span></span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    <span class="comment">//COLOR0用来存储颜色信息</span></span><br><span class="line">    float3 color : COLOR0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为完整代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Unity Shaders Book/Simple Shader&quot;</span>&#123;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="keyword">pragma</span> fragment frag</span></span><br><span class="line">			<span class="comment">//将模型坐标输入到顶点着色器</span></span><br><span class="line">            <span class="keyword">struct</span> a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line">			<span class="comment">//将顶点数据输出到片元</span></span><br><span class="line">            <span class="keyword">struct</span> v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//顶点着色器，逐顶点调用</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span>(<span class="params">a2v v</span>)</span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line">                o.color = v.normal * <span class="number">0.5</span>+fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//逐片元调用</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span>(<span class="params">v2f i</span>) : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">	_Color(<span class="string">&quot;Color Tint&quot;</span>,Color) = (<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要注意的是，在CG代码中需要定义出名称类型都一致的变量</span></span><br><span class="line"></span><br><span class="line">SubShader&#123;</span><br><span class="line">    Pass&#123;</span><br><span class="line">        CGPROGRAM</span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别ShaderLab和CG的变量</p>
<p><img src="/2022/10/26/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8104/image-20220714112206997.png" alt="image-20220714112206997"></p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>已知真正的Shader不是简单的一个<code>.shader</code>文件。</p>
<p>UnityShader 的方便性使得不用开发者自己转换法线方向，处理光照阴影等。</p>
<p>类似于C++的头文件,写在CG中，根据情况下载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">ENGCG</span><br></pre></td></tr></table></figure>

<h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>ColorPicker.cs绑定摄像机，获取屏幕RGB值</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>有关CG/HLSL的语义，可参照微软DX文档</p>
<p>语义主要是用来限定输入输出的字符串，决定输入输出来源去向，方式等。</p>
<p>SV（system value semantics)</p>
<p>定义复杂变量类型时，需要注意，一个语义，寄存器只能存储4个浮点数，所以可以采取分成4个变量表示一个矩阵</p>
<p>shader中不要除以0</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 01</title>
    <url>/2022/10/27/%E8%99%8E%E4%B9%A6/01/</url>
    <content><![CDATA[<h1 id="Computer-Graphics-01"><a href="#Computer-Graphics-01" class="headerlink" title="Computer Graphics 01"></a>Computer Graphics 01</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p><code>However, for the foreseeable future, a good heuristic is that programmers</code></p>
<p><code>should pay more attention to memory access patterns than to operation counts.</code></p>
<p>因为内存的速度跟不上处理器的速度</p>
<h2 id="Miscellaneous-Math"><a href="#Miscellaneous-Math" class="headerlink" title="Miscellaneous Math"></a>Miscellaneous Math</h2><p>2.1 集合和映射</p>
<p>2.2 解决二次等式</p>
<p>2.3 三角学（trigonometry) 勾股，三角函数，角</p>
<p>…</p>
<p>2.4.4 叉乘（cross product)</p>
<p><strong>a</strong> x <strong>b</strong> = |ab| sin (theta)</p>
<p>…</p>
<h4 id="Curve-and-Surface"><a href="#Curve-and-Surface" class="headerlink" title="Curve and Surface"></a>Curve and Surface</h4><p>从1d 到3d的积分，参数方程</p>
<h4 id="Linear-Interpolation"><a href="#Linear-Interpolation" class="headerlink" title="Linear Interpolation"></a>Linear Interpolation</h4><p><code>p = (1 - t)a + tb</code></p>
<p>barycentric 重心坐标</p>
<p>cardinality 集合基数</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要5</title>
    <url>/2022/10/27/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8105/</url>
    <content><![CDATA[<h3 id="UnityShader-05"><a href="#UnityShader-05" class="headerlink" title="UnityShader 05"></a>UnityShader 05</h3><h4 id="Unity中的基本光照"><a href="#Unity中的基本光照" class="headerlink" title="Unity中的基本光照"></a>Unity中的基本光照</h4><p>光线是如何产生的，光源发射光，一些物体与光交互，吸收一些光，散射一些光，而摄像机吸收一些光，形成了图像。</p>
<p>在光学中，使用<strong>辐照度</strong>（irradiance)来量化光。</p>
<p>那么如何计算辐照度呢？</p>
<p>辐照度与照射到物体表面光线之间的距离<code>d/cosx</code>成反比。</p>
<p>当光垂直下落<code>cosx=1</code>,那么距离为d</p>
<p>当光与竖直方向呈x度角，距离为<code>d/cosx</code></p>
<p>其中x可以由表面法线n和光源方向l的点积得到。</p>
<h5 id="散射与吸收"><a href="#散射与吸收" class="headerlink" title="散射与吸收"></a>散射与吸收</h5><p>散射（scatering)只改变光线方向，不改变光线的密度和颜色。散射的光线一般有两种方向，一种是向物体内部折射（refraction)或透射（transmission);另一种是反射（reflection)到外部。</p>
<p>为了区分两种散射，用<strong>高光反射</strong>（specular)和<strong>漫反射</strong>（diffuse)分别表示物体如何反射以及计算多少光线折射、吸收(absorption)、反射出表面。</p>
<p>根据光线的入射方向和入射量可以得到出射度（exitance)</p>
<h5 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h5><p>根据一系列的信息得到计算出射度的等式，也即光照模型。（lighting model )</p>
<h5 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h5><ul>
<li><p>自发光（emissive) 光线直接由光源进入摄像机，直接用材质的自发光颜色。</p>
</li>
<li><p>高光反射（specular)</p>
</li>
<li><p>漫反射（diffuse)</p>
<p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间角的余弦值 成正比。因此， 漫反射部分的计算如下</p>
<p><img src="/2022/10/27/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%8105/image-20220715170258041.png" alt="image-20220715170258041"></p>
<p>c light 和 m diffuse 分别表示光源颜色和漫反射颜色</p>
</li>
<li><p>环境光（ambient) 一般是全局变量</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要6</title>
    <url>/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/</url>
    <content><![CDATA[<h2 id="Chapter6-Diffuse"><a href="#Chapter6-Diffuse" class="headerlink" title="Chapter6_Diffuse"></a>Chapter6_Diffuse</h2><h3 id="逐顶点计算漫反射"><a href="#逐顶点计算漫反射" class="headerlink" title="逐顶点计算漫反射"></a>逐顶点计算漫反射</h3><p>漫反射光照符合兰伯特定律 (Lambert’s law): 反射光线的强度与表面法线和光源方向之间</p>
<p>角的余弦值 。因此， 漫反射部分的计算如下</p>
<p>c_diffuse=( light * m_diffuse) max( n . I ) </p>
<p>中， n是表面法线,I 是指向光源的单位矢量 ,m_diffuse 是材质的漫反射颜色 ,light 是光源颜色。</p>
<p>需要注意的是 我们需要防止法线和光源方向点乘的结果为负值，为此 我们使用取最大值的函数来将其截取到 o, 这可以防止物体被从后面来的光源照亮。</p>
<p><em>以下为具体代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//顶点着色器代码</span><br><span class="line">          v2f vert(a2v v)&#123;</span><br><span class="line">              v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">              //将顶点信息从模型空间传递到投影空间</span><br><span class="line">              o.pos = mul(UNITY_MATRIX_MVP,v.vertex);</span><br><span class="line"></span><br><span class="line">              //获取环境光</span><br><span class="line">              fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">              //将法线从模型空间传递到世界空间,</span><br><span class="line">              fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line"></span><br><span class="line">              //获取世界空间的光照方向</span><br><span class="line">              fixed3 worldLight = normalizze(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line"></span><br><span class="line">              //计算漫反射  saturate：饱和,用于将数据截取到【0，1】之间</span><br><span class="line">              fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line"></span><br><span class="line">              o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">              return o;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>详情见P128.</p>
<p>矩阵变换见P86</p>
<p>要注意，非统一缩放，<strong>经计算得知</strong>会导致，法线不再垂直，所以不能用M(A-B)矩阵</p>
<p>需要用变换矩阵的<em>逆转置矩阵</em></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>1.进行漫反射计算，需要法线，光照，但是需要两者在同一空间下，这里是世界空间，并且法线变换不同于顶点变换</p>
<p><em>法线变换mv方法</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//右乘mv逆矩阵</span><br><span class="line">fixed3 worldNormal = normalize(mul(v.normal,(float3x3)_World2Object));</span><br><span class="line">//因为左乘逆转置矩阵，</span><br><span class="line">//it为逆转置，其实对于正交来说，等于原来变换矩阵，但不是正交矩阵，会出现上述法线问题</span><br></pre></td></tr></table></figure>

<p>2.一个矩阵可以左乘达成mv变换，那么它的逆矩阵就可以达成vm变换；逆=换方向，转=换位置</p>
<p><img src="/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660737217984.png" alt="uTools_1660737217984"></p>
<h3 id="逐像素计算漫反射"><a href="#逐像素计算漫反射" class="headerlink" title="逐像素计算漫反射"></a>逐像素计算漫反射</h3><p>类似于顶点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Books/Chapter6/Pixel_Level&quot;&#123;</span><br><span class="line">     Properties&#123;</span><br><span class="line">        //初始化Color属性,得到并控制漫反射颜色,设置为白色</span><br><span class="line">        _Diffuse(&quot;Diffuse&quot;,Color)=(1,1,1,1)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader&#123;</span><br><span class="line">        // Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        //顶点片元着色器代码要写在pass通道中</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //正确定义lightmode才可以得到unity内置光照变量，该Tag用于定义pass的角色</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line">            //获取properties中的变量</span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            //定义顶点着色器的输入输出结构体,同时输出也是片元的输入</span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal :NORMAL;  //将模型顶点法线信息保存</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0;  //将光照颜色传递给片元着色器，也可以用 XCOORDO 语义。</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            //顶点着色器代码,由于顶点着色器不参加计算，只要获取到坐标和世界法线</span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;   //用于输出</span><br><span class="line"></span><br><span class="line">                //将顶点信息从模型空间传递到投影空间</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                // //获取环境光</span><br><span class="line">                // fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">                //将法线从模型空间传递到世界空间</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal,(float3x3)unity_WorldToObject));</span><br><span class="line">                // //获取世界空间的光照方向</span><br><span class="line">                // fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz); //只有一个光源且为平行光才有用</span><br><span class="line">                // //计算漫反射  saturate：饱和</span><br><span class="line">                // fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLight));</span><br><span class="line">                // o.color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //逐像素计算</span><br><span class="line">            fixed4 frag(v2f i) :SV_TARGET&#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                //法线</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //获取光照方向</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal,worldLightDir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line">                </span><br><span class="line">                return fixed4(color,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果全黑</p>
<p><img src="/2022/10/28/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter6/uTools_1660751437397.png" alt="uTools_1660751437397"></p>
<p>在片元着色器计算结果更加平滑，但是光照不到的地方全黑；</p>
<p>全黑可以通过添加环境光</p>
<p>但是背光区却和向光区明暗一致，这时可以用<strong>半兰伯特模型</strong></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 02</title>
    <url>/2022/10/28/%E8%99%8E%E4%B9%A6/02/</url>
    <content><![CDATA[<h1 id="02"><a href="#02" class="headerlink" title="02"></a>02</h1><h2 id="Raster-Images"><a href="#Raster-Images" class="headerlink" title="Raster Images"></a>Raster Images</h2><ul>
<li><p>光栅以矩形像素数组的形式展示图片</p>
</li>
<li><p>光栅在需要图片的输入设备中也很流行。电子相机包含一个图片传感器，这个传感器由一个光敏像素网格组成。每个像素记录颜色和照在上面的光强。</p>
</li>
<li><p>光栅图片常用于存储和处理图片。光栅图片是一个简单的二维数组，存储每个像素的像素值。</p>
</li>
<li><p>除了光栅图片，还有vector image 用于存储描述形状，颜色范围，存储直线和曲线。</p>
</li>
</ul>
<p><strong>以下讨论raster image的基础和展示，特别关注于标准显示的非线性。其中像素值如何关联光强将会是很重要的</strong></p>
<h2 id="Raster-Device"><a href="#Raster-Device" class="headerlink" title="Raster Device"></a>Raster Device</h2><p>当今的显示器，包括电视，数字电影投影仪和电脑的显示器和投影仪一样，几乎都是基于固定像素数组。</p>
<p>他们可以被分为<strong>放射显示器</strong>（利用像素直接放射可控量的光）</p>
<p>和<strong>透射显示器</strong>（自己不发光，但是其他光源能够透过），需要一个lamp照射到screen上</p>
<h2 id="Images-Pixels-and-Geometry"><a href="#Images-Pixels-and-Geometry" class="headerlink" title="Images,Pixels,and Geometry"></a>Images,Pixels,and Geometry</h2><p><strong>首先我们要知道gamma校正</strong>，见本文末“补充”</p>
<p>然后</p>
<p>设定一个处于黑和白中间的强度 <code>0.5 = a ^ gamma</code></p>
<p>1.一个黑像素与白像素像交替的图片</p>
<p>2.一张灰色像素的图片</p>
<p>如果你是近视的，从远处看，这两张图会差不多</p>
<p>=&gt;根据这个道理</p>
<p>我们可以得到<code>a‘ = a^(1/gamma)</code></p>
<p>其中a为输入值，a’是输出值，由于有8bits的存储量</p>
<p>=&gt;a可能的值为{0/255，1/255，…,255/255} ^ gamma</p>
<h2 id="RGB-Color"><a href="#RGB-Color" class="headerlink" title="RGB Color"></a>RGB Color</h2><p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/image-20221028231837391.png" alt="image-20221028231837391"></p>
<p>大部分计算机图像都是用rgb来定义颜色</p>
<p>颜色叠加公式</p>
<p>详情见P75</p>
<h2 id="Image-Storage"><a href="#Image-Storage" class="headerlink" title="Image Storage"></a>Image Storage</h2><p>大部分rgb格式的图片,为三个通道，每个分配8bit</p>
<p>并且大部分格式的图片支持压缩（compression)</p>
<p>压缩又分为有损压缩和无损压缩</p>
<p><strong>为什么不让monitor(显示器)变成线性的，来避免gamma校正呢？</strong></p>
<blockquote>
<p>Ideally, the 256 possible intensities of a monitor should <em>look</em> evenly spaced as</p>
<p>opposed to being linearly spaced in energy. Because human perception of in</p>
<p>tensity is itself nonlinear, a gamma between 1.5 and 3 (depending on viewing</p>
<p>conditions) will make the intensities approximately uniform in a subjective sense.</p>
<p>In this way, gamma is a feature. Otherwise, the manufacturers would make the</p>
<p>monitors linear.</p>
</blockquote>
<p>理想情况下，256种强度的显示器应该是看起来能量均匀分布而不是线性分布。</p>
<p>因为人类感知本来就不是线性的。一个1.5到3的gamma值可以几乎让人从主观的感觉区分每种强度。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><font jump="补充">补充</font></h3><p><strong>根据百度</strong>：</p>
<p><code>Gamma源于CRT（显示器/电视机）的响应曲线，即其亮度与输入电压的非线性关系。</code></p>
<ul>
<li><p><strong>为什么显示器要Gamma校正</strong> 因为人眼对亮度的感知与物理功率不成正比，而是幂函数的关系，这个指数通常是2.2，称为Gamma值。</p>
</li>
<li><p>例如，功率为50%的灰色，人眼实际感知亮度为<code>pow(0.5,1/2.2) * 100% = 72.97%</code></p>
<p>但是人眼认为的50%的灰色，实际功率为<code>pow(0.5,2.2) * 100% = 21.76%</code></p>
<p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/02%5CuTools_1667052564080.png" alt="uTools_1667052564080"></p>
<p><img src="/2022/10/28/%E8%99%8E%E4%B9%A6/02/02%5CuTools_1667052057309.png" alt="uTools_1667052057309"></p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Gamma校正的应用之一，就是明度和灰度计算公式。</p>
<p><strong>RGB明度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/6e778b35764a65eed7a22fa000b7dcf4.svg" alt="img"></p>
<p>L取值范围为0~1</p>
<p><strong>RGB灰度计算公式：</strong></p>
<p><img src="https://bkimg.cdn.bcebos.com/formula/61b798fe6cddb99adc44b1aae1c92c22.svg" alt="img"></p>
<p><strong>注意这里的2.2次方和2.2次方根，RGB颜色值不能简单直接相加，而是必须用2.2次方换算成物理光功率。</strong>因为RGB值与功率并非简单的线性关系，而是幂函数关系，这个函数的指数称为Gamma值，一般为2.2，而这个换算过程，称为Gamma校正。</p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7</title>
    <url>/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/</url>
    <content><![CDATA[<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们通常用一张纹理代替物体漫反射</p>
<h3 id="单纹理贴图"><a href="#单纹理贴图" class="headerlink" title="单纹理贴图"></a>单纹理贴图</h3><p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span><br><span class="line"></span><br><span class="line">// Upgrade NOTE: replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter7/SingleTexture&quot;&#123;</span><br><span class="line"></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTex(&quot;Main Tex&quot;,2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">        _Specular(&quot;Specular&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _Gloss(&quot;Gloss&quot;,Range(8.0,256)) = 20</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed3 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST; //TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算， 确保材质球里的缩//放和偏移设置是正确的。 （v.texcoord就是顶点的uv）</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex :POSITION;</span><br><span class="line">                float3 normal :NORMAL;</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">                float2 uv : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line"></span><br><span class="line">                o.uv = v.texcoord.xy + _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                //get normal</span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                //get lightdir</span><br><span class="line">                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos)); //输入世界坐标，返回该点到光源方向</span><br><span class="line">                //拿采样结果和color的乘积作为反射率</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //计算环境光</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                //计算漫反射</span><br><span class="line">                fixed3 diffuse =  _LightColor0.rgb * albedo.rgb * max(0,dot(worldNormal,worldLightDir));</span><br><span class="line"></span><br><span class="line">                //朝向光源</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));//_WorldCameraPos - o.wroldPos(not normalized)</span><br><span class="line">                //halfDir代替出射光,worldLightDir指向交点</span><br><span class="line">                fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">                //计算高光,发现reflect*viewDir 变成了normal*halfDir</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal , halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/uTools_1660877749523.png"></p>
<p>中间由于将halfDir 、diffuse声明为fixed，导致高光方向错误</p>
<p><code>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code></p>
<p>tilling 和 offset==&gt; 平铺和偏移系数</p>
<h3 id="凹凸映射"><a href="#凹凸映射" class="headerlink" title="凹凸映射"></a>凹凸映射</h3><p><em>分为高度贴图和法线贴图；前者记录深度值，后者记录法线</em>，一般法线映射认为是凹凸贴图的等价（实际不然）</p>
<p>而法线纹理中，又分为模型空间下的和切线空间下的，一般用切线空间下的法线贴图更方便</p>
<p><strong>切线空间指的是以某点切线、副切线、法线为三个坐标轴的空间（副切线有时也称为Binormal)</strong></p>
<h4 id="切线空间下的光照模型的计算"><a href="#切线空间下的光照模型的计算" class="headerlink" title="切线空间下的光照模型的计算"></a>切线空间下的光照模型的计算</h4><p><em>计算副法线Binormal</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Compute the binormal </span><br><span class="line">//float3 binormal = cross (normalize (v . normal), normalize (v. tangent. xyz )) * </span><br><span class="line">v . tangent.w; </span><br><span class="line">//Cons rue matrix which transform vectors from object space to tangent spac e </span><br><span class="line">//float3x3 rotation= float3x3(v . tangent . xyz , binormal, no mal)</span><br><span class="line">//Or just use the built-in macro </span><br><span class="line">TANGENT SPACE ROTATION;</span><br></pre></td></tr></table></figure>

<p>如果再法线纹理中没有设置为Normal Map,需要再代码中手动设置；这是为了方便Unity优化法线纹理的存储压缩</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Or mark the texture as &quot;Noramal Map&quot;</span></span><br><span class="line">tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">tangentNormal.xy *= _BumpScale; <span class="comment">//控制凹凸程度</span></span><br><span class="line">tangentNormal.z = sqrt(<span class="number">1.0</span>-saturate(dot(tangentNormal.xy,tangentNormal.xy)));<span class="comment">//由于是单位矢量，直接计算出z</span></span><br></pre></td></tr></table></figure>

<p>使用tex2D返回_BumpMap的采样</p>
<p><code> fixed4 packedNormal = tex2D(_BumpMap,i.uv.zw);</code></p>
<p><strong>结果</strong></p>
<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/uTools_1660905878189.png" alt="uTools_1660905878189"></p>
<h4 id="世界空间下计算光照"><a href="#世界空间下计算光照" class="headerlink" title="世界空间下计算光照"></a>世界空间下计算光照</h4><p>插值寄存器只能存放最大float4,无法存放矩阵，所以声明三个float4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                // float3 lightDir : TEXCOORD1;</span><br><span class="line">                // float3 viewDir : TEXCOORD2;</span><br><span class="line"></span><br><span class="line">                //WorldSpace</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                Float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //一个uv存两张图</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw; </span><br><span class="line"></span><br><span class="line">                //WorldSpace-----------</span><br><span class="line">                fixed3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal,worldTangent) * v.tangent.w;//叉乘</span><br><span class="line">                </span><br><span class="line">                //Compute transform matrix</span><br><span class="line">                o.TtoW0 = float4(worldTangent.x,worldBinormal.x,worldNormal.x,worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y,worldBinormal.y,worldNormal.y,worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z,worldBinormal.z,worldNormal.z,worldPos.z);</span><br><span class="line"></span><br><span class="line">                //---------------------</span><br><span class="line">                // //计算副法线</span><br><span class="line">                // TANGENT_SPACE_ROTATION;</span><br><span class="line"></span><br><span class="line">                // //将模型空间的光线变换到切线空间中</span><br><span class="line">                // o.lightDir = mul(rotation,ObjSpaceLightDir(v.vertex).xyz);</span><br><span class="line">                // //同时将视角方向传递到切线空间</span><br><span class="line">                // o.viewDir = mul(rotation,ObjSpaceViewDir(v.vertex).xyz);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">                </span><br><span class="line">                //get worldpos</span><br><span class="line">                fixed3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);</span><br><span class="line"></span><br><span class="line">                //compute light and view dir</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                fixed3 bump= UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">                bump.xy *= _BumpScale ; </span><br><span class="line">                bump.z = sqrt(1.0- saturate(dot(bump.xy, bump.xy))); </span><br><span class="line">                // Transform the normal from tangent space to wo ld space </span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz,bump), </span><br><span class="line">                dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //-------------</span><br><span class="line">                 //tex2d 返回float4,普通纹理返回颜色值 bump则是法向量</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex,i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * max(0,dot(bump,lightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line"></span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(bump,halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">            &#125;  </span><br></pre></td></tr></table></figure>

<p><img src="/2022/10/29/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7/image-20220820083553612.png" alt="image-20220820083553612"></p>
<p><strong>CreateFromGrayscale</strong> 用高度图生成切线空间法线纹理</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 03</title>
    <url>/2022/10/31/%E8%99%8E%E4%B9%A6/03/</url>
    <content><![CDATA[<h1 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h1><p><strong>Why Ray Tracing?</strong></p>
<ul>
<li>rasterization : real-time,ray tracing: offline</li>
<li>ray tracing is accurate,but is very slow</li>
</ul>
<p><strong>Whitted-Style Ray Tracing</strong></p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667388590899.png" alt="uTools_1667388590899"></p>
<p>渲染3d物体时计算机图形的工作之一。</p>
<p>同一场景的物体渲染需要考虑每个物体贡献的像素。</p>
<p>有两种常规的方法来考虑</p>
<ul>
<li>object-order rendering ,通过找物体来计算对应像素</li>
<li>image-order rendering，通过找像素来判断物体，然后计算像素</li>
</ul>
<p>差别可以这么来看</p>
<p>前者双重循环外循环是物体，后者则是像素</p>
<p>宽泛来说，image-order rendering 是更加简单和灵活的，一般来说也会有更长的执行事件来制造同样的图片。</p>
<p><strong>Ray Tracing 就是image-order algorithm</strong>因为这样不需要像前者一样用数学器械就能实现光线追踪器。</p>
<h2 id="The-Basic-Ray-Tracing-Algorithm"><a href="#The-Basic-Ray-Tracing-Algorithm" class="headerlink" title="The Basic Ray-Tracing Algorithm"></a>The Basic Ray-Tracing Algorithm</h2><p>基本的光线追踪器有三个部分</p>
<p>某种意义上，在引擎中，可以认为“眼睛发光”</p>
<ol>
<li><p>ray generation. 计算每个像素的view射线的来源和方向</p>
</li>
<li><p>ray intersection. 计算与view射线相交的最近物体</p>
</li>
<li><p>shading. 在原有的射线相交的基础上进行着色</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667218571247.png" alt="uTools_1667218571247"></p>
</li>
</ol>
<h2 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h2><p>标准的方法来为计算机图形，艺术和照片制作图片，是使用linear perspective(线性透视)</p>
<p>parallel projection(平行投影)是最简单的投影方式，平移。一般用于机械和建筑</p>
<p>如果image plane和视线方向垂直，成为orthograph(正交投影)  orthonormal(正交的)</p>
<h2 id="Compute-View-Ray"><a href="#Compute-View-Ray" class="headerlink" title="Compute View Ray"></a>Compute View Ray</h2><p>phase 1</p>
<p>为了生成ray,我们首先需要一个数学表达</p>
<p><code>p(t) = e + t(s- e)</code></p>
<p>e is eye,    s is image plane point</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667219704846.png" alt="uTools_1667219704846"></p>
<p>在代码中</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667219881824.png" alt="uTools_1667219881824"></p>
<p>详情见P84</p>
<h3 id="Orthographic-Views"><a href="#Orthographic-Views" class="headerlink" title="Orthographic Views"></a>Orthographic Views</h3><p>对于正交投影view ray,</p>
<p>ray generation 使用相机的框架，</p>
<ol>
<li><p>正交投影从image plane的一个像素的位置开始，并且全部共享相同的方向—-view direction.</p>
</li>
<li><p>而透视投影则是选择一个view point 开始，方向则是view point 到image plane的点的位置。</p>
</li>
</ol>
<p><strong>要将nx  ny 的像素投射到(r - l) x (t - b)的矩形上</strong></p>
<p>其中l,r分别是片元，pixel的左右边界坐标，b和t则是下、上边界坐标</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667220608282.png" alt="uTools_1667220608282"></p>
<p>详情见P86</p>
<h3 id="Perspective-Views"><a href="#Perspective-Views" class="headerlink" title="Perspective Views"></a>Perspective Views</h3><h2 id="Ray-Object-Intersection"><a href="#Ray-Object-Intersection" class="headerlink" title="Ray-Object Intersection"></a>Ray-Object Intersection</h2><p>phase 2</p>
<h3 id="Ray-Sphere-Intersection"><a href="#Ray-Sphere-Intersection" class="headerlink" title="Ray-Sphere Intersection"></a>Ray-Sphere Intersection</h3><p>使用implicit surface</p>
<p>隐式表达式f(p(t)) = 0或者f(e + td) = 0</p>
<p>对于一个球来说，设中心点为c</p>
<p><code>(p - c)(p - c) - R^2 = 0</code></p>
<p><strong>注意，当满足上式，说明p对应的点已经在球上，也即intersection</strong></p>
<p><code>(e + t d - c)(e + td - c) - R^2 = 0</code></p>
<p>只有t未知</p>
<p>展开得到quadratic 二次方程，判别式b^2 - 4ac</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667222501427.png" alt="uTools_1667222501427"></p>
<h2 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h2><p>Here we will discuss how a ray tracer computes the inputs to shading</p>
<p>1.从点光源和直线光计算着色需要具体的几何信息。当viewing ray 确定与表面相交，我们需要决定以下4个向量。</p>
<ul>
<li>着色点x可以通过估算viewing ray 以t的值相交</li>
<li>表面的法线向量n</li>
<li>光源方向l</li>
<li>视觉射线viewing direction 是viewing ray的反方向（v = -d/|d|)</li>
</ul>
<p>2.coding</p>
<p>3.一旦你已经在光线追踪器上有基本的着色后，光线和点阴影添加会很容易</p>
<p><img src="/2022/10/31/%E8%99%8E%E4%B9%A6/03/uTools_1667389464606.png" alt="uTools_1667389464606"></p>
<p>使用directional light 的阴影与点光源类似，但是t=无穷，也即距离无穷，环境光不进行阴影测试（shadow test)</p>
<p>4.Mirror Reflection(镜面反射)</p>
<p>为光线追踪程序添加镜面发射（or specular reflection) 很直接。</p>
<p>由视线计算反射光向量，<strong>易得</strong></p>
<p><code>r = d - 2(d*n)*n</code></p>
<p>其中r是反射向量，d是view(视线)入射的向量</p>
<p><strong>在现实世界中，当光线从表面反射出去，一定会有能量损失</strong></p>
<p>由于光线颜色不同，损失也会不一样，这里使用递归算法(recursive)</p>
<p>调用shader-ray函数。</p>
<p><code>color c = c + k * shader-ray(Ray(p,r),t,infinity)</code></p>
<p>k是specular rgb color, 并且t = infinity,和shadow一样。因为并不想让光线反射到光源上</p>
<h2 id="Frequently-Asked"><a href="#Frequently-Asked" class="headerlink" title="Frequently Asked"></a>Frequently Asked</h2><ul>
<li><p>为什么ray tracing 中没有透视矩阵</p>
</li>
<li><p>可以实现交互式光线追踪吗</p>
<p>对于充分小的模型和图片，任何现代pc都足以支持可交互式光线追踪。现实中，对于全屏的实现，多cpu共享帧缓存区是需要的。</p>
<p>计算机算力进步比屏幕分辨率更快，让传统pc在屏幕分辨率下实现复杂场景光线追踪只不过是时间问题。</p>
</li>
<li><p>ray tracing在硬件图形程序中有用吗</p>
<p>光线追踪经常用于<strong>采集</strong>，当用户点击鼠标3d图形程序的像素，程序需要决定哪个物体的显示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要7-1</title>
    <url>/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/</url>
    <content><![CDATA[<h2 id="Chapter7"><a href="#Chapter7" class="headerlink" title="Chapter7"></a>Chapter7</h2><h3 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h3><p>冷色调转暖色调，编写卡通风格Unity Shader（<em>记录：区别BlinnPhong和Phong高光计算</em>，另外如果计算新的漫反射albedo,就不用声明_Diffuse来计算diffuse）</p>
<p><em>代码</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">               fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">               fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line"></span><br><span class="line">               fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;  //</span><br><span class="line"></span><br><span class="line">               //使用纹理来采样漫反射,使用半兰伯特模型</span><br><span class="line">               fixed halfLambert = 0.5 * dot(worldNormal,worldLightDir) + 0.5;</span><br><span class="line">               fixed3 diffuseColor = tex2D(_RampTex,fixed2(halfLambert,halfLambert)).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">               fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br><span class="line"></span><br><span class="line">               //计算高光BlinnPhong模型</span><br><span class="line">               fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">               fixed3 halfDir = normalize(worldLightDir + viewDir);</span><br><span class="line">               fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0,dot(worldNormal,halfDir)),_Gloss);</span><br><span class="line">               </span><br><span class="line">               return fixed4(ambient + diffuse + specular,1.0);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



<p>注意使用<code>fixed2(halfLambert,halfLambert)</code>会发生大于1的情况（1.0001）,这样映射到模型上会出现黑点</p>
<p>此时需要将纹理的WrapMode从Repeat(重复，但是最左边是黑色的）换成Clamp(大于1取1)</p>
<p><img src="/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5Cimage-20220820110835470.png" alt="image-20220820110835470"></p>
<h3 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h3><p>使用高光遮罩纹理，遮罩纹理用于更加细致地控制高光反射光强度</p>
<p>变量声明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">fixed4 _Color;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line"><span class="comment">//float4 _BumpMap_ST;</span></span><br><span class="line"><span class="built_in">float</span> _BumpScale;</span><br><span class="line">sampler2D _SpecularMask;</span><br><span class="line"><span class="comment">//float4 _SpecularMask_ST;</span></span><br><span class="line"><span class="built_in">float</span> _SpecularScale;</span><br><span class="line">fixed4 _Specular;</span><br><span class="line"><span class="built_in">float</span> _Gloss;</span><br></pre></td></tr></table></figure>

<p><em>这里 _ BumpMap、_ Specular和_MainTex共用一个ST</em></p>
<p>如果每个纹理都需要不同的平铺系数和偏移系数，那么纹理数目增加顶点着色器中的插值寄存器会迅速被占满。</p>
<p><strong>流程</strong></p>
<p>1.该实验使用了三个纹理，分别是基本纹理，切线空间的法线纹理（凹凸贴图），高光遮罩纹理</p>
<p>2.计算是逐像素计算，计算是在切线空间下进行（一定要明确在哪个空间下进行），diffuse用lambert模型</p>
<p>specular用BlinnPhong模型</p>
<p>3.<code>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex;</code>三张纹理共用同一套uv</p>
<p><strong>结果</strong></p>
<p>加上遮罩贴图后高光更加暗淡和谐</p>
<p><img src="/2022/10/31/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1/UnityShader%E7%B2%BE%E8%A6%81Chapter7_1%5CuTools_1660974045813.png" alt="uTools_1660974045813"></p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>Computer Graphics 04</title>
    <url>/2022/11/02/%E8%99%8E%E4%B9%A6/04/</url>
    <content><![CDATA[<h1 id="Surface-Shading"><a href="#Surface-Shading" class="headerlink" title="Surface Shading"></a>Surface Shading</h1><p>渲染3d场景时，无论使用ray tracing还是rasterization，在实时还是在批处理中，<strong>着色</strong>是对视觉效果影响</p>
<p>最大的过程之一</p>
<p>本章描述基于点光源照射的不透明表面基本着色模型。</p>
<h2 id="Point-source-illumination"><a href="#Point-source-illumination" class="headerlink" title="Point source illumination"></a>Point source illumination</h2><p>点光源包括position,intensity</p>
<p>点光源有isotropic(各向同性)</p>
<p>the irradiance E is  <code>E = P/4PI * 1/pow(r,2)</code></p>
<p>the quantity I = P/4PI,是光强(amount of light)，后者是factor</p>
<p>更普遍地，<code>E = I * cos(theta) / pow(r,2)</code>,其中<code>cos(theta) = n * l</code></p>
<p><img src="/2022/11/02/%E8%99%8E%E4%B9%A6/04/uTools_1667393710823.png" alt="uTools_1667393710823"></p>
]]></content>
      <categories>
        <category>Fundamental of Computer Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要8</title>
    <url>/2022/11/02/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/</url>
    <content><![CDATA[<h2 id="Chapter8-透明效果"><a href="#Chapter8-透明效果" class="headerlink" title="Chapter8 透明效果"></a>Chapter8 透明效果</h2><h3 id="实现透明的方法"><a href="#实现透明的方法" class="headerlink" title="实现透明的方法"></a>实现透明的方法</h3><p>unity中通常使用两种方式实现透明效果</p>
<p>1.透明度测试(alpha test),（无法实现真正的半透明）</p>
<p>2.透明度混合(alpha blending)</p>
<p><strong>使用深度测试，可以不考虑渲染顺序</strong>，但是使用透明度混合时，需要关闭*<code>ZWrite</code>*，关闭了深度写入</p>
<p>虽然<em>透明度测试</em>不需要关闭，但是它的机制是如果透明度不满足某个阈值（通常小于），直接舍弃该片元。</p>
<ul>
<li>为什么关闭<code>ZWrite</code>?</li>
</ul>
<p><em>由于深度测试丢弃远处被遮挡部分，但是透明物体的机制是”可以透过并看见远处的物体”。</em></p>
<p>关闭了ZWrite，渲染顺序则成了问题。</p>
<p><strong>流程</strong></p>
<p>1.渲染时，会进行深度测试，如果先渲染后面的不透明b，将b写入颜色缓冲和深度缓冲；然后渲染前面的透明a,a写入颜色缓冲，会发生透明混合，显示正确。</p>
<p>2.如果先渲染a,进行深度测试，写入颜色缓冲，但是关闭了ZWrite，无法写入深度值，然后渲染b，写入深度值，写入颜色缓冲，b的颜色<strong>覆盖</strong>a,只能看见b。</p>
<p>3.半透明物体之间亦然。</p>
<h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>Unity Shader解决方案为SubShader 中的Tags</p>
<p>以下为透明度测试alpha test示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       Tags&#123;<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;AlphaTest&quot;</span> <span class="string">&quot;IgnoreProjector&quot;</span> = <span class="string">&quot;True&quot;</span> <span class="string">&quot;RenderType&quot;</span> = <span class="string">&quot;TransparentCutout&quot;</span>&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;<span class="string">&quot;LightMode&quot;</span> = <span class="string">&quot;ForwardBase&quot;</span>&#125;</span><br><span class="line">           ...</span><br><span class="line">            <span class="comment">//alpha test</span></span><br><span class="line">               clip(texColor.a - _Cutoff);</span><br><span class="line">               <span class="comment">// Equal to </span></span><br><span class="line">               <span class="comment">// if (( exColor - _Cutoff) &lt; 0 . 0) &#123; </span></span><br><span class="line">               <span class="comment">// discard; &#125;</span></span><br><span class="line">           	...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">         &#125;  </span><br></pre></td></tr></table></figure>

<p>每块的透明度都不同，根据面板调整_Cutoff可以看出哪个更低，低的那个会直接被剔除</p>
<p>结果图</p>
<p><img src="/2022/11/02/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/UnityShader%E7%B2%BE%E8%A6%81Chapter8/uTools_1660983793621.png" alt="uTools_1660983793621"></p>
<h3 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">       //alpha blend</span><br><span class="line">       Tags&#123;&quot;Queue&quot;=/*&quot;AlphaTest&quot;*/&quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;TransparentCutout&quot;&#125;</span><br><span class="line">       Pass&#123;</span><br><span class="line">           Tags&#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line">           ZWrite Off</span><br><span class="line">           Blend SrcAlpha OneMinusSrcAlpha  //P170</span><br><span class="line">           ...</span><br><span class="line">           &#125;</span><br><span class="line">           //去掉clip</span><br></pre></td></tr></table></figure>

<h3 id="解决排序问题"><a href="#解决排序问题" class="headerlink" title="解决排序问题"></a>解决排序问题</h3><p><strong>一般先开启深度测试、写入，先渲染不透明物体，然后关闭写入，对不透明物体排序，先渲染后面的物体</strong></p>
<ul>
<li><strong>但是仍然存在很大问题。</strong></li>
</ul>
<p>比如一个物体，各个部分互相遮挡，又或者多个物体，相互遮挡，而深度排序是像素级别的。</p>
<p><strong>问题在于</strong></p>
<p>现在开启ZWrite</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Pass&#123;</span><br><span class="line"> ZWrite On </span><br><span class="line"> ColorMask 0//ColorMask RGB 、 A 、 0 、其他任何rgba的组合</span><br><span class="line"> //0表示不写入任何颜色通道，即只写入深度缓存，不输出颜色</span><br><span class="line"> 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新添加一个Pass通道。该Pass专门用来写入深度缓冲，并且先执行。</p>
<p>Pass通道中加上<code>//Cull Front/Back/Off 需要双面渲染时关闭剔除</code></p>
<p>注意如果关闭了深度写入，此时再双面渲染就会出现半透明错误渲染</p>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
  <entry>
    <title>unityshader精要9</title>
    <url>/2022/11/03/Unity%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/%E4%B8%AD%E7%BA%A7%E7%AF%87Chapter9/</url>
    <content><![CDATA[<h2 id="Complex-Light-Chapter9"><a href="#Complex-Light-Chapter9" class="headerlink" title="Complex Light - Chapter9"></a>Complex Light - Chapter9</h2><h3 id="渲染路径（Rendering-Path"><a href="#渲染路径（Rendering-Path" class="headerlink" title="渲染路径（Rendering Path)"></a>渲染路径（Rendering Path)</h3><p><strong>分为前向渲染路径，延迟渲染路径(更新），顶点渲染路径（弃用）</strong></p>
<p>1.前向渲染路径，如果深度测试不过关，该片元不可见，反之可见，就进行光照计算</p>
<p>2.如果物体受到多个光源照射，就要写多个Pass,然后在帧缓冲中将这些光照结果混合。</p>
<p>3.前向渲染中，光照类型（平行光parallel light或其他）+光照渲染模式（important)决定了处理光照（照亮物体）的方式。</p>
<p>而处理方式分为逐像素，逐顶点、sh计算。</p>
<p>参见P182</p>
<h3 id="Unity光源类型"><a href="#Unity光源类型" class="headerlink" title="Unity光源类型"></a>Unity光源类型</h3><p>1.平行光、点光源、<em>面光源</em>和<em>聚光灯</em>，面光源只在烘焙时才会产生作用</p>
<p>2.当RenderMode是Auto,Unity自动判断哪些光源逐像素，哪些顶点、sh计算。</p>
<p>3.最亮的平行光是按照逐像素计算，而Auto状态下最多除平行光源外4个逐像素计算，这些在addtional pass中计算</p>
<p><strong>最常用的光源属性有：位置、方向、颜色、强度、衰减</strong></p>
<ul>
<li>光照衰弱</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用纹理来计算衰弱值</span></span><br><span class="line"><span class="keyword">fixed</span> atten = tex2D(_ ghtTextureO, dot(lightCoord, lightCoord) .rr) .UNITY_ATTEN_CHANNEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数学公式进行线性衰弱值计算</span></span><br><span class="line"><span class="built_in">float</span> distance = length (_WorldSpaceLightPosO . xyz - i. worldPosi <span class="keyword">on</span>.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> <span class="comment">// distance; // linear attenuation</span></span><br></pre></td></tr></table></figure>



<h3 id="Unity阴影"><a href="#Unity阴影" class="headerlink" title="Unity阴影"></a>Unity阴影</h3><p>1.如果最重要的平行光开启了阴影，那么Unity会为这个光源生成<em>阴影纹理图</em>，一种由光源出发的深度图。</p>
<p>2.另取一个LightMode为ShadowCaster的Pass,Unity会将摄像头放到光源的地方</p>
<p>3.一个物体想要接收阴影，那么在shader中要对纹理采样；相同地，一个物体想要投射阴影，就要参与纹理计算</p>
<p>见P200</p>
<ul>
<li>如何让正方体接收阴影</li>
</ul>
<p>SHADOWCOORD,TRANSFER_SHADOW,SHADOW_ATTENUATION分别在v2f,vert,frag中调用</p>
<p>实现接收阴影</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHADOW_COORDS(2)</span><br><span class="line">TRANSFER_SHADOW(o);</span><br><span class="line">fixed shadow = SHADOW_ATTENUATION(i);</span><br></pre></td></tr></table></figure>



<p><strong>光照衰减和阴影的效果是一样的，于是就有了统一光照衰弱和阴影</strong></p>
<p>unity提供一个方法同时管理这两者</p>
<p><code>UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos);</code></p>
<ul>
<li><p>透明物体的阴影</p>
<p>在AlphaTest的基础上使用上述方法</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity shader</category>
      </categories>
  </entry>
</search>
